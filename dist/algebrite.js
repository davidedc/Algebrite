// Generated by CoffeeScript 1.9.0
(function() {
  var $, ABS, ADD, ADJ, AND, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BINOM_check_args, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, Condense, DEBUG, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DET_check_arg, DIM, DIRAC, DISPLAY, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, EIG_N, EIG_check_arg, EIG_yydd, EIG_yyqq, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_adj, Eval_and, Eval_arccos, Eval_arccosh, Eval_arcsin, Eval_arcsinh, Eval_arctan, Eval_arctanh, Eval_arg, Eval_besselj, Eval_bessely, Eval_binding, Eval_binomial, Eval_ceiling, Eval_check, Eval_choose, Eval_circexp, Eval_clear, Eval_clock, Eval_coeff, Eval_cofactor, Eval_condense, Eval_conj, Eval_cons, Eval_contract, Eval_cos, Eval_cosh, Eval_decomp, Eval_defint, Eval_degree, Eval_denominator, Eval_derivative, Eval_det, Eval_dim, Eval_dirac, Eval_divisors, Eval_do, Eval_dsolve, Eval_eigen, Eval_eigenval, Eval_eigenvec, Eval_erf, Eval_erfc, Eval_exp, Eval_expand, Eval_expcos, Eval_expsin, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_filter, Eval_float, Eval_floor, Eval_for, Eval_gamma, Eval_gcd, Eval_hermite, Eval_hilbert, Eval_imag, Eval_index, Eval_inner, Eval_integral, Eval_inv, Eval_invg, Eval_isinteger, Eval_isprime, Eval_laguerre, Eval_lcm, Eval_leading, Eval_legendre, Eval_log, Eval_mag, Eval_mod, Eval_multiply, Eval_noexpand, Eval_not, Eval_nroots, Eval_number, Eval_numerator, Eval_operator, Eval_or, Eval_outer, Eval_polar, Eval_power, Eval_predicate, Eval_prime, Eval_print, Eval_product, Eval_quote, Eval_quotient, Eval_rank, Eval_rationalize, Eval_real, Eval_rect, Eval_roots, Eval_setq, Eval_sgn, Eval_simfac, Eval_simplify, Eval_sin, Eval_sinh, Eval_sqrt, Eval_stop, Eval_subst, Eval_sym, Eval_tan, Eval_tanh, Eval_taylor, Eval_tensor, Eval_test, Eval_testeq, Eval_testge, Eval_testgt, Eval_testle, Eval_testlt, Eval_transpose, Eval_unit, Eval_user_function, Eval_zero, Evalpoly, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, INV_check_arg, INV_decomp, ISINTEGER, ISPRIME, LAGUERRE, LAST, LCM, LEADING, LEGENDRE, LOG, M, MAG, MAXDIM, MAXPRIMETAB, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MP_MAX_FREE, MP_MIN_SIZE, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NROOTS_ABS, NROOTS_DELTA, NROOTS_EPSILON, NROOTS_RANDOM, NROOTS_YMAX, NROOTS_divpoly, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PI, POLAR, POWER, PRIME, PRINT, PRINTOUTRESULT, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, SECRETX, SELFTEST, SETQ, SGN, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOL_A, SYMBOL_B, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TOS, TRACE, TRANSPOSE, TTY, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEWLINE, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, YMAX, YYE, YYRECT, ZERO, absval, absval_tensor, add, add_all, add_numbers, add_terms, addf, adj, alloc_tensor, allocatedId, any_denominators, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, arg, arglist, bake, bake_poly, bake_poly_term, besselj, bessely, bigInt, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, binomial, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, ceiling, charTabIndex, chartab, check_esc_flag, check_stack, choose, choose_check_args, circexp, clear, clear_symbols, clear_term, clockform, cmpGlyphs, cmp_args, cmp_expr, cmp_terms, cmp_terms_count, coeff, cofactor, collectResultLine, combine_factors, combine_gammas, combine_terms, compare_numbers, compare_rationals, compare_tensors, compatible, compute_fa, conjugate, cons, consCount, contract, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, count_denominators, counter, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, decomp, decomp_product, decomp_sum, define_user_function, defn, defn_str, degree, denominator, derf, derfc, derivative, derivative_of_integral, det, determinant, detg, dfunction, dhermite, dirac, display, display_flag, displaychar, divide, divide_numbers, divisors, divisors_onstack, divpoly, dlog, doubleToReasonableString, dpow, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, echo_input, eigen, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, equal, equaln, equalq, erfc, errorMessage, esc_flag, exec, expand, expand_get_A, expand_get_AF, expand_get_B, expand_get_C, expand_get_CF, expand_tensor, expanding, expcos, exponential, expr_level, expsin, f1, f2, f3, f4, f5, f9, f_equals_a, factor, factor_a, factor_again, factor_b, factor_number, factor_small_number, factor_term, factorial, factorpoly, factors, factpoly_expo, fill_buf, filter, filter_main, filter_sum, filter_tensor, findroot, fixed_top_level_eval, fixup_fraction, fixup_power, flag, fmt_index, fmt_level, fmt_x, frame, free_stack, gamma, gamma_of_sum, gammaf, gcd, gcd_expr, gcd_expr_expr, gcd_factor_term, gcd_main, gcd_numbers, gcd_term_factor, gcd_term_term, gen, get_arglist, get_binding, get_factor, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, hermite, hilbert, imag, imaginaryunit, index_function, init, initNRoots, inited, inner, inner_f, input_str, integral, integral_of_form, integral_of_product, integral_of_sum, inv, inverse, invert_number, invg, is_denominator, is_factor, is_small_integer, is_square_matrix, isadd, isalnum, isalpha, iscomplexnumber, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isimaginarynumber, isimaginaryunit, isinteger, isintegerfactor, iskeyword, isminusone, isminusoneoversqrttwo, ismultiply, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isnum, isoneover, isoneoversqrttwo, isplusone, ispoly, ispoly_expr, ispoly_factor, ispoly_term, isposint, ispower, isquarterturn, isrational, isspace, isstr, issymbol, issymbolic, istensor, iszero, itab, laguerre, laguerre2, lcm, leading, legendre, length, lessp, level, list, logarithm, logbuf, lookupsTotal, lu_decomp, madd, mag, makePositive, makeSignSameAs, mask, mcmp, mcmpint, mdiv, mdivrem, meta_mode, mgcd, mini_solve, mint, mmod, mmul, mod, monic, move, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, n_factor_number, negate, negate_expand, negate_noexpand, negate_number, new_string, newline_flag, nil_symbols, normalize_angle, nroots_a, nroots_b, nroots_c, nroots_df, nroots_dx, nroots_fa, nroots_fb, nroots_x, nroots_y, nterms, numerator, numericRootOfPolynomial, one, oneElement, out_buf, out_count, out_of_memory, outer, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse, parse_internal, parse_p1, parse_p2, partition, peek, peek2, polar, polycoeff, polyform, pop, pop_double, pop_frame, pop_integer, power, power_str, power_sum, power_tensor, prime, primetab, print1, print_a_over_b, print_char, print_denom, print_double, print_expr, print_factor, print_factorial_function, print_it, print_multiply_sign, print_number, print_str, print_subexpr, print_tensor, print_tensor_inner, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, push_cars, push_double, push_factor, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_term_factors, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, rationalize_coefficients, real, reciprocate, rect, remove_negative_exponents, reset_after_error, restore, rewrite_args, rewrite_args_tensor, roots, roots2, roots3, run, save, scalar_times_tensor, scan, scan_error, scan_expression, scan_factor, scan_function_call, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_term, scanned, setM, setSignTo, set_binding, set_binding_and_arglist, set_component, setq_indexed, sfac_product, sfac_product_f, sgn, sign, sign_of_term, simfac, simfac_term, simplify, simplify_main, simplify_polar, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, step, step2, stop, strcmp, stringToBePrinted, subf, subst, subtract, subtract_numbers, swap, symbol, symnum, symtab, tangent, taylor, tensor, tensor_plus_tensor, tensor_times_scalar, test_flag, text_metric, theRandom, token, token_buf, token_str, top_level_eval, tos, transform, transpose, trigmode, trivial_divide, try_kth_prime, ucmp, unique, unique_f, update_token_buf, usr_symbol, verbosing, will_be_displayed_as_fraction, ybinomial, ycosh, ydirac, yerf, yerfc, yfloor, yindex, ysinh, yyarg, yybesselj, yybessely, yyceiling, yycondense, yycontract, yycosh, yydegree, yydetg, yydivpoly, yyerf, yyerfc, yyexpand, yyfactorpoly, yyfloat, yyfloor, yyhermite, yyhermite2, yyinvg, yylcm, yylog, yymag, yymultiply, yyouter, yypower, yyrationalize, yysgn, yysimfac, yysinh, yytangent, zero, __emit_char, __emit_str, __factor_add, __factorial, __is_negative, __is_radical_number, __lcm, __legendre, __legendre2, __legendre3, __normalize_radical_factors, __rationalize_tensor, _i, _j, _k,
    __slice = [].slice;

  bigInt = require('big-integer');

  SELFTEST = 1;

  NSYM = 1000;

  DEBUG = false;

  PRINTOUTRESULT = false;

  rational = (function() {
    function rational() {}

    rational.prototype.a = null;

    rational.prototype.b = null;

    return rational;

  })();

  U = (function() {
    U.prototype.cons = null;

    U.prototype.printname = "";

    U.prototype.str = "";

    U.prototype.tensor = null;

    U.prototype.q = null;

    U.prototype.d = 0.0;

    U.prototype.k = 0;

    U.prototype.tag = 0;

    U.prototype.toString = function() {
      return collectResultLine(this);
    };

    function U() {
      this.cons = {};
      this.cons.car = null;
      this.cons.cdr = null;
      this.q = new rational();
    }

    return U;

  })();

  errorMessage = "";

  CONS = 0;

  NUM = 1;

  DOUBLE = 2;

  STR = 3;

  TENSOR = 4;

  SYM = 5;

  counter = 0;

  ABS = counter++;

  ADD = counter++;

  ADJ = counter++;

  AND = counter++;

  ARCCOS = counter++;

  ARCCOSH = counter++;

  ARCSIN = counter++;

  ARCSINH = counter++;

  ARCTAN = counter++;

  ARCTANH = counter++;

  ARG = counter++;

  ATOMIZE = counter++;

  BESSELJ = counter++;

  BESSELY = counter++;

  BINDING = counter++;

  BINOMIAL = counter++;

  CEILING = counter++;

  CHECK = counter++;

  CHOOSE = counter++;

  CIRCEXP = counter++;

  CLEAR = counter++;

  CLOCK = counter++;

  COEFF = counter++;

  COFACTOR = counter++;

  CONDENSE = counter++;

  CONJ = counter++;

  CONTRACT = counter++;

  COS = counter++;

  COSH = counter++;

  DECOMP = counter++;

  DEFINT = counter++;

  DEGREE = counter++;

  DENOMINATOR = counter++;

  DERIVATIVE = counter++;

  DET = counter++;

  DIM = counter++;

  DIRAC = counter++;

  DISPLAY = counter++;

  DIVISORS = counter++;

  DO = counter++;

  DOT = counter++;

  DRAW = counter++;

  DSOLVE = counter++;

  EIGEN = counter++;

  EIGENVAL = counter++;

  EIGENVEC = counter++;

  ERF = counter++;

  ERFC = counter++;

  EVAL = counter++;

  EXP = counter++;

  EXPAND = counter++;

  EXPCOS = counter++;

  EXPSIN = counter++;

  FACTOR = counter++;

  FACTORIAL = counter++;

  FACTORPOLY = counter++;

  FILTER = counter++;

  FLOATF = counter++;

  FLOOR = counter++;

  FOR = counter++;

  GAMMA = counter++;

  GCD = counter++;

  HERMITE = counter++;

  HILBERT = counter++;

  IMAG = counter++;

  INDEX = counter++;

  INNER = counter++;

  INTEGRAL = counter++;

  INV = counter++;

  INVG = counter++;

  ISINTEGER = counter++;

  ISPRIME = counter++;

  LAGUERRE = counter++;

  LCM = counter++;

  LEADING = counter++;

  LEGENDRE = counter++;

  LOG = counter++;

  MAG = counter++;

  MOD = counter++;

  MULTIPLY = counter++;

  NOT = counter++;

  NROOTS = counter++;

  NUMBER = counter++;

  NUMERATOR = counter++;

  OPERATOR = counter++;

  OR = counter++;

  OUTER = counter++;

  POLAR = counter++;

  POWER = counter++;

  PRIME = counter++;

  PRINT = counter++;

  PRODUCT = counter++;

  QUOTE = counter++;

  QUOTIENT = counter++;

  RANK = counter++;

  RATIONALIZE = counter++;

  REAL = counter++;

  YYRECT = counter++;

  ROOTS = counter++;

  SETQ = counter++;

  SGN = counter++;

  SIMPLIFY = counter++;

  SIN = counter++;

  SINH = counter++;

  SQRT = counter++;

  STOP = counter++;

  SUBST = counter++;

  SUM = counter++;

  TAN = counter++;

  TANH = counter++;

  TAYLOR = counter++;

  TEST = counter++;

  TESTEQ = counter++;

  TESTGE = counter++;

  TESTGT = counter++;

  TESTLE = counter++;

  TESTLT = counter++;

  TRANSPOSE = counter++;

  UNIT = counter++;

  ZERO = counter++;

  NIL = counter++;

  AUTOEXPAND = counter++;

  BAKE = counter++;

  LAST = counter++;

  TRACE = counter++;

  TTY = counter++;

  YYE = counter++;

  DRAWX = counter++;

  METAA = counter++;

  METAB = counter++;

  METAX = counter++;

  SECRETX = counter++;

  PI = counter++;

  SYMBOL_A = counter++;

  SYMBOL_B = counter++;

  SYMBOL_C = counter++;

  SYMBOL_D = counter++;

  SYMBOL_I = counter++;

  SYMBOL_J = counter++;

  SYMBOL_N = counter++;

  SYMBOL_R = counter++;

  SYMBOL_S = counter++;

  SYMBOL_T = counter++;

  SYMBOL_X = counter++;

  SYMBOL_Y = counter++;

  SYMBOL_Z = counter++;

  C1 = counter++;

  C2 = counter++;

  C3 = counter++;

  C4 = counter++;

  C5 = counter++;

  C6 = counter++;

  USR_SYMBOLS = counter++;

  E = YYE;

  TOS = 100000;

  BUF = 10000;

  MAX_PROGRAM_SIZE = 100001;

  MAXPRIMETAB = 10000;

  MAXDIM = 24;

  tensor = (function() {
    tensor.prototype.ndim = 0;

    tensor.prototype.dim = null;

    tensor.prototype.nelem = 0;

    tensor.prototype.elem = null;

    function tensor() {
      this.dim = (function() {
        var _i, _results;
        _results = [];
        for (_i = 0; 0 <= MAXDIM ? _i <= MAXDIM : _i >= MAXDIM; 0 <= MAXDIM ? _i++ : _i--) {
          _results.push(0);
        }
        return _results;
      })();
      this.elem = [];
    }

    return tensor;

  })();

  display = (function() {
    function display() {}

    display.prototype.h = 0;

    display.prototype.w = 0;

    display.prototype.n = 0;

    display.prototype.a = [];

    return display;

  })();

  text_metric = (function() {
    function text_metric() {}

    text_metric.prototype.ascent = 0;

    text_metric.prototype.descent = 0;

    text_metric.prototype.width = 0;

    return text_metric;

  })();

  tos = 0;

  expanding = 0;

  fmt_x = 0;

  fmt_index = 0;

  fmt_level = 0;

  verbosing = 0;

  primetab = (function() {
    var ceil, i, j, primes;
    primes = [2];
    i = 3;
    while (primes.length < MAXPRIMETAB) {
      j = 0;
      ceil = Math.sqrt(i);
      while (j < primes.length && primes[j] <= ceil) {
        if (i % primes[j] === 0) {
          j = -1;
          break;
        }
        j++;
      }
      if (j !== -1) {
        primes.push(i);
      }
      i += 2;
    }
    primes[MAXPRIMETAB] = 0;
    return primes;
  })();

  esc_flag = 0;

  draw_flag = 0;

  mtotal = 0;

  trigmode = 0;

  logbuf = "";

  program_buf = "";

  symtab = [];

  binding = [];

  arglist = [];

  stack = [];

  frame = 0;

  p0 = null;

  p1 = null;

  p2 = null;

  p3 = null;

  p4 = null;

  p5 = null;

  p6 = null;

  p7 = null;

  p8 = null;

  p9 = null;

  zero = null;

  one = null;

  imaginaryunit = null;

  symtab = [];

  out_buf = "";

  out_count = 0;

  test_flag = 0;

  draw_stop_return = null;

  symbol = function(x) {
    return symtab[x];
  };

  iscons = function(p) {
    return p.k === CONS;
  };

  isrational = function(p) {
    return p.k === NUM;
  };

  isdouble = function(p) {
    return p.k === DOUBLE;
  };

  isnum = function(p) {
    return isrational(p) || isdouble(p);
  };

  isstr = function(p) {
    return p.k === STR;
  };

  istensor = function(p) {
    if (p == null) {
      debugger;
    } else {
      return p.k === TENSOR;
    }
  };

  issymbol = function(p) {
    return p.k === SYM;
  };

  iskeyword = function(p) {
    return issymbol(p) && symnum(p) < NIL;
  };

  car = function(p) {
    if (iscons(p)) {
      return p.cons.car;
    } else {
      return symbol(NIL);
    }
  };

  cdr = function(p) {
    if (iscons(p)) {
      return p.cons.cdr;
    } else {
      return symbol(NIL);
    }
  };

  caar = function(p) {
    return car(car(p));
  };

  cadr = function(p) {
    return car(cdr(p));
  };

  cdar = function(p) {
    return cdr(car(p));
  };

  cddr = function(p) {
    return cdr(cdr(p));
  };

  caadr = function(p) {
    return car(car(cdr(p)));
  };

  caddr = function(p) {
    return car(cdr(cdr(p)));
  };

  cadar = function(p) {
    return car(cdr(car(p)));
  };

  cdadr = function(p) {
    return cdr(car(cdr(p)));
  };

  cddar = function(p) {
    return cdr(cdr(car(p)));
  };

  cdddr = function(p) {
    return cdr(cdr(cdr(p)));
  };

  caaddr = function(p) {
    return car(car(cdr(cdr(p))));
  };

  cadadr = function(p) {
    return car(cdr(car(cdr(p))));
  };

  caddar = function(p) {
    return car(cdr(cdr(car(p))));
  };

  cdaddr = function(p) {
    return cdr(car(cdr(cdr(p))));
  };

  cadddr = function(p) {
    return car(cdr(cdr(cdr(p))));
  };

  cddddr = function(p) {
    return cdr(cdr(cdr(cdr(p))));
  };

  caddddr = function(p) {
    return car(cdr(cdr(cdr(cdr(p)))));
  };

  cadaddr = function(p) {
    return car(cdr(car(cdr(cdr(p)))));
  };

  cddaddr = function(p) {
    return cdr(cdr(car(cdr(cdr(p)))));
  };

  caddadr = function(p) {
    return car(cdr(cdr(car(cdr(p)))));
  };

  cdddaddr = function(p) {
    return cdr(cdr(cdr(car(cdr(cdr(p))))));
  };

  caddaddr = function(p) {
    return car(cdr(cdr(car(cdr(cdr(p))))));
  };

  isadd = function(p) {
    return car(p) === symbol(ADD);
  };

  ismultiply = function(p) {
    return car(p) === symbol(MULTIPLY);
  };

  ispower = function(p) {
    return car(p) === symbol(POWER);
  };

  isfactorial = function(p) {
    return car(p) === symbol(FACTORIAL);
  };

  MSIGN = function(p) {
    if (p.isPositive()) {
      return 1;
    } else if (p.isZero()) {
      return 0;
    } else {
      return -1;
    }
  };

  MLENGTH = function(p) {
    return p.toString().length;
  };

  MZERO = function(p) {
    return p.isZero();
  };

  MEQUAL = function(p, n) {
    if (p == null) {
      debugger;
    }
    return p.equals(n);
  };

  $ = typeof exports !== "undefined" && exports !== null ? exports : this;

  $.isadd = isadd;

  $.ismultiply = ismultiply;

  $.ispower = ispower;

  $.isfactorial = isfactorial;

  $.car = car;

  $.cdr = cdr;

  $.caar = caar;

  $.cadr = cadr;

  $.cdar = cdar;

  $.cddr = cddr;

  $.caadr = caadr;

  $.caddr = caddr;

  $.cadar = cadar;

  $.cdadr = cdadr;

  $.cddar = cddar;

  $.cdddr = cdddr;

  $.caaddr = caaddr;

  $.cadadr = cadadr;

  $.caddar = caddar;

  $.cdaddr = cdaddr;

  $.cadddr = cadddr;

  $.cddddr = cddddr;

  $.caddddr = caddddr;

  $.cadaddr = cadaddr;

  $.cddaddr = cddaddr;

  $.caddadr = caddadr;

  $.cdddaddr = cdddaddr;

  $.caddaddr = caddaddr;

  $.symbol = symbol;

  $.iscons = iscons;

  $.isrational = isrational;

  $.isdouble = isdouble;

  $.isnum = isnum;

  $.isstr = isstr;

  $.istensor = istensor;

  $.issymbol = issymbol;

  $.iskeyword = iskeyword;

  $.CONS = CONS;

  $.NUM = NUM;

  $.DOUBLE = DOUBLE;

  $.STR = STR;

  $.TENSOR = TENSOR;

  $.SYM = SYM;

  Eval_abs = function() {
    push(cadr(p1));
    Eval();
    return absval();
  };

  absval = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (istensor(p1)) {
      absval_tensor();
      restore();
      return;
    }
    if (isnum(p1)) {
      push(p1);
      if (isnegativenumber(p1)) {
        negate();
      }
      restore();
      return;
    }
    if (iscomplexnumber(p1)) {
      push(p1);
      push(p1);
      conjugate();
      multiply();
      push_rational(1, 2);
      power();
      restore();
      return;
    }
    if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
      push(p1);
      reciprocate();
      absval();
      reciprocate();
      restore();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      h = tos;
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        absval();
        p1 = cdr(p1);
      }
      multiply_all(tos - h);
      restore();
      return;
    }
    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {
      push(p1);
      negate();
      p1 = pop();
    }
    push_symbol(ABS);
    push(p1);
    list(2);
    return restore();
  };

  absval_tensor = function() {
    if (p1.tensor.ndim !== 1) {
      stop("abs(tensor) with tensor rank > 1");
    }
    push(p1);
    push(p1);
    conjugate();
    inner();
    push_rational(1, 2);
    power();
    simplify();
    return Eval();
  };


  /*
   Symbolic addition
  
  	Terms in a sum are combined if they are identical modulo rational
  	coefficients.
  
  	For example, A + 2A becomes 3A.
  
  	However, the sum A + sqrt(2) A is not modified.
  
  	Combining terms can lead to second-order effects.
  
  	For example, consider the case of
  
  		1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A
  
  	The first two terms are combined to yield 2 sqrt(2) A.
  
  	This result can now be combined with the third term to yield
  
  		3 sqrt(2) A
   */

  flag = 0;

  Eval_add = function() {
    var h;
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p2 = pop();
      push_terms(p2);
      p1 = cdr(p1);
    }
    return add_terms(tos - h);
  };

  stackAddsCount = 0;

  add_terms = function(n) {
    var h, i, s, subsetOfStack, _i, _j, _k, _results;
    stackAddsCount++;
    i = 0;
    h = tos - n;
    s = h;
    if (DEBUG) {
      console.log("stack before adding terms #" + stackAddsCount);
    }
    if (DEBUG) {
      for (i = _i = 0; 0 <= tos ? _i < tos : _i > tos; i = 0 <= tos ? ++_i : --_i) {
        print1(stack[i]);
      }
    }
    for (i = _j = 0; _j < 10; i = ++_j) {
      if (n < 2) {
        break;
      }
      flag = 0;
      subsetOfStack = stack.slice(h, h + n);
      subsetOfStack.sort(cmp_terms);
      stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
      if (flag === 0) {
        break;
      }
      n = combine_terms(h, n);
    }
    tos = h + n;
    switch (n) {
      case 0:
        push_integer(0);
        break;
      case 1:
        break;
      default:
        list(n);
        p1 = pop();
        push_symbol(ADD);
        push(p1);
        cons();
    }
    if (DEBUG) {
      console.log("stack after adding terms #" + stackAddsCount);
    }
    if (DEBUG) {
      _results = [];
      for (i = _k = 0; 0 <= tos ? _k < tos : _k > tos; i = 0 <= tos ? ++_k : --_k) {
        _results.push(print1(stack[i]));
      }
      return _results;
    }
  };

  cmp_terms_count = 0;

  cmp_terms = function(p1, p2) {
    var i, t, _i, _ref;
    cmp_terms_count++;
    i = 0;
    if (isnum(p1) && isnum(p2)) {
      flag = 1;
      return 0;
    }
    if (istensor(p1) && istensor(p2)) {
      if (p1.tensor.ndim < p2.tensor.ndim) {
        return -1;
      }
      if (p1.tensor.ndim > p2.tensor.ndim) {
        return 1;
      }
      for (i = _i = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (p1.tensor.dim[i] < p2.tensor.dim[i]) {
          return -1;
        }
        if (p1.tensor.dim[i] > p2.tensor.dim[i]) {
          return 1;
        }
      }
      flag = 1;
      return 0;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      if (isnum(car(p1))) {
        p1 = cdr(p1);
        if (cdr(p1) === symbol(NIL)) {
          p1 = car(p1);
        }
      }
    }
    if (car(p2) === symbol(MULTIPLY)) {
      p2 = cdr(p2);
      if (isnum(car(p2))) {
        p2 = cdr(p2);
        if (cdr(p2) === symbol(NIL)) {
          p2 = car(p2);
        }
      }
    }
    t = cmp_expr(p1, p2);
    if (t === 0) {
      flag = 1;
    }
    return t;
  };


  /*
   Compare adjacent terms in s[] and combine if possible.
  
  	Returns the number of terms remaining in s[].
  
  	n	number of terms in s[] initially
   */

  combine_terms = function(s, n) {
    var i, j, t, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    i = 0;
    while (i < (n - 1)) {
      check_esc_flag();
      p3 = stack[s + i];
      p4 = stack[s + i + 1];
      if (istensor(p3) && istensor(p4)) {
        push(p3);
        push(p4);
        tensor_plus_tensor();
        p1 = pop();
        if (p1 !== symbol(NIL)) {
          stack[s + i] = p1;
          for (j = _i = _ref = i + 1, _ref1 = n - 1; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; j = _ref <= _ref1 ? ++_i : --_i) {
            stack[s + j] = stack[s + j + 1];
          }
          n--;
          i--;
        }
        i++;
        continue;
      }
      if (istensor(p3) || istensor(p4)) {
        i++;
        continue;
      }
      if (isnum(p3) && isnum(p4)) {
        push(p3);
        push(p4);
        add_numbers();
        p1 = pop();
        if (iszero(p1)) {
          for (j = _j = i, _ref2 = n - 2; i <= _ref2 ? _j < _ref2 : _j > _ref2; j = i <= _ref2 ? ++_j : --_j) {
            stack[s + j] = stack[s + j + 2];
          }
          n -= 2;
        } else {
          stack[s + i] = p1;
          for (j = _k = _ref3 = i + 1, _ref4 = n - 1; _ref3 <= _ref4 ? _k < _ref4 : _k > _ref4; j = _ref3 <= _ref4 ? ++_k : --_k) {
            stack[s + j] = stack[s + j + 1];
          }
          n--;
        }
        i--;
        i++;
        continue;
      }
      if (isnum(p3) || isnum(p4)) {
        i++;
        continue;
      }
      p1 = one;
      p2 = one;
      t = 0;
      if (car(p3) === symbol(MULTIPLY)) {
        p3 = cdr(p3);
        t = 1;
        if (isnum(car(p3))) {
          p1 = car(p3);
          p3 = cdr(p3);
          if (cdr(p3) === symbol(NIL)) {
            p3 = car(p3);
            t = 0;
          }
        }
      }
      if (car(p4) === symbol(MULTIPLY)) {
        p4 = cdr(p4);
        if (isnum(car(p4))) {
          p2 = car(p4);
          p4 = cdr(p4);
          if (cdr(p4) === symbol(NIL)) {
            p4 = car(p4);
          }
        }
      }
      if (!equal(p3, p4)) {
        i++;
        continue;
      }
      push(p1);
      push(p2);
      add_numbers();
      p1 = pop();
      if (iszero(p1)) {
        for (j = _l = i, _ref5 = n - 2; i <= _ref5 ? _l < _ref5 : _l > _ref5; j = i <= _ref5 ? ++_l : --_l) {
          stack[s + j] = stack[s + j + 2];
        }
        n -= 2;
        i--;
        i++;
        continue;
      }
      push(p1);
      if (t) {
        push(symbol(MULTIPLY));
        push(p3);
        cons();
      } else {
        push(p3);
      }
      multiply();
      stack[s + i] = pop();
      for (j = _m = _ref6 = i + 1, _ref7 = n - 1; _ref6 <= _ref7 ? _m < _ref7 : _m > _ref7; j = _ref6 <= _ref7 ? ++_m : --_m) {
        stack[s + j] = stack[s + j + 1];
      }
      n--;
      i--;
      i++;
    }
    return n;
  };

  push_terms = function(p) {
    var _results;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        push(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    } else if (!iszero(p)) {
      return push(p);
    }
  };

  add = function() {
    var h;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    push_terms(p1);
    push_terms(p2);
    add_terms(tos - h);
    return restore();
  };

  add_all = function(k) {
    var h, i, s, _i;
    i = 0;
    save();
    s = tos - k;
    h = tos;
    for (i = _i = 0; 0 <= k ? _i < k : _i > k; i = 0 <= k ? ++_i : --_i) {
      push_terms(stack[s + i]);
    }
    add_terms(tos - h);
    p1 = pop();
    tos -= k;
    push(p1);
    return restore();
  };

  subtract = function() {
    negate();
    return add();
  };

  Eval_adj = function() {
    push(cadr(p1));
    Eval();
    return adj();
  };

  adj = function() {
    var doNothing, i, j, n, _i, _j;
    i = 0;
    j = 0;
    n = 0;
    save();
    p1 = pop();
    if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {
      doNothing = 1;
    } else {
      stop("adj: square matrix expected");
    }
    n = p1.tensor.dim[0];
    p2 = alloc_tensor(n * n);
    p2.tensor.ndim = 2;
    p2.tensor.dim[0] = n;
    p2.tensor.dim[1] = n;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      for (j = _j = 0; 0 <= n ? _j < n : _j > n; j = 0 <= n ? ++_j : --_j) {
        cofactor(p1, n, i, j);
        p2.tensor.elem[n * j + i] = pop();
      }
    }
    push(p2);
    return restore();
  };

  Eval_arccos = function() {
    push(cadr(p1));
    Eval();
    return arccos();
  };

  arccos = function() {
    var d, errno, n;
    n = 0;
    d = 0.0;
    save();
    p1 = pop();
    if (car(p1) === symbol(COS)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      errno = 0;
      d = Math.acos(p1.d);
      if (errno) {
        stop("arccos function argument is not in the interval [-1,1]");
      }
      push_double(d);
      restore();
      return;
    }
    if (isoneoversqrttwo(p1)) {
      push_rational(1, 4);
      push_symbol(PI);
      multiply();
      restore();
      return;
    }
    if (isminusoneoversqrttwo(p1)) {
      push_rational(3, 4);
      push_symbol(PI);
      multiply();
      restore();
      return;
    }
    if (!isrational(p1)) {
      push_symbol(ARCCOS);
      push(p1);
      list(2);
      restore();
      return;
    }
    push(p1);
    push_integer(2);
    multiply();
    n = pop_integer();
    switch (n) {
      case -2:
        push_symbol(PI);
        break;
      case -1:
        push_rational(2, 3);
        push_symbol(PI);
        multiply();
        break;
      case 0:
        push_rational(1, 2);
        push_symbol(PI);
        multiply();
        break;
      case 1:
        push_rational(1, 3);
        push_symbol(PI);
        multiply();
        break;
      case 2:
        push(zero);
        break;
      default:
        push_symbol(ARCCOS);
        push(p1);
        list(2);
    }
    return restore();
  };

  Eval_arccosh = function() {
    push(cadr(p1));
    Eval();
    return arccosh();
  };

  arccosh = function() {
    var d;
    d = 0.0;
    save();
    p1 = pop();
    if (car(p1) === symbol(COSH)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      d = p1.d;
      if (d < 1.0) {
        stop("arccosh function argument is less than 1.0");
      }
      d = Math.log(d + Math.sqrt(d * d - 1.0));
      push_double(d);
      restore();
      return;
    }
    if (isplusone(p1)) {
      push(zero);
      restore();
      return;
    }
    push_symbol(ARCCOSH);
    push(p1);
    list(2);
    return restore();
  };

  Eval_arcsin = function() {
    push(cadr(p1));
    Eval();
    return arcsin();
  };

  arcsin = function() {
    var d, errno, n;
    n = 0;
    d = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(SIN)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      errno = 0;
      d = Math.asin(p1.d);
      if (errno) {
        stop("arcsin function argument is not in the interval [-1,1]");
      }
      push_double(d);
      restore();
      return;
    }
    if (isoneoversqrttwo(p1)) {
      push_rational(1, 4);
      push_symbol(PI);
      multiply();
      restore();
      return;
    }
    if (isminusoneoversqrttwo(p1)) {
      push_rational(-1, 4);
      push_symbol(PI);
      multiply();
      restore();
      return;
    }
    if (!isrational(p1)) {
      push_symbol(ARCSIN);
      push(p1);
      list(2);
      restore();
      return;
    }
    push(p1);
    push_integer(2);
    multiply();
    n = pop_integer();
    switch (n) {
      case -2:
        push_rational(-1, 2);
        push_symbol(PI);
        multiply();
        break;
      case -1:
        push_rational(-1, 6);
        push_symbol(PI);
        multiply();
        break;
      case 0:
        push(zero);
        break;
      case 1:
        push_rational(1, 6);
        push_symbol(PI);
        multiply();
        break;
      case 2:
        push_rational(1, 2);
        push_symbol(PI);
        multiply();
        break;
      default:
        push_symbol(ARCSIN);
        push(p1);
        list(2);
    }
    return restore();
  };

  Eval_arcsinh = function() {
    push(cadr(p1));
    Eval();
    return arcsinh();
  };

  arcsinh = function() {
    var d;
    d = 0.0;
    save();
    p1 = pop();
    if (car(p1) === symbol(SINH)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      d = p1.d;
      d = Math.log(d + Math.sqrt(d * d + 1.0));
      push_double(d);
      restore();
      return;
    }
    if (iszero(p1)) {
      push(zero);
      restore();
      return;
    }
    push_symbol(ARCSINH);
    push(p1);
    list(2);
    return restore();
  };

  Eval_arctan = function() {
    push(cadr(p1));
    Eval();
    return arctan();
  };

  arctan = function() {
    var d, errno;
    d = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(TAN)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      errno = 0;
      d = Math.atan(p1.d);
      if (errno) {
        stop("arctan function error");
      }
      push_double(d);
      restore();
      return;
    }
    if (iszero(p1)) {
      push(zero);
      restore();
      return;
    }
    if (isnegative(p1)) {
      push(p1);
      negate();
      arctan();
      negate();
      restore();
      return;
    }
    if (Find(p1, symbol(SIN)) && Find(p1, symbol(COS))) {
      push(p1);
      numerator();
      p2 = pop();
      push(p1);
      denominator();
      p3 = pop();
      if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {
        push(cadr(p2));
        restore();
        return;
      }
    }
    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2)) {
      push_rational(1, 6);
      push(symbol(PI));
      multiply();
      restore();
      return;
    }
    if (equaln(p1, 1)) {
      push_rational(1, 4);
      push(symbol(PI));
      multiply();
      restore();
      return;
    }
    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {
      push_rational(1, 3);
      push(symbol(PI));
      multiply();
      restore();
      return;
    }
    push_symbol(ARCTAN);
    push(p1);
    list(2);
    return restore();
  };

  Eval_arctanh = function() {
    push(cadr(p1));
    Eval();
    return arctanh();
  };

  arctanh = function() {
    var d;
    d = 0.0;
    save();
    p1 = pop();
    if (car(p1) === symbol(TANH)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      d = p1.d;
      if (d < -1.0 || d > 1.0) {
        stop("arctanh function argument is not in the interval [-1,1]");
      }
      d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;
      push_double(d);
      restore();
      return;
    }
    if (iszero(p1)) {
      push(zero);
      restore();
      return;
    }
    push_symbol(ARCTANH);
    push(p1);
    list(2);
    return restore();
  };


  /*
   Argument (angle) of complex z
  
  	z		arg(z)
  	-		------
  
  	a		0
  
  	-a		-pi			See note 3 below
  
  	(-1)^a		a pi
  
  	exp(a + i b)	b
  
  	a b		arg(a) + arg(b)
  
  	a + i b		arctan(b/a)
  
  Result by quadrant
  
  	z		arg(z)
  	-		------
  
  	1 + i		1/4 pi
  
  	1 - i		-1/4 pi
  
  	-1 + i		3/4 pi
  
  	-1 - i		-3/4 pi
  
  Notes
  
  	1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)
  
  	2. Symbols in z are assumed to be positive and real.
  
  	3. Negative direction adds -pi to angle.
  
  	   Example: z = (-1)^(1/3), mag(z) = 1/3 pi, mag(-z) = -2/3 pi
  
  	4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then
  
  		arg(numerator(z)) - arg(denominator(z))
  
  	   must be used to get the correct answer. Now the operation is
  	   automatic.
   */

  Eval_arg = function() {
    push(cadr(p1));
    Eval();
    return arg();
  };

  arg = function() {
    save();
    p1 = pop();
    push(p1);
    numerator();
    yyarg();
    push(p1);
    denominator();
    yyarg();
    subtract();
    return restore();
  };

  yyarg = function() {
    save();
    p1 = pop();
    if (isnegativenumber(p1)) {
      push(symbol(PI));
      negate();
    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {
      push(symbol(PI));
      push(caddr(p1));
      multiply();
    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {
      push(caddr(p1));
      imag();
    } else if (car(p1) === symbol(MULTIPLY)) {
      push_integer(0);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        arg();
        add();
        p1 = cdr(p1);
      }
    } else if (car(p1) === symbol(ADD)) {
      push(p1);
      rect();
      p1 = pop();
      push(p1);
      real();
      p2 = pop();
      push(p1);
      imag();
      p3 = pop();
      if (iszero(p2)) {
        push(symbol(PI));
        if (isnegative(p3)) {
          negate();
        }
      } else {
        push(p3);
        push(p2);
        divide();
        arctan();
        if (isnegative(p2)) {
          push_symbol(PI);
          if (isnegative(p3)) {
            subtract();
          } else {
            add();
          }
        }
      }
    } else {
      push_integer(0);
    }
    return restore();
  };

  bake = function() {
    var h, s, t, x, y, z;
    h = 0;
    s = 0;
    t = 0;
    x = 0;
    y = 0;
    z = 0;
    expanding++;
    save();
    p1 = pop();
    s = ispoly(p1, symbol(SYMBOL_S));
    t = ispoly(p1, symbol(SYMBOL_T));
    x = ispoly(p1, symbol(SYMBOL_X));
    y = ispoly(p1, symbol(SYMBOL_Y));
    z = ispoly(p1, symbol(SYMBOL_Z));
    if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {
      p2 = symbol(SYMBOL_S);
      bake_poly();
    } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {
      p2 = symbol(SYMBOL_T);
      bake_poly();
    } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {
      p2 = symbol(SYMBOL_X);
      bake_poly();
    } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {
      p2 = symbol(SYMBOL_Y);
      bake_poly();
    } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {
      p2 = symbol(SYMBOL_Z);
      bake_poly();
    } else if (iscons(p1)) {
      h = tos;
      push(car(p1));
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        bake();
        p1 = cdr(p1);
      }
      list(tos - h);
    } else {
      push(p1);
    }
    restore();
    return expanding--;
  };

  polyform = function() {
    var h;
    h = 0;
    save();
    p2 = pop();
    p1 = pop();
    if (ispoly(p1, p2)) {
      bake_poly();
    } else if (iscons(p1)) {
      h = tos;
      push(car(p1));
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        polyform();
        p1 = cdr(p1);
      }
      list(tos - h);
    } else {
      push(p1);
    }
    return restore();
  };

  bake_poly = function() {
    var a, h, i, k, n, _i, _ref;
    h = 0;
    i = 0;
    k = 0;
    n = 0;
    a = tos;
    push(p1);
    push(p2);
    k = coeff();
    h = tos;
    for (i = _i = _ref = k - 1; _i >= 0; i = _i += -1) {
      p1 = stack[a + i];
      bake_poly_term(i);
    }
    n = tos - h;
    if (n > 1) {
      list(n);
      push(symbol(ADD));
      swap();
      cons();
    }
    p1 = pop();
    tos -= k;
    return push(p1);
  };

  bake_poly_term = function(k) {
    var h, n;
    h = 0;
    n = 0;
    if (iszero(p1)) {
      return;
    }
    if (k === 0) {
      if (car(p1) === symbol(ADD)) {
        p1 = cdr(p1);
        while (iscons(p1)) {
          push(car(p1));
          p1 = cdr(p1);
        }
      } else {
        push(p1);
      }
      return;
    }
    h = tos;
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        p1 = cdr(p1);
      }
    } else if (!equaln(p1, 1)) {
      push(p1);
    }
    if (k === 1) {
      push(p2);
    } else {
      push(symbol(POWER));
      push(p2);
      push_integer(k);
      list(3);
    }
    n = tos - h;
    if (n > 1) {
      list(n);
      push(symbol(MULTIPLY));
      swap();
      return cons();
    }
  };


  /*
   Bessel J function
  
  	1st arg		x
  
  	2nd arg		n
  
  Recurrence relation
  
  	besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)
  
  	besselj(x,1/2) = sqrt(2/pi/x) sin(x)
  
  	besselj(x,-1/2) = sqrt(2/pi/x) cos(x)
  
  For negative n, reorder the recurrence relation as
  
  	besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)
  
  Substitute n+2 for n to obtain
  
  	besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)
  
  Examples
  
  	besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)
  
  	besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)
   */

  Eval_besselj = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return besselj();
  };

  besselj = function() {
    save();
    yybesselj();
    return restore();
  };

  yybesselj = function() {
    var d, n;
    d = 0.0;
    n = 0;
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    if (isdouble(p1) && n !== 0x80000000) {
      d = jn(n, p1.d);
      push_double(d);
      return;
    }
    if (iszero(p1) && iszero(p2)) {
      push_integer(1);
      return;
    }
    if (iszero(p1) && n !== 0x80000000) {
      push_integer(0);
      return;
    }
    if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {
      if (MEQUAL(p2.q.a, 1)) {
        push_integer(2);
        push_symbol(PI);
        divide();
        push(p1);
        divide();
        push_rational(1, 2);
        power();
        push(p1);
        sine();
        multiply();
        return;
      }
      if (MEQUAL(p2.q.a, -1)) {
        push_integer(2);
        push_symbol(PI);
        divide();
        push(p1);
        divide();
        push_rational(1, 2);
        power();
        push(p1);
        cosine();
        multiply();
        return;
      }
      push_integer(MSIGN(p2.q.a));
      p3 = pop();
      push_integer(2);
      push(p1);
      divide();
      push(p2);
      push(p3);
      subtract();
      multiply();
      push(p1);
      push(p2);
      push(p3);
      subtract();
      besselj();
      multiply();
      push(p1);
      push(p2);
      push_integer(2);
      push(p3);
      multiply();
      subtract();
      besselj();
      subtract();
      return;
    }
    if (isnegativeterm(p1)) {
      push(p1);
      negate();
      push(p2);
      power();
      push(p1);
      push(p2);
      negate();
      power();
      multiply();
      push_symbol(BESSELJ);
      push(p1);
      negate();
      push(p2);
      list(3);
      multiply();
      return;
    }
    if (isnegativeterm(p2)) {
      push_integer(-1);
      push(p2);
      power();
      push_symbol(BESSELJ);
      push(p1);
      push(p2);
      negate();
      list(3);
      multiply();
      return;
    }
    push(symbol(BESSELJ));
    push(p1);
    push(p2);
    return list(3);
  };

  Eval_bessely = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return bessely();
  };

  bessely = function() {
    save();
    yybessely();
    return restore();
  };

  yybessely = function() {
    var d, n;
    d = 0.0;
    n = 0;
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    if (isdouble(p1) && n !== 0x80000000) {
      d = yn(n, p1.d);
      push_double(d);
      return;
    }
    if (isnegativeterm(p2)) {
      push_integer(-1);
      push(p2);
      power();
      push_symbol(BESSELY);
      push(p1);
      push(p2);
      negate();
      list(3);
      multiply();
      return;
    }
    push_symbol(BESSELY);
    push(p1);
    push(p2);
    list(3);
  };

  MP_MIN_SIZE = 2;

  MP_MAX_FREE = 1000;

  mtotal = 0;

  free_stack = [];

  mint = function(a) {
    return bigInt(a);
  };

  setSignTo = function(a, b) {
    if (a.isPositive()) {
      if (b < 0) {
        return a.multiply(bigInt(-1));
      }
    } else {
      if (b > 0) {
        return a.multiply(bigInt(-1));
      }
    }
    return a;
  };

  makeSignSameAs = function(a, b) {
    if (a.isPositive()) {
      if (b.isNegative()) {
        return a.multiply(bigInt(-1));
      }
    } else {
      if (b.isPositive()) {
        return a.multiply(bigInt(-1));
      }
    }
    return a;
  };

  makePositive = function(a) {
    if (a.isNegative()) {
      return a.multiply(bigInt(-1));
    }
    return a;
  };


  /*
  mnew = (n) ->
  	if (n < MP_MIN_SIZE)
  		n = MP_MIN_SIZE
  	if (n == MP_MIN_SIZE && mfreecount)
  		p = free_stack[--mfreecount]
  	else
  		p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))
  		#if (p == 0)
  		#	stop("malloc failure")
  	p[0] = n
  	mtotal += n
  	return p[3]
   */


  /*
  mfree = (array, p) ->
  	p -= 3
  	mtotal -= array[p]
  	if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)
  		free_stack[mfreecount++] = p
  	else
  		free(p)
   */


  /*
  mint = (n) ->
  	p = mnew(1)
  	if (n < 0)
  		 * !!! this is FU
  		 * MSIGN(p) = -1
  		fu = true
  	else
  		 * !!! this is FU
  		#MSIGN(p) = 1
  		fu = true
  	 * !!! this is FU
  	#MLENGTH(p) = 1
  	p[0] = Math.abs(n)
  	return p
   */


  /*
  mcopy = (a) ->
  	#unsigned int *b
  
  	b = mnew(MLENGTH(a))
  
  	 * !!! fu
  	#MSIGN(b) = MSIGN(a)
  	#MLENGTH(b) = MLENGTH(a)
  
  	for i in [0...MLENGTH(a)]
  		b[i] = a[i]
  
  	return b
   */


  /*
   * 
   * ge not invoked from anywhere - is you need ge
   * just use the bigNum's ge implementation
   * leaving it here just in case I decide to backport to C
  #
   * a >= b ?
   * and and b arrays of ints, len is an int
  ge = (a, b, len) ->
  	i = 0
  	for i in [0...len]
  		if (a[i] == b[i])
  			continue
  		else
  			break
  	if (a[i] >= b[i])
  		return 1
  	else
  		return 0
   */

  add_numbers = function() {
    var a, b, theResult;
    a = 1.0;
    b = 1.0;
    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
      qadd();
      return;
    }
    save();
    p2 = pop();
    p1 = pop();
    if (isdouble(p1)) {
      a = p1.d;
    } else {
      a = convert_rational_to_double(p1);
    }
    if (isdouble(p2)) {
      b = p2.d;
    } else {
      b = convert_rational_to_double(p2);
    }
    theResult = a + b;
    push_double(theResult);
    return restore();
  };

  subtract_numbers = function() {
    var a, b;
    a = 0.0;
    b = 0.0;
    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
      qsub();
      return;
    }
    save();
    p2 = pop();
    p1 = pop();
    if (isdouble(p1)) {
      a = p1.d;
    } else {
      a = convert_rational_to_double(p1);
    }
    if (isdouble(p2)) {
      b = p2.d;
    } else {
      b = convert_rational_to_double(p2);
    }
    push_double(a - b);
    return restore();
  };

  multiply_numbers = function() {
    var a, b;
    a = 0.0;
    b = 0.0;
    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
      qmul();
      return;
    }
    save();
    p2 = pop();
    p1 = pop();
    if (isdouble(p1)) {
      a = p1.d;
    } else {
      a = convert_rational_to_double(p1);
    }
    if (isdouble(p2)) {
      b = p2.d;
    } else {
      b = convert_rational_to_double(p2);
    }
    push_double(a * b);
    return restore();
  };

  divide_numbers = function() {
    var a, b;
    a = 0.0;
    b = 0.0;
    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
      qdiv();
      return;
    }
    save();
    p2 = pop();
    p1 = pop();
    if (iszero(p2)) {
      stop("divide by zero");
    }
    if (isdouble(p1)) {
      a = p1.d;
    } else {
      a = convert_rational_to_double(p1);
    }
    if (isdouble(p2)) {
      b = p2.d;
    } else {
      b = convert_rational_to_double(p2);
    }
    push_double(a / b);
    return restore();
  };

  invert_number = function() {
    var a, b;
    save();
    p1 = pop();
    if (iszero(p1)) {
      stop("divide by zero");
    }
    if (isdouble(p1)) {
      push_double(1 / p1.d);
      restore();
      return;
    }
    a = bigInt(p1.q.a);
    b = bigInt(p1.q.b);
    b = makeSignSameAs(b, a);
    a = setSignTo(a, 1);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = b;
    p1.q.b = a;
    push(p1);
    return restore();
  };

  compare_rationals = function(a, b) {
    var ab, ba, t;
    t = 0;
    ab = mmul(a.q.a, b.q.b);
    ba = mmul(a.q.b, b.q.a);
    t = mcmp(ab, ba);
    return t;
  };

  compare_numbers = function(a, b) {
    var x, y;
    x = 0.0;
    y = 0.0;
    if (isrational(a) && isrational(b)) {
      return compare_rationals(a, b);
    }
    if (isdouble(a)) {
      x = a.d;
    } else {
      x = convert_rational_to_double(a);
    }
    if (isdouble(b)) {
      y = b.d;
    } else {
      y = convert_rational_to_double(b);
    }
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };

  negate_number = function() {
    save();
    p1 = pop();
    if (iszero(p1)) {
      push(p1);
      restore();
      return;
    }
    switch (p1.k) {
      case NUM:
        p2 = new U();
        p2.k = NUM;
        p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));
        p2.q.b = bigInt(p1.q.b);
        push(p2);
        break;
      case DOUBLE:
        push_double(-p1.d);
        break;
      default:
        stop("bug caught in mp_negate_number");
    }
    return restore();
  };

  bignum_truncate = function() {
    var a;
    save();
    p1 = pop();
    a = mdiv(p1.q.a, p1.q.b);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = a;
    p1.q.b = bigInt(1);
    push(p1);
    return restore();
  };

  mp_numerator = function() {
    save();
    p1 = pop();
    if (p1.k !== NUM) {
      push(one);
      restore();
      return;
    }
    p2 = new U();
    p2.k = NUM;
    p2.q.a = bigInt(p1.q.a);
    p2.q.b = bigInt(1);
    push(p2);
    return restore();
  };

  mp_denominator = function() {
    save();
    p1 = pop();
    if (p1.k !== NUM) {
      push(one);
      restore();
      return;
    }
    p2 = new U();
    p2.k = NUM;
    p2.q.a = bigInt(p1.q.b);
    p2.q.b = bigInt(1);
    push(p2);
    return restore();
  };

  bignum_power_number = function(expo) {
    var a, b, t;
    save();
    p1 = pop();
    a = mpow(p1.q.a, Math.abs(expo));
    b = mpow(p1.q.b, Math.abs(expo));
    if (expo < 0) {
      t = a;
      a = b;
      b = t;
      a = makeSignSameAs(a, b);
      b = setSignTo(b, 1);
    }
    p1 = new U();
    p1.k = NUM;
    p1.q.a = a;
    p1.q.b = b;
    push(p1);
    return restore();
  };

  convert_bignum_to_double = function(p) {
    return p.toJSNumber();
  };

  convert_rational_to_double = function(p) {
    var quotientAndRemainder, result;
    if (p.q == null) {
      debugger;
    }
    quotientAndRemainder = p.q.a.divmod(p.q.b);
    result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();
    return result;
  };

  push_integer = function(n) {
    if (DEBUG) {
      console.log("pushing integer " + n);
    }
    save();
    p1 = new U();
    p1.k = NUM;
    p1.q.a = bigInt(n);
    p1.q.b = bigInt(1);
    push(p1);
    return restore();
  };

  push_double = function(d) {
    save();
    p1 = new U();
    p1.k = DOUBLE;
    p1.d = d;
    push(p1);
    return restore();
  };

  push_rational = function(a, b) {

    /*
    	save()
    	p1 = new U()
    	p1.k = NUM
    	p1.q.a = bigInt(a)
    	p1.q.b = bigInt(b)
    	## FIXME -- normalize ##
    	push(p1)
    	restore()
     */
    var p;
    p = new U();
    p.k = NUM;
    p.q.a = bigInt(a);
    p.q.b = bigInt(b);
    return push(p);
  };

  pop_integer = function() {
    var n;
    n = 0;
    save();
    p1 = pop();
    switch (p1.k) {
      case NUM:
        if (isinteger(p1) && p1.q.a.isSmall) {
          n = p1.q.a.toJSNumber();
        } else {
          n = 0x80000000;
        }
        break;
      case DOUBLE:
        n = Math.floor(p1.q.a);
        break;
      default:
        n = 0x80000000;
    }
    restore();
    return n;
  };

  print_double = function(p, flag) {
    var buf;
    buf = "";
    buf = "" + doubleToReasonableString(p.d);
    if (flag === 1 && buf === '-') {
      return print_str(buf + 1);
    } else {
      return print_str(buf);
    }
  };

  bignum_scan_integer = function(s) {
    var a, scounter, sign_;
    save();
    scounter = 0;
    sign_ = s[scounter];
    if (sign_ === '+' || sign_ === '-') {
      scounter++;
    }
    a = bigInt(s.substring(scounter));
    p1 = new U();
    p1.k = NUM;
    p1.q.a = a;
    p1.q.b = bigInt(1);
    push(p1);
    if (sign_ === '-') {
      negate();
    }
    return restore();
  };

  bignum_scan_float = function(s) {
    return push_double(parseFloat(s));
  };

  print_number = function(p, accumulator) {
    var aAsString, buf, denominatorString, topLevelCall;
    topLevelCall = false;
    if (accumulator == null) {
      topLevelCall = true;
      accumulator = "";
    }
    denominatorString = "";
    buf = "";
    switch (p.k) {
      case NUM:
        aAsString = p.q.a.toString();
        if (aAsString[0] === "-") {
          aAsString = aAsString.substring(1);
        }
        accumulator += aAsString;
        stringToBePrinted += aAsString;
        if (isfraction(p)) {
          accumulator += "/";
          stringToBePrinted += "/";
          denominatorString = p.q.b.toString();
          accumulator += denominatorString;
          stringToBePrinted += denominatorString;
        }
        break;
      case DOUBLE:
        aAsString = "" + doubleToReasonableString(p.d);
        if (aAsString[0] === "-") {
          aAsString = aAsString.substring(1);
        }
        accumulator += aAsString;
        stringToBePrinted += aAsString;
    }
    return accumulator;
  };

  gcd_numbers = function() {
    save();
    p2 = pop();
    p1 = pop();
    p3 = new U();
    p3.k = NUM;
    p3.q.a = mgcd(p1.q.a, p2.q.a);
    p3.q.b = mgcd(p1.q.b, p2.q.b);
    p3.q.a = setSignTo(p3.q.a, 1);
    push(p3);
    return restore();
  };

  pop_double = function() {
    var d;
    d = 0.0;
    save();
    p1 = pop();
    switch (p1.k) {
      case NUM:
        d = convert_rational_to_double(p1);
        break;
      case DOUBLE:
        d = p1.d;
        break;
      default:
        d = 0.0;
    }
    restore();
    return d;
  };

  bignum_float = function() {
    var d;
    d = 0.0;
    d = convert_rational_to_double(pop());
    return push_double(d);
  };

  bignum_factorial = function(n) {
    save();
    p1 = new U();
    p1.k = NUM;
    p1.q.a = __factorial(n);
    p1.q.b = bigInt(1);
    push(p1);
    return restore();
  };

  __factorial = function(n) {
    var a, b, i, t, _i;
    i = 0;
    if (n === 0 || n === 1) {
      a = bigInt(1);
      return a;
    }
    a = bigInt(2);
    b = bigInt(0);
    if (3 <= n) {
      for (i = _i = 3; 3 <= n ? _i <= n : _i >= n; i = 3 <= n ? ++_i : --_i) {
        b = bigInt(i);
        t = mmul(a, b);
        a = t;
      }
    }
    return a;
  };

  mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];

  mp_set_bit = function(x, k) {
    console.log("not implemented yet");
    debugger;
    return x[k / 32] |= mask[k % 32];
  };

  mp_clr_bit = function(x, k) {
    console.log("not implemented yet");
    debugger;
    return x[k / 32] &= ~mask[k % 32];
  };

  mshiftright = function(a) {
    return a = a.shiftRight();
  };

  Eval_binomial = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return binomial();
  };

  binomial = function() {
    save();
    ybinomial();
    return restore();
  };

  ybinomial = function() {
    p2 = pop();
    p1 = pop();
    if (BINOM_check_args() === 0) {
      push(zero);
      return;
    }
    push(p1);
    factorial();
    push(p2);
    factorial();
    divide();
    push(p1);
    push(p2);
    subtract();
    factorial();
    return divide();
  };

  BINOM_check_args = function() {
    if (isnum(p1) && lessp(p1, zero)) {
      return 0;
    } else if (isnum(p2) && lessp(p2, zero)) {
      return 0;
    } else if (isnum(p1) && isnum(p2) && lessp(p1, p2)) {
      return 0;
    } else {
      return 1;
    }
  };

  Eval_ceiling = function() {
    push(cadr(p1));
    Eval();
    return ceiling();
  };

  ceiling = function() {
    save();
    yyceiling();
    return restore();
  };

  yyceiling = function() {
    var d, doNothing;
    d = 0.0;
    p1 = pop();
    if (!isnum(p1)) {
      push_symbol(CEILING);
      push(p1);
      list(2);
      return;
    }
    if (isdouble(p1)) {
      d = Math.ceil(p1.d);
      push_double(d);
      return;
    }
    if (isinteger(p1)) {
      push(p1);
      return;
    }
    p3 = new U();
    p3.k = NUM;
    p3.q.a = mdiv(p1.q.a, p1.q.b);
    p3.q.b = mint(1);
    push(p3);
    if (isnegativenumber(p1)) {
      return doNothing = 1;
    } else {
      push_integer(1);
      return add();
    }
  };

  Eval_choose = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return choose();
  };

  choose = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (choose_check_args() === 0) {
      push_integer(0);
      restore();
      return;
    }
    push(p1);
    factorial();
    push(p2);
    factorial();
    divide();
    push(p1);
    push(p2);
    subtract();
    factorial();
    divide();
    return restore();
  };

  choose_check_args = function() {
    if (isnum(p1) && lessp(p1, zero)) {
      return 0;
    } else if (isnum(p2) && lessp(p2, zero)) {
      return 0;
    } else if (isnum(p1) && isnum(p2) && lessp(p1, p2)) {
      return 0;
    } else {
      return 1;
    }
  };

  Eval_circexp = function() {
    push(cadr(p1));
    Eval();
    circexp();
    return Eval();
  };

  circexp = function() {
    var h, i, _i, _ref;
    i = 0;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(COS)) {
      push(cadr(p1));
      expcos();
      restore();
      return;
    }
    if (car(p1) === symbol(SIN)) {
      push(cadr(p1));
      expsin();
      restore();
      return;
    }
    if (car(p1) === symbol(TAN)) {
      p1 = cadr(p1);
      push(imaginaryunit);
      push(p1);
      multiply();
      exponential();
      p2 = pop();
      push(imaginaryunit);
      push(p1);
      multiply();
      negate();
      exponential();
      p3 = pop();
      push(p3);
      push(p2);
      subtract();
      push(imaginaryunit);
      multiply();
      push(p2);
      push(p3);
      add();
      divide();
      restore();
      return;
    }
    if (car(p1) === symbol(COSH)) {
      p1 = cadr(p1);
      push(p1);
      exponential();
      push(p1);
      negate();
      exponential();
      add();
      push_rational(1, 2);
      multiply();
      restore();
      return;
    }
    if (car(p1) === symbol(SINH)) {
      p1 = cadr(p1);
      push(p1);
      exponential();
      push(p1);
      negate();
      exponential();
      subtract();
      push_rational(1, 2);
      multiply();
      restore();
      return;
    }
    if (car(p1) === symbol(TANH)) {
      p1 = cadr(p1);
      push(p1);
      push_integer(2);
      multiply();
      exponential();
      p1 = pop();
      push(p1);
      push_integer(1);
      subtract();
      push(p1);
      push_integer(1);
      add();
      divide();
      restore();
      return;
    }
    if (iscons(p1)) {
      h = tos;
      while (iscons(p1)) {
        push(car(p1));
        circexp();
        p1 = cdr(p1);
      }
      list(tos - h);
      restore();
      return;
    }
    if (p1.k === TENSOR) {
      push(p1);
      copy_tensor();
      p1 = pop();
      for (i = _i = 0, _ref = p1.tensor.nelem; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        push(p1.tensor.elem[i]);
        circexp();
        p1.tensor.elem[i] = pop();
      }
      push(p1);
      restore();
      return;
    }
    push(p1);
    return restore();
  };

  Eval_clear = function() {
    if (test_flag === 0) {
      clear_term();
    }
    clear_symbols();
    defn();
    return push(symbol(NIL));
  };

  clear = function() {
    return run("clear");
  };


  /*
   Convert complex z to clock form
  
  	Input:		push	z
  
  	Output:		Result on stack
  
  	clock(z) = mag(z) * (-1) ^ (arg(z) / pi)
  
  	For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)
   */

  Eval_clock = function() {
    push(cadr(p1));
    Eval();
    return clockform();
  };

  clockform = function() {
    save();
    p1 = pop();
    push(p1);
    mag();
    push_integer(-1);
    push(p1);
    arg();
    push(symbol(PI));
    divide();
    power();
    multiply();

    /*
    	p1 = pop()
    	push(p1)
    	mag()
    	push(symbol(E))
    	push(p1)
    	arg()
    	push(imaginaryunit)
    	multiply()
    	power()
    	multiply()
     */
    return restore();
  };

  Eval_coeff = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    if (p3 === symbol(NIL)) {
      p3 = p2;
      p2 = symbol(SYMBOL_X);
    }
    push(p1);
    push(p2);
    push(p3);
    power();
    divide();
    push(p2);
    return filter();
  };

  coeff = function() {
    var h, n;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    while (1) {
      push(p1);
      push(p2);
      push(zero);
      subst();
      Eval();
      p3 = pop();
      push(p3);
      push(p1);
      push(p3);
      subtract();
      p1 = pop();
      if (equal(p1, zero)) {
        n = tos - h;
        restore();
        return n;
      }
      push(p1);
      push(p2);
      divide();
      p1 = pop();
    }
  };

  Eval_cofactor = function() {
    var doNothing, i, j, n;
    i = 0;
    j = 0;
    n = 0;
    push(cadr(p1));
    Eval();
    p2 = pop();
    if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {
      doNothing = 1;
    } else {
      stop("cofactor: 1st arg: square matrix expected");
    }
    n = p2.tensor.dim[0];
    push(caddr(p1));
    Eval();
    i = pop_integer();
    if (i < 1 || i > n) {
      stop("cofactor: 2nd arg: row index expected");
    }
    push(cadddr(p1));
    Eval();
    j = pop_integer();
    if (j < 1 || j > n) {
      stop("cofactor: 3rd arg: column index expected");
    }
    return cofactor(p2, n, i - 1, j - 1);
  };

  cofactor = function(p, n, row, col) {
    var i, j, _i, _j;
    i = 0;
    j = 0;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      for (j = _j = 0; 0 <= n ? _j < n : _j > n; j = 0 <= n ? ++_j : --_j) {
        if (i !== row && j !== col) {
          push(p.tensor.elem[n * i + j]);
        }
      }
    }
    determinant(n - 1);
    if ((row + col) % 2) {
      return negate();
    }
  };

  Eval_condense = function() {
    push(cadr(p1));
    Eval();
    return Condense();
  };

  Condense = function() {
    var tmp;
    tmp = 0;
    tmp = expanding;
    save();
    yycondense();
    restore();
    return expanding = tmp;
  };

  yycondense = function() {
    expanding = 0;
    p1 = pop();
    if (car(p1) !== symbol(ADD)) {
      push(p1);
      return;
    }
    p3 = cdr(p1);
    push(car(p3));
    p3 = cdr(p3);
    while (iscons(p3)) {
      push(car(p3));
      gcd();
      p3 = cdr(p3);
    }
    inverse();
    p2 = pop();
    push(zero);
    p3 = cdr(p1);
    while (iscons(p3)) {
      push(p2);
      push(car(p3));
      multiply();
      add();
      p3 = cdr(p3);
    }
    yyexpand();
    push(p2);
    return divide();
  };

  Eval_conj = function() {
    push(cadr(p1));
    Eval();
    p1 = pop();
    push(p1);
    if (!Find(p1, imaginaryunit)) {
      polar();
      conjugate();
      return clockform();
    } else {
      return conjugate();
    }
  };

  conjugate = function() {
    push(imaginaryunit);
    push(imaginaryunit);
    negate();
    subst();
    return Eval();
  };

  consCount = 0;

  cons = function() {
    var p;
    consCount++;
    if (DEBUG) {
      console.log("cons tos: " + tos + " # " + consCount);
    }
    p = new U();
    p.k = CONS;
    p.cons.cdr = pop();
    if (p === p.cons.cdr) {
      debugger;
      console.log("something wrong p == its cdr");
    }
    p.cons.car = pop();

    /*
    	console.log "cons new cdr.k = " + p.cons.cdr.k + "\nor more in detail:"
    	print1 p.cons.cdr
    	console.log "cons new car.k = " + p.cons.car.k + "\nor more in detail:"
    	print1 p.cons.car
     */
    return push(p);
  };

  Eval_contract = function() {
    push(cadr(p1));
    Eval();
    if (cddr(p1) === symbol(NIL)) {
      push_integer(1);
      push_integer(2);
    } else {
      push(caddr(p1));
      Eval();
      push(cadddr(p1));
      Eval();
    }
    return contract();
  };

  contract = function() {
    save();
    yycontract();
    return restore();
  };

  yycontract = function() {
    var a, ai, an, b, h, i, j, k, l, m, n, ndim, nelem, _i, _j, _k, _l, _m, _n, _o, _ref;
    h = 0;
    i = 0;
    j = 0;
    k = 0;
    l = 0;
    m = 0;
    n = 0;
    ndim = 0;
    nelem = 0;
    ai = [];
    an = [];
    p3 = pop();
    p2 = pop();
    p1 = pop();
    if (!istensor(p1)) {
      if (!iszero(p1)) {
        stop("contract: tensor expected, 1st arg is not a tensor");
      }
      push(zero);
      return;
    }
    push(p2);
    l = pop_integer();
    push(p3);
    m = pop_integer();
    ndim = p1.tensor.ndim;
    if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {
      stop("contract: index out of range");
    }
    l--;
    m--;
    n = p1.tensor.dim[l];
    nelem = 1;
    for (i = _i = 0; 0 <= ndim ? _i < ndim : _i > ndim; i = 0 <= ndim ? ++_i : --_i) {
      if (i !== l && i !== m) {
        nelem *= p1.tensor.dim[i];
      }
    }
    p2 = alloc_tensor(nelem);
    p2.tensor.ndim = ndim - 2;
    j = 0;
    for (i = _j = 0; 0 <= ndim ? _j < ndim : _j > ndim; i = 0 <= ndim ? ++_j : --_j) {
      if (i !== l && i !== m) {
        p2.tensor.dim[j++] = p1.tensor.dim[i];
      }
    }
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    for (i = _k = 0; 0 <= ndim ? _k < ndim : _k > ndim; i = 0 <= ndim ? ++_k : --_k) {
      ai[i] = 0;
      an[i] = p1.tensor.dim[i];
    }
    for (i = _l = 0; 0 <= nelem ? _l < nelem : _l > nelem; i = 0 <= nelem ? ++_l : --_l) {
      push(zero);
      for (j = _m = 0; 0 <= n ? _m < n : _m > n; j = 0 <= n ? ++_m : --_m) {
        ai[l] = j;
        ai[m] = j;
        h = 0;
        for (k = _n = 0; 0 <= ndim ? _n < ndim : _n > ndim; k = 0 <= ndim ? ++_n : --_n) {
          h = (h * an[k]) + ai[k];
        }
        push(a[h]);
        add();
      }
      b[i] = pop();
      for (j = _o = _ref = ndim - 1; _ref <= 0 ? _o <= 0 : _o >= 0; j = _ref <= 0 ? ++_o : --_o) {
        if (j === l || j === m) {
          continue;
        }
        if (++ai[j] < an[j]) {
          break;
        }
        ai[j] = 0;
      }
    }
    if (nelem === 1) {
      return push(b[0]);
    } else {
      return push(p2);
    }
  };

  Eval_cos = function() {
    push(cadr(p1));
    Eval();
    return cosine();
  };

  cosine = function() {
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      cosine_of_angle_sum();
    } else {
      cosine_of_angle();
    }
    return restore();
  };

  cosine_of_angle_sum = function() {
    p2 = cdr(p1);
    while (iscons(p2)) {
      p4 = car(p2);
      if (isnpi(p4)) {
        push(p1);
        push(p4);
        subtract();
        p3 = pop();
        push(p3);
        cosine();
        push(p4);
        cosine();
        multiply();
        push(p3);
        sine();
        push(p4);
        sine();
        multiply();
        subtract();
        return;
      }
      p2 = cdr(p2);
    }
    return cosine_of_angle();
  };

  cosine_of_angle = function() {
    var d, n;
    if (car(p1) === symbol(ARCCOS)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.cos(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (isnegative(p1)) {
      push(p1);
      negate();
      p1 = pop();
    }
    if (car(p1) === symbol(ARCTAN)) {
      push_integer(1);
      push(cadr(p1));
      push_integer(2);
      power();
      add();
      push_rational(-1, 2);
      power();
      return;
    }
    push(p1);
    push_integer(180);
    multiply();
    push_symbol(PI);
    divide();
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push(symbol(COS));
      push(p1);
      list(2);
      return;
    }
    switch (n % 360) {
      case 90:
      case 270:
        return push_integer(0);
      case 60:
      case 300:
        return push_rational(1, 2);
      case 120:
      case 240:
        return push_rational(-1, 2);
      case 45:
      case 315:
        push_rational(1, 2);
        push_integer(2);
        push_rational(1, 2);
        power();
        return multiply();
      case 135:
      case 225:
        push_rational(-1, 2);
        push_integer(2);
        push_rational(1, 2);
        power();
        return multiply();
      case 30:
      case 330:
        push_rational(1, 2);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 150:
      case 210:
        push_rational(-1, 2);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 0:
        return push_integer(1);
      case 180:
        return push_integer(-1);
      default:
        push(symbol(COS));
        push(p1);
        return list(2);
    }
  };

  Eval_cosh = function() {
    push(cadr(p1));
    Eval();
    return ycosh();
  };

  ycosh = function() {
    save();
    yycosh();
    return restore();
  };

  yycosh = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (car(p1) === symbol(ARCCOSH)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.cosh(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (iszero(p1)) {
      push(one);
      return;
    }
    push_symbol(COSH);
    push(p1);
    return list(2);
  };

  Eval_decomp = function() {
    var h;
    h = tos;
    push(symbol(NIL));
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p1 = pop();
    if (p1 === symbol(NIL)) {
      guess();
    } else {
      push(p1);
    }
    decomp();
    return list(tos - h);
  };

  decomp = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (Find(p1, p2) === 0) {
      push(p1);
      restore();
      return;
    }
    if (isadd(p1)) {
      decomp_sum();
      restore();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      decomp_product();
      restore();
      return;
    }
    p3 = cdr(p1);
    while (iscons(p3)) {
      push(car(p3));
      push(p2);
      decomp();
      p3 = cdr(p3);
    }
    return restore();
  };

  decomp_sum = function() {
    var h;
    h = 0;
    p3 = cdr(p1);
    while (iscons(p3)) {
      if (Find(car(p3), p2)) {
        push(car(p3));
        push(p2);
        decomp();
      }
      p3 = cdr(p3);
    }
    h = tos;
    p3 = cdr(p1);
    while (iscons(p3)) {
      if (Find(car(p3), p2) === 0) {
        push(car(p3));
      }
      p3 = cdr(p3);
    }
    if (tos - h) {
      add_all(tos - h);
      p3 = pop();
      push(p3);
      push(p3);
      return negate();
    }
  };

  decomp_product = function() {
    var h;
    h = 0;
    p3 = cdr(p1);
    while (iscons(p3)) {
      if (Find(car(p3), p2)) {
        push(car(p3));
        push(p2);
        decomp();
      }
      p3 = cdr(p3);
    }
    h = tos;
    p3 = cdr(p1);
    while (iscons(p3)) {
      if (Find(car(p3), p2) === 0) {
        push(car(p3));
      }
      p3 = cdr(p3);
    }
    if (tos - h) {
      return multiply_all(tos - h);
    }
  };

  define_user_function = function() {
    p3 = caadr(p1);
    p4 = cdadr(p1);
    p5 = caddr(p1);
    if (!issymbol(p3)) {
      stop("function name?");
    }
    if (car(p5) === symbol(EVAL)) {
      push(cadr(p5));
      Eval();
      p5 = pop();
    }
    set_binding_and_arglist(p3, p5, p4);
    return push_symbol(NIL);
  };

  Eval_defint = function() {
    push(cadr(p1));
    Eval();
    p2 = pop();
    p1 = cddr(p1);
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
      Eval();
      p3 = pop();
      push(car(p1));
      p1 = cdr(p1);
      Eval();
      p4 = pop();
      push(car(p1));
      p1 = cdr(p1);
      Eval();
      p5 = pop();
      push(p2);
      push(p3);
      integral();
      p2 = pop();
      push(p2);
      push(p3);
      push(p5);
      subst();
      Eval();
      push(p2);
      push(p3);
      push(p4);
      subst();
      Eval();
      subtract();
      p2 = pop();
    }
    return push(p2);
  };

  Eval_degree = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p1 = pop();
    if (p1 === symbol(NIL)) {
      guess();
    } else {
      push(p1);
    }
    return degree();
  };

  degree = function() {
    save();
    p2 = pop();
    p1 = pop();
    p3 = zero;
    yydegree(p1);
    push(p3);
    return restore();
  };

  yydegree = function(p) {
    var _results;
    if (equal(p, p2)) {
      if (iszero(p3)) {
        return p3 = one;
      }
    } else if (car(p) === symbol(POWER)) {
      if (equal(cadr(p), p2) && isnum(caddr(p)) && lessp(p3, caddr(p))) {
        return p3 = caddr(p);
      }
    } else if (iscons(p)) {
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        yydegree(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    }
  };

  Eval_denominator = function() {
    push(cadr(p1));
    Eval();
    return denominator();
  };

  denominator = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      push(p1);
      rationalize();
      p1 = pop();
    }
    if (car(p1) === symbol(MULTIPLY)) {
      h = tos;
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        denominator();
        p1 = cdr(p1);
      }
      multiply_all(tos - h);
    } else if (isrational(p1)) {
      push(p1);
      mp_denominator();
    } else if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
      push(p1);
      reciprocate();
    } else {
      push(one);
    }
    return restore();
  };

  Eval_derivative = function() {
    var doNothing, i, n, _i, _j;
    i = 0;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
      push(symbol(NIL));
    } else if (isnum(p2)) {
      guess();
      push(p2);
    } else {
      push(p2);
      p1 = cdr(p1);
      push(car(p1));
      Eval();
    }
    p5 = pop();
    p4 = pop();
    p3 = pop();
    while (1.) {
      if (isnum(p5)) {
        push(p5);
        n = pop_integer();
        if (n === 0x80000000) {
          stop("nth derivative: check n");
        }
      } else {
        n = 1;
      }
      push(p3);
      if (n >= 0) {
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          push(p4);
          derivative();
        }
      } else {
        n = -n;
        for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
          push(p4);
          integral();
        }
      }
      p3 = pop();
      if (p5 === symbol(NIL)) {
        break;
      }
      if (isnum(p5)) {
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
        if (p5 === symbol(NIL)) {
          break;
        }
        if (isnum(p5)) {
          doNothing = 1;
        } else {
          p4 = p5;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p5 = pop();
        }
      } else {
        p4 = p5;
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
      }
    }
    return push(p3);
  };

  derivative = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (isnum(p2)) {
      stop("undefined function");
    }
    if (istensor(p1)) {
      if (istensor(p2)) {
        d_tensor_tensor();
      } else {
        d_tensor_scalar();
      }
    } else {
      if (istensor(p2)) {
        d_scalar_tensor();
      } else {
        d_scalar_scalar();
      }
    }
    return restore();
  };

  d_scalar_scalar = function() {
    if (issymbol(p2)) {
      return d_scalar_scalar_1();
    } else {
      push(p1);
      push(p2);
      push(symbol(SECRETX));
      subst();
      push(symbol(SECRETX));
      derivative();
      push(symbol(SECRETX));
      push(p2);
      return subst();
    }
  };

  d_scalar_scalar_1 = function() {
    if (equal(p1, p2)) {
      push(one);
      return;
    }
    if (!iscons(p1)) {
      push(zero);
      return;
    }
    if (isadd(p1)) {
      dsum();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      dproduct();
      return;
    }
    if (car(p1) === symbol(POWER)) {
      dpower();
      return;
    }
    if (car(p1) === symbol(DERIVATIVE)) {
      dd();
      return;
    }
    if (car(p1) === symbol(LOG)) {
      dlog();
      return;
    }
    if (car(p1) === symbol(SIN)) {
      dsin();
      return;
    }
    if (car(p1) === symbol(COS)) {
      dcos();
      return;
    }
    if (car(p1) === symbol(TAN)) {
      dtan();
      return;
    }
    if (car(p1) === symbol(ARCSIN)) {
      darcsin();
      return;
    }
    if (car(p1) === symbol(ARCCOS)) {
      darccos();
      return;
    }
    if (car(p1) === symbol(ARCTAN)) {
      darctan();
      return;
    }
    if (car(p1) === symbol(SINH)) {
      dsinh();
      return;
    }
    if (car(p1) === symbol(COSH)) {
      dcosh();
      return;
    }
    if (car(p1) === symbol(TANH)) {
      dtanh();
      return;
    }
    if (car(p1) === symbol(ARCSINH)) {
      darcsinh();
      return;
    }
    if (car(p1) === symbol(ARCCOSH)) {
      darccosh();
      return;
    }
    if (car(p1) === symbol(ARCTANH)) {
      darctanh();
      return;
    }
    if (car(p1) === symbol(ABS)) {
      dabs();
      return;
    }
    if (car(p1) === symbol(SGN)) {
      dsgn();
      return;
    }
    if (car(p1) === symbol(HERMITE)) {
      dhermite();
      return;
    }
    if (car(p1) === symbol(ERF)) {
      derf();
      return;
    }
    if (car(p1) === symbol(ERFC)) {
      derfc();
      return;
    }
    if (car(p1) === symbol(BESSELJ)) {
      if (iszero(caddr(p1))) {
        dbesselj0();
      } else {
        dbesseljn();
      }
      return;
    }
    if (car(p1) === symbol(BESSELY)) {
      if (iszero(caddr(p1))) {
        dbessely0();
      } else {
        dbesselyn();
      }
      return;
    }
    if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {
      derivative_of_integral();
      return;
    }
    return dfunction();
  };

  dsum = function() {
    var h;
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      derivative();
      p1 = cdr(p1);
    }
    return add_all(tos - h);
  };

  dproduct = function() {
    var i, j, n, _i, _j;
    i = 0;
    j = 0;
    n = 0;
    n = length(p1) - 1;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      p3 = cdr(p1);
      for (j = _j = 0; 0 <= n ? _j < n : _j > n; j = 0 <= n ? ++_j : --_j) {
        push(car(p3));
        if (i === j) {
          push(p2);
          derivative();
        }
        p3 = cdr(p3);
      }
      multiply_all(n);
    }
    return add_all(n);
  };

  dpower = function() {
    push(caddr(p1));
    push(cadr(p1));
    divide();
    push(cadr(p1));
    push(p2);
    derivative();
    multiply();
    push(cadr(p1));
    logarithm();
    push(caddr(p1));
    push(p2);
    derivative();
    multiply();
    add();
    push(p1);
    return multiply();
  };

  dlog = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    return divide();
  };

  dd = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    p3 = pop();
    if (car(p3) === symbol(DERIVATIVE)) {
      push_symbol(DERIVATIVE);
      push_symbol(DERIVATIVE);
      push(cadr(p3));
      if (lessp(caddr(p3), caddr(p1))) {
        push(caddr(p3));
        list(3);
        push(caddr(p1));
      } else {
        push(caddr(p1));
        list(3);
        push(caddr(p3));
      }
      return list(3);
    } else {
      push(p3);
      push(caddr(p1));
      return derivative();
    }
  };

  dfunction = function() {
    p3 = cdr(p1);
    if (p3 === symbol(NIL) || Find(p3, p2)) {
      push_symbol(DERIVATIVE);
      push(p1);
      push(p2);
      return list(3);
    } else {
      return push(zero);
    }
  };

  dsin = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    cosine();
    return multiply();
  };

  dcos = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    sine();
    multiply();
    return negate();
  };

  dtan = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    cosine();
    push_integer(-2);
    power();
    return multiply();
  };

  darcsin = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    subtract();
    push_rational(-1, 2);
    power();
    return multiply();
  };

  darccos = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    subtract();
    push_rational(-1, 2);
    power();
    multiply();
    return negate();
  };

  darctan = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    add();
    inverse();
    multiply();
    return simplify();
  };

  dsinh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    ycosh();
    return multiply();
  };

  dcosh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    ysinh();
    return multiply();
  };

  dtanh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    ycosh();
    push_integer(-2);
    power();
    return multiply();
  };

  darcsinh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push_integer(2);
    power();
    push_integer(1);
    add();
    push_rational(-1, 2);
    power();
    return multiply();
  };

  darccosh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push_integer(2);
    power();
    push_integer(-1);
    add();
    push_rational(-1, 2);
    power();
    return multiply();
  };

  darctanh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    subtract();
    inverse();
    return multiply();
  };

  dabs = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    sgn();
    return multiply();
  };

  dsgn = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    dirac();
    multiply();
    push_integer(2);
    return multiply();
  };

  dhermite = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(2);
    push(caddr(p1));
    multiply();
    multiply();
    push(cadr(p1));
    push(caddr(p1));
    push_integer(-1);
    add();
    hermite();
    return multiply();
  };

  derf = function() {
    push(cadr(p1));
    push_integer(2);
    power();
    push_integer(-1);
    multiply();
    exponential();
    push_symbol(PI);
    push_rational(-1, 2);
    power();
    multiply();
    push_integer(2);
    multiply();
    push(cadr(p1));
    push(p2);
    derivative();
    return multiply();
  };

  derfc = function() {
    push(cadr(p1));
    push_integer(2);
    power();
    push_integer(-1);
    multiply();
    exponential();
    push_symbol(PI);
    push_rational(-1, 2);
    power();
    multiply();
    push_integer(-2);
    multiply();
    push(cadr(p1));
    push(p2);
    derivative();
    return multiply();
  };

  dbesselj0 = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push_integer(1);
    besselj();
    multiply();
    push_integer(-1);
    return multiply();
  };

  dbesseljn = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push(caddr(p1));
    push_integer(-1);
    add();
    besselj();
    push(caddr(p1));
    push_integer(-1);
    multiply();
    push(cadr(p1));
    divide();
    push(cadr(p1));
    push(caddr(p1));
    besselj();
    multiply();
    add();
    return multiply();
  };

  dbessely0 = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push_integer(1);
    besselj();
    multiply();
    push_integer(-1);
    return multiply();
  };

  dbesselyn = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push(caddr(p1));
    push_integer(-1);
    add();
    bessely();
    push(caddr(p1));
    push_integer(-1);
    multiply();
    push(cadr(p1));
    divide();
    push(cadr(p1));
    push(caddr(p1));
    bessely();
    multiply();
    add();
    return multiply();
  };

  derivative_of_integral = function() {
    return push(cadr(p1));
  };

  DET_check_arg = function() {
    if (!istensor(p1)) {
      return 0;
    } else if (p1.tensor.ndim !== 2) {
      return 0;
    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {
      return 0;
    } else {
      return 1;
    }
  };

  det = function() {
    var a, i, n, _i, _j, _ref;
    i = 0;
    n = 0;
    save();
    p1 = pop();
    if (DET_check_arg() === 0) {
      push_symbol(DET);
      push(p1);
      list(2);
      restore();
      return;
    }
    n = p1.tensor.nelem;
    a = p1.tensor.elem;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      if (!isnum(a[i])) {
        break;
      }
    }
    if (i === n) {
      yydetg();
    } else {
      for (i = _j = 0, _ref = p1.tensor.nelem; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        push(p1.tensor.elem[i]);
      }
      determinant(p1.tensor.dim[0]);
    }
    return restore();
  };

  determinant = function(n) {
    var a, breakFromOutherWhile, h, i, j, k, q, s, sign_, t, _i, _j;
    h = 0;
    i = 0;
    j = 0;
    k = 0;
    q = 0;
    s = 0;
    sign_ = 0;
    t = 0;
    a = [];
    h = tos - n * n;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      a[i] = i;
      a[i + n] = 0;
      a[i + n + n] = 1;
    }
    sign_ = 1;
    push(zero);
    while (1) {
      if (sign_ === 1) {
        push_integer(1);
      } else {
        push_integer(-1);
      }
      for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
        k = n * a[i] + i;
        push(stack[h + k]);
        multiply();
      }
      add();
      j = n - 1;
      s = 0;
      breakFromOutherWhile = false;
      while (1) {
        q = a[n + j] + a[n + n + j];
        if (q < 0) {
          a[n + n + j] = -a[n + n + j];
          j--;
          continue;
        }
        if (q === j + 1) {
          if (j === 0) {
            breakFromOutherWhile = true;
            break;
          }
          s++;
          a[n + n + j] = -a[n + n + j];
          j--;
          continue;
        }
        break;
      }
      if (breakFromOutherWhile) {
        break;
      }
      t = a[j - a[n + j] + s];
      a[j - a[n + j] + s] = a[j - q + s];
      a[j - q + s] = t;
      a[n + j] = q;
      sign_ = -sign_;
    }
    stack[h] = stack[tos - 1];
    return tos = h + 1;
  };

  detg = function() {
    save();
    p1 = pop();
    if (DET_check_arg() === 0) {
      push_symbol(DET);
      push(p1);
      list(2);
      restore();
      return;
    }
    yydetg();
    return restore();
  };

  yydetg = function() {
    var i, n, _i, _ref;
    i = 0;
    n = 0;
    n = p1.tensor.dim[0];
    for (i = _i = 0, _ref = n * n; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      push(p1.tensor.elem[i]);
    }
    lu_decomp(n);
    tos -= n * n;
    return push(p1);
  };

  M = function(h, n, i, j) {
    return stack[h + n * i + j];
  };

  setM = function(h, n, i, j, value) {
    return stack[h + n * i + j] = value;
  };

  lu_decomp = function(n) {
    var d, h, i, j, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3;
    d = 0;
    h = 0;
    i = 0;
    j = 0;
    h = tos - n * n;
    p1 = one;
    for (d = _i = 0, _ref = n - 1; 0 <= _ref ? _i < _ref : _i > _ref; d = 0 <= _ref ? ++_i : --_i) {
      if (equal(M(h, n, d, d), zero)) {
        for (i = _j = _ref1 = d + 1; _ref1 <= n ? _j < n : _j > n; i = _ref1 <= n ? ++_j : --_j) {
          if (!equal(M(h, n, i, d), zero)) {
            break;
          }
        }
        if (i === n) {
          p1 = zero;
          break;
        }
        for (j = _k = d; d <= n ? _k < n : _k > n; j = d <= n ? ++_k : --_k) {
          p2 = M(h, n, d, j);
          setM(h, n, d, j, M(h, n, i, j));
          setM(h, n, i, j, p2);
        }
        push(p1);
        negate();
        p1 = pop();
      }
      push(p1);
      push(M(h, n, d, d));
      multiply();
      p1 = pop();
      for (i = _l = _ref2 = d + 1; _ref2 <= n ? _l < n : _l > n; i = _ref2 <= n ? ++_l : --_l) {
        push(M(h, n, i, d));
        push(M(h, n, d, d));
        divide();
        negate();
        p2 = pop();
        setM(h, n, i, d, zero);
        for (j = _m = _ref3 = d + 1; _ref3 <= n ? _m < n : _m > n; j = _ref3 <= n ? ++_m : --_m) {
          push(M(h, n, d, j));
          push(p2);
          multiply();
          push(M(h, n, i, j));
          add();
          setM(h, n, i, j, pop());
        }
      }
    }
    push(p1);
    push(M(h, n, n - 1, n - 1));
    multiply();
    return p1 = pop();
  };

  Eval_dirac = function() {
    push(cadr(p1));
    Eval();
    return dirac();
  };

  dirac = function() {
    save();
    ydirac();
    return restore();
  };

  ydirac = function() {
    p1 = pop();
    if (isdouble(p1)) {
      if (p1.d === 0) {
        push_integer(1);
        return;
      } else {
        push_integer(0);
        return;
      }
    }
    if (isrational(p1)) {
      if (MZERO(mmul(p1.q.a, p1.q.b))) {
        push_integer(1);
        return;
      } else {
        push_integer(0);
        return;
      }
    }
    if (car(p1) === symbol(POWER)) {
      push_symbol(DIRAC);
      push(cadr(p1));
      list(2);
      return;
    }
    if (isnegativeterm(p1)) {
      push_symbol(DIRAC);
      push(p1);
      negate();
      list(2);
      return;
    }
    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {
      push(p1);
      negate();
      p1 = pop();
    }
    push_symbol(DIRAC);
    push(p1);
    return list(2);
  };

  divisors = function() {
    var h, i, n, subsetOfStack, _i;
    i = 0;
    h = 0;
    n = 0;
    save();
    h = tos - 1;
    divisors_onstack();
    n = tos - h;
    subsetOfStack = stack.slice(h, h + n);
    subsetOfStack.sort(cmp_expr);
    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
    p1 = alloc_tensor(n);
    p1.tensor.ndim = 1;
    p1.tensor.dim[0] = n;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      p1.tensor.elem[i] = stack[h + i];
    }
    tos = h;
    push(p1);
    return restore();
  };

  divisors_onstack = function() {
    var h, i, k, n, _i;
    h = 0;
    i = 0;
    k = 0;
    n = 0;
    save();
    p1 = pop();
    h = tos;
    if (isnum(p1)) {
      push(p1);
      factor_small_number();
    } else if (car(p1) === symbol(ADD)) {
      push(p1);
      __factor_add();
    } else if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      if (isnum(car(p1))) {
        push(car(p1));
        factor_small_number();
        p1 = cdr(p1);
      }
      while (iscons(p1)) {
        p2 = car(p1);
        if (car(p2) === symbol(POWER)) {
          push(cadr(p2));
          push(caddr(p2));
        } else {
          push(p2);
          push(one);
        }
        p1 = cdr(p1);
      }
    } else if (car(p1) === symbol(POWER)) {
      push(cadr(p1));
      push(caddr(p1));
    } else {
      push(p1);
      push(one);
    }
    k = tos;
    push(one);
    gen(h, k);
    n = tos - k;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      stack[h + i] = stack[k + i];
    }
    tos = h + n;
    return restore();
  };

  gen = function(h, k) {
    var expo, i, _i, _ref;
    expo = 0;
    i = 0;
    save();
    p1 = pop();
    if (h === k) {
      push(p1);
      restore();
      return;
    }
    p2 = stack[h + 0];
    p3 = stack[h + 1];
    push(p3);
    expo = pop_integer();
    for (i = _i = 0, _ref = Math.abs(expo); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      push(p1);
      push(p2);
      push_integer(sign(expo) * i);
      power();
      multiply();
      gen(h + 2, k);
    }
    return restore();
  };

  __factor_add = function() {
    save();
    p1 = pop();
    p3 = cdr(p1);
    push(car(p3));
    p3 = cdr(p3);
    while (iscons(p3)) {
      push(car(p3));
      gcd();
      p3 = cdr(p3);
    }
    p2 = pop();
    if (isplusone(p2)) {
      push(p1);
      push(one);
      restore();
      return;
    }
    if (isnum(p2)) {
      push(p2);
      factor_small_number();
    } else if (car(p2) === symbol(MULTIPLY)) {
      p3 = cdr(p2);
      if (isnum(car(p3))) {
        push(car(p3));
        factor_small_number();
      } else {
        push(car(p3));
        push(one);
      }
      p3 = cdr(p3);
      while (iscons(p3)) {
        push(car(p3));
        push(one);
        p3 = cdr(p3);
      }
    } else {
      push(p2);
      push(one);
    }
    push(p2);
    inverse();
    p2 = pop();
    push(zero);
    p3 = cdr(p1);
    while (iscons(p3)) {
      push(p2);
      push(car(p3));
      multiply();
      add();
      p3 = cdr(p3);
    }
    push(one);
    return restore();
  };

  dpow = function() {
    var a, b, base, expo, result, theta;
    a = 0.0;
    b = 0.0;
    base = 0.0;
    expo = 0.0;
    result = 0.0;
    theta = 0.0;
    expo = pop_double();
    base = pop_double();
    if (base === 0.0 && expo < 0.0) {
      stop("divide by zero");
    }
    if (base >= 0.0 || (expo % 1.0) === 0.0) {
      result = Math.pow(base, expo);
      push_double(result);
      return;
    }
    result = Math.pow(Math.abs(base), expo);
    theta = Math.PI * expo;
    if ((expo % 0.5) === 0.0) {
      a = 0.0;
      b = Math.sin(theta);
    } else {
      a = Math.cos(theta);
      b = Math.sin(theta);
    }
    push_double(a * result);
    push_double(b * result);
    push(imaginaryunit);
    multiply();
    return add();
  };

  EIG_N = 0;

  EIG_yydd = [];

  EIG_yyqq = [];

  Eval_eigen = function() {
    if (EIG_check_arg() === 0) {
      stop("eigen: argument is not a square matrix");
    }
    eigen(EIGEN);
    p1 = usr_symbol("D");
    set_binding(p1, p2);
    p1 = usr_symbol("Q");
    set_binding(p1, p3);
    return push(symbol(NIL));
  };

  Eval_eigenval = function() {
    if (EIG_check_arg() === 0) {
      push_symbol(EIGENVAL);
      push(p1);
      list(2);
      return;
    }
    eigen(EIGENVAL);
    return push(p2);
  };

  Eval_eigenvec = function() {
    if (EIG_check_arg() === 0) {
      push_symbol(EIGENVEC);
      push(p1);
      list(2);
      return;
    }
    eigen(EIGENVEC);
    return push(p3);
  };

  EIG_check_arg = function() {
    var i, j, _i, _j, _k, _l, _ref, _ref1;
    i = 0;
    j = 0;
    push(cadr(p1));
    Eval();
    yyfloat();
    Eval();
    p1 = pop();
    if (!istensor(p1)) {
      return 0;
    }
    if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {
      stop("eigen: argument is not a square matrix");
    }
    EIG_N = p1.tensor.dim[0];
    for (i = _i = 0; 0 <= EIG_N ? _i < EIG_N : _i > EIG_N; i = 0 <= EIG_N ? ++_i : --_i) {
      for (j = _j = 0; 0 <= EIG_N ? _j < EIG_N : _j > EIG_N; j = 0 <= EIG_N ? ++_j : --_j) {
        if (!isdouble(p1.tensor.elem[EIG_N * i + j])) {
          stop("eigen: matrix is not numerical");
        }
      }
    }
    for (i = _k = 0, _ref = EIG_N - 1; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
      for (j = _l = _ref1 = i + 1; _ref1 <= EIG_N ? _l < EIG_N : _l > EIG_N; j = _ref1 <= EIG_N ? ++_l : --_l) {
        if (Math.abs(p1.tensor.elem[EIG_N * i + j].d - p1.tensor.elem[EIG_N * j + i].d) > 1e-10) {
          stop("eigen: matrix is not symmetrical");
        }
      }
    }
    return 1;
  };

  eigen = function(op) {
    var i, j, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _results;
    i = 0;
    j = 0;
    for (i = _i = 0, _ref = EIG_N * EIG_N; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      EIG_yydd[i] = 0.0;
    }
    for (i = _j = 0, _ref1 = EIG_N * EIG_N; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      EIG_yyqq[i] = 0.0;
    }
    for (i = _k = 0; 0 <= EIG_N ? _k < EIG_N : _k > EIG_N; i = 0 <= EIG_N ? ++_k : --_k) {
      EIG_yydd[EIG_N * i + i] = p1.tensor.elem[EIG_N * i + i].d;
      for (j = _l = _ref2 = i + 1; _ref2 <= EIG_N ? _l < EIG_N : _l > EIG_N; j = _ref2 <= EIG_N ? ++_l : --_l) {
        EIG_yydd[EIG_N * i + j] = p1.tensor.elem[EIG_N * i + j].d;
        EIG_yydd[EIG_N * j + i] = p1.tensor.elem[EIG_N * i + j].d;
      }
    }
    for (i = _m = 0; 0 <= EIG_N ? _m < EIG_N : _m > EIG_N; i = 0 <= EIG_N ? ++_m : --_m) {
      EIG_yyqq[EIG_N * i + i] = 1.0;
      for (j = _n = _ref3 = i + 1; _ref3 <= EIG_N ? _n < EIG_N : _n > EIG_N; j = _ref3 <= EIG_N ? ++_n : --_n) {
        EIG_yyqq[EIG_N * i + j] = 0.0;
        EIG_yyqq[EIG_N * j + i] = 0.0;
      }
    }
    for (i = _o = 0; _o < 100; i = ++_o) {
      if (step() === 0) {
        break;
      }
    }
    if (i === 100) {
      printstr("\nnote: eigen did not converge\n");
    }
    if (op === EIGEN || op === EIGENVAL) {
      push(p1);
      copy_tensor();
      p2 = pop();
      for (i = _p = 0; 0 <= EIG_N ? _p < EIG_N : _p > EIG_N; i = 0 <= EIG_N ? ++_p : --_p) {
        for (j = _q = 0; 0 <= EIG_N ? _q < EIG_N : _q > EIG_N; j = 0 <= EIG_N ? ++_q : --_q) {
          push_double(EIG_yydd[EIG_N * i + j]);
          p2.tensor.elem[EIG_N * i + j] = pop();
        }
      }
    }
    if (op === EIGEN || op === EIGENVEC) {
      push(p1);
      copy_tensor();
      p3 = pop();
      _results = [];
      for (i = _r = 0; 0 <= EIG_N ? _r < EIG_N : _r > EIG_N; i = 0 <= EIG_N ? ++_r : --_r) {
        _results.push((function() {
          var _results1, _s;
          _results1 = [];
          for (j = _s = 0; 0 <= EIG_N ? _s < EIG_N : _s > EIG_N; j = 0 <= EIG_N ? ++_s : --_s) {
            push_double(EIG_yyqq[EIG_N * i + j]);
            _results1.push(p3.tensor.elem[EIG_N * i + j] = pop());
          }
          return _results1;
        })());
      }
      return _results;
    }
  };

  step = function() {
    var count, i, j, _i, _j, _ref, _ref1;
    i = 0;
    j = 0;
    count = 0;
    for (i = _i = 0, _ref = EIG_N - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = _ref1 = i + 1; _ref1 <= EIG_N ? _j < EIG_N : _j > EIG_N; j = _ref1 <= EIG_N ? ++_j : --_j) {
        if (EIG_yydd[EIG_N * i + j] !== 0.0) {
          step2(i, j);
          count++;
        }
      }
    }
    return count;
  };

  step2 = function(p, q) {
    var c, cc, k, s, ss, t, theta, _i, _j, _k;
    k = 0;
    t = 0.0;
    theta = 0.0;
    c = 0.0;
    cc = 0.0;
    s = 0.0;
    ss = 0.0;
    theta = 0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p + q];
    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));
    if (theta < 0.0) {
      t = -t;
    }
    c = 1.0 / Math.sqrt(t * t + 1.0);
    s = t * c;
    for (k = _i = 0; 0 <= EIG_N ? _i < EIG_N : _i > EIG_N; k = 0 <= EIG_N ? ++_i : --_i) {
      cc = EIG_yydd[EIG_N * p + k];
      ss = EIG_yydd[EIG_N * q + k];
      EIG_yydd[EIG_N * p + k] = c * cc + s * ss;
      EIG_yydd[EIG_N * q + k] = c * ss - s * cc;
    }
    for (k = _j = 0; 0 <= EIG_N ? _j < EIG_N : _j > EIG_N; k = 0 <= EIG_N ? ++_j : --_j) {
      cc = EIG_yydd[EIG_N * k + p];
      ss = EIG_yydd[EIG_N * k + q];
      EIG_yydd[EIG_N * k + p] = c * cc + s * ss;
      EIG_yydd[EIG_N * k + q] = c * ss - s * cc;
    }
    for (k = _k = 0; 0 <= EIG_N ? _k < EIG_N : _k > EIG_N; k = 0 <= EIG_N ? ++_k : --_k) {
      cc = EIG_yyqq[EIG_N * p + k];
      ss = EIG_yyqq[EIG_N * q + k];
      EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;
      EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;
    }
    EIG_yydd[EIG_N * p + q] = 0.0;
    return EIG_yydd[EIG_N * q + p] = 0.0;
  };

  Eval_erf = function() {
    push(cadr(p1));
    Eval();
    return yerf();
  };

  yerf = function() {
    save();
    yyerf();
    return restore();
  };

  yyerf = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (isdouble(p1)) {
      d = 1.0 - erfc(p1.d);
      push_double(d);
      return;
    }
    if (isnegativeterm(p1)) {
      push_symbol(ERF);
      push(p1);
      negate();
      list(2);
      negate();
      return;
    }
    push_symbol(ERF);
    push(p1);
    list(2);
  };

  Eval_erfc = function() {
    push(cadr(p1));
    Eval();
    return yerfc();
  };

  yerfc = function() {
    save();
    yyerfc();
    return restore();
  };

  yyerfc = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (isdouble(p1)) {
      d = erfc(p1.d);
      push_double(d);
      return;
    }
    push_symbol(ERFC);
    push(p1);
    list(2);
  };

  erfc = function(x) {
    var ans, t, z;
    t = 0.0;
    z = 0.0;
    ans = 0.0;
    z = Math.abs(x);
    t = 1.0 / (1.0 + 0.5 * z);
    ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));
    if (x >= 0.0) {
      return ans;
    } else {
      return 2.0 - ans;
    }
  };


  /*
  	 * commented-out test
  	"float(erfc(1))",
  	"0.157299",
   */

  Eval = function() {
    check_esc_flag();
    save();
    p1 = pop();
    if (p1 == null) {
      debugger;
    }
    switch (p1.k) {
      case CONS:
        Eval_cons();
        break;
      case NUM:
        push(p1);
        break;
      case DOUBLE:
        push(p1);
        break;
      case STR:
        push(p1);
        break;
      case TENSOR:
        Eval_tensor();
        break;
      case SYM:
        Eval_sym();
        break;
      default:
        stop("atom?");
    }
    return restore();
  };

  Eval_sym = function() {
    if (iskeyword(p1)) {
      push(p1);
      push(symbol(LAST));
      list(2);
      Eval();
      return;
    }
    p2 = get_binding(p1);
    push(p2);
    if (p1 !== p2) {
      return Eval();
    }
  };

  Eval_cons = function() {
    if (!issymbol(car(p1))) {
      stop("cons?");
    }
    switch (symnum(car(p1))) {
      case ABS:
        return Eval_abs();
      case ADD:
        return Eval_add();
      case ADJ:
        return Eval_adj();
      case AND:
        return Eval_and();
      case ARCCOS:
        return Eval_arccos();
      case ARCCOSH:
        return Eval_arccosh();
      case ARCSIN:
        return Eval_arcsin();
      case ARCSINH:
        return Eval_arcsinh();
      case ARCTAN:
        return Eval_arctan();
      case ARCTANH:
        return Eval_arctanh();
      case ARG:
        return Eval_arg();
      case ATOMIZE:
        return Eval_atomize();
      case BESSELJ:
        return Eval_besselj();
      case BESSELY:
        return Eval_bessely();
      case BINDING:
        return Eval_binding();
      case BINOMIAL:
        return Eval_binomial();
      case CEILING:
        return Eval_ceiling();
      case CHECK:
        return Eval_check();
      case CHOOSE:
        return Eval_choose();
      case CIRCEXP:
        return Eval_circexp();
      case CLEAR:
        return Eval_clear();
      case CLOCK:
        return Eval_clock();
      case COEFF:
        return Eval_coeff();
      case COFACTOR:
        return Eval_cofactor();
      case CONDENSE:
        return Eval_condense();
      case CONJ:
        return Eval_conj();
      case CONTRACT:
        return Eval_contract();
      case COS:
        return Eval_cos();
      case COSH:
        return Eval_cosh();
      case DECOMP:
        return Eval_decomp();
      case DEGREE:
        return Eval_degree();
      case DEFINT:
        return Eval_defint();
      case DENOMINATOR:
        return Eval_denominator();
      case DERIVATIVE:
        return Eval_derivative();
      case DET:
        return Eval_det();
      case DIM:
        return Eval_dim();
      case DIRAC:
        return Eval_dirac();
      case DISPLAY:
        return Eval_display();
      case DIVISORS:
        return Eval_divisors();
      case DO:
        return Eval_do();
      case DOT:
        return Eval_inner();
      case DRAW:
        return Eval_draw();
      case DSOLVE:
        return Eval_dsolve();
      case EIGEN:
        return Eval_eigen();
      case EIGENVAL:
        return Eval_eigenval();
      case EIGENVEC:
        return Eval_eigenvec();
      case ERF:
        return Eval_erf();
      case ERFC:
        return Eval_erfc();
      case EVAL:
        return Eval_Eval();
      case EXP:
        return Eval_exp();
      case EXPAND:
        return Eval_expand();
      case EXPCOS:
        return Eval_expcos();
      case EXPSIN:
        return Eval_expsin();
      case FACTOR:
        return Eval_factor();
      case FACTORIAL:
        return Eval_factorial();
      case FACTORPOLY:
        return Eval_factorpoly();
      case FILTER:
        return Eval_filter();
      case FLOATF:
        return Eval_float();
      case FLOOR:
        return Eval_floor();
      case FOR:
        return Eval_for();
      case GAMMA:
        return Eval_gamma();
      case GCD:
        return Eval_gcd();
      case HERMITE:
        return Eval_hermite();
      case HILBERT:
        return Eval_hilbert();
      case IMAG:
        return Eval_imag();
      case INDEX:
        return Eval_index();
      case INNER:
        return Eval_inner();
      case INTEGRAL:
        return Eval_integral();
      case INV:
        return Eval_inv();
      case INVG:
        return Eval_invg();
      case ISINTEGER:
        return Eval_isinteger();
      case ISPRIME:
        return Eval_isprime();
      case LAGUERRE:
        return Eval_laguerre();
      case LCM:
        return Eval_lcm();
      case LEADING:
        return Eval_leading();
      case LEGENDRE:
        return Eval_legendre();
      case LOG:
        return Eval_log();
      case MAG:
        return Eval_mag();
      case MOD:
        return Eval_mod();
      case MULTIPLY:
        return Eval_multiply();
      case NOT:
        return Eval_not();
      case NROOTS:
        return Eval_nroots();
      case NUMBER:
        return Eval_number();
      case NUMERATOR:
        return Eval_numerator();
      case OPERATOR:
        return Eval_operator();
      case OR:
        return Eval_or();
      case OUTER:
        return Eval_outer();
      case POLAR:
        return Eval_polar();
      case POWER:
        return Eval_power();
      case PRIME:
        return Eval_prime();
      case PRINT:
        return Eval_display();
      case PRODUCT:
        return Eval_product();
      case QUOTE:
        return Eval_quote();
      case QUOTIENT:
        return Eval_quotient();
      case RANK:
        return Eval_rank();
      case RATIONALIZE:
        return Eval_rationalize();
      case REAL:
        return Eval_real();
      case YYRECT:
        return Eval_rect();
      case ROOTS:
        return Eval_roots();
      case SETQ:
        return Eval_setq();
      case SGN:
        return Eval_sgn();
      case SIMPLIFY:
        return Eval_simplify();
      case SIN:
        return Eval_sin();
      case SINH:
        return Eval_sinh();
      case SQRT:
        return Eval_sqrt();
      case STOP:
        return Eval_stop();
      case SUBST:
        return Eval_subst();
      case SUM:
        return Eval_sum();
      case TAN:
        return Eval_tan();
      case TANH:
        return Eval_tanh();
      case TAYLOR:
        return Eval_taylor();
      case TEST:
        return Eval_test();
      case TESTEQ:
        return Eval_testeq();
      case TESTGE:
        return Eval_testge();
      case TESTGT:
        return Eval_testgt();
      case TESTLE:
        return Eval_testle();
      case TESTLT:
        return Eval_testlt();
      case TRANSPOSE:
        return Eval_transpose();
      case UNIT:
        return Eval_unit();
      case ZERO:
        return Eval_zero();
      default:
        return Eval_user_function();
    }
  };

  Eval_binding = function() {
    return push(get_binding(cadr(p1)));
  };

  Eval_check = function() {
    push(cadr(p1));
    Eval_predicate();
    p1 = pop();
    if (iszero(p1)) {
      stop("check(arg): arg is zero");
    }
    return push(symbol(NIL));
  };

  Eval_det = function() {
    push(cadr(p1));
    Eval();
    return det();
  };

  Eval_dim = function() {
    var n;
    push(cadr(p1));
    Eval();
    p2 = pop();
    if (iscons(cddr(p1))) {
      push(caddr(p1));
      Eval();
      n = pop_integer();
    } else {
      n = 1;
    }
    if (!istensor(p2)) {
      return push_integer(1);
    } else if (n < 1 || n > p2.tensor.ndim) {
      return push(p1);
    } else {
      return push_integer(p2.tensor.dim[n - 1]);
    }
  };

  Eval_divisors = function() {
    push(cadr(p1));
    Eval();
    return divisors();
  };

  Eval_do = function() {
    var _results;
    push(car(p1));
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      pop();
      push(car(p1));
      Eval();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  Eval_dsolve = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    return dsolve();
  };

  Eval_Eval = function() {
    push(cadr(p1));
    Eval();
    p1 = cddr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      push(cadr(p1));
      Eval();
      subst();
      p1 = cddr(p1);
    }
    return Eval();
  };

  Eval_exp = function() {
    push(cadr(p1));
    Eval();
    return exponential();
  };

  Eval_factorial = function() {
    push(cadr(p1));
    Eval();
    return factorial();
  };

  Eval_factorpoly = function() {
    var _results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    factorpoly();
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      factorpoly();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  Eval_hermite = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return hermite();
  };

  Eval_hilbert = function() {
    push(cadr(p1));
    Eval();
    return hilbert();
  };

  Eval_index = function() {
    var h;
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p1 = cdr(p1);
    }
    return index_function(tos - h);
  };

  Eval_inv = function() {
    push(cadr(p1));
    Eval();
    return inv();
  };

  Eval_invg = function() {
    push(cadr(p1));
    Eval();
    return invg();
  };

  Eval_isinteger = function() {
    var n;
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (isrational(p1)) {
      if (isinteger(p1)) {
        push(one);
      } else {
        push(zero);
      }
      return;
    }
    if (isdouble(p1)) {
      n = Math.floor(p1.d);
      if (n === p1.d) {
        push(one);
      } else {
        push(zero);
      }
      return;
    }
    push_symbol(ISINTEGER);
    push(p1);
    return list(2);
  };

  Eval_multiply = function() {
    var _results;
    push(cadr(p1));
    Eval();
    p1 = cddr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      multiply();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  Eval_number = function() {
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (p1.k === NUM || p1.k === DOUBLE) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_operator = function() {
    var h;
    h = tos;
    push_symbol(OPERATOR);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p1 = cdr(p1);
    }
    return list(tos - h);
  };

  Eval_print = function() {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      if (equaln(get_binding(symbol(TTY)), 1)) {
        printline(pop());
      } else {
        display(pop());
      }
      p1 = cdr(p1);
    }
    return push(symbol(NIL));
  };

  Eval_quote = function() {
    return push(cadr(p1));
  };

  Eval_rank = function() {
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (istensor(p1)) {
      return push_integer(p1.tensor.ndim);
    } else {
      return push(zero);
    }
  };

  setq_indexed = function() {
    var h;
    p4 = cadadr(p1);
    if (!issymbol(p4)) {
      stop("indexed assignment: error in symbol");
    }
    h = tos;
    push(caddr(p1));
    Eval();
    p2 = cdadr(p1);
    while (iscons(p2)) {
      push(car(p2));
      Eval();
      p2 = cdr(p2);
    }
    set_component(tos - h);
    p3 = pop();
    set_binding(p4, p3);
    return push(symbol(NIL));
  };

  Eval_setq = function() {
    if (caadr(p1) === symbol(INDEX)) {
      setq_indexed();
      return;
    }
    if (iscons(cadr(p1))) {
      define_user_function();
      return;
    }
    if (!issymbol(cadr(p1))) {
      stop("symbol assignment: error in symbol");
    }
    push(caddr(p1));
    Eval();
    p2 = pop();
    set_binding(cadr(p1), p2);
    return push(symbol(NIL));
  };

  Eval_sqrt = function() {
    push(cadr(p1));
    Eval();
    push_rational(1, 2);
    return power();
  };

  Eval_stop = function() {
    return stop("user stop");
  };

  Eval_subst = function() {
    push(cadddr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadr(p1));
    Eval();
    subst();
    return Eval();
  };

  Eval_unit = function() {
    var i, n, _i;
    i = 0;
    n = 0;
    push(cadr(p1));
    Eval();
    n = pop_integer();
    if (n < 2) {
      push(p1);
      return;
    }
    p1 = alloc_tensor(n * n);
    p1.tensor.ndim = 2;
    p1.tensor.dim[0] = n;
    p1.tensor.dim[1] = n;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      p1.tensor.elem[n * i + i] = one;
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    return push(p1);
  };

  Eval_noexpand = function() {
    var x;
    x = expanding;
    expanding = 0;
    Eval();
    return expanding = x;
  };

  Eval_predicate = function() {
    save();
    p1 = pop();
    if (car(p1) === symbol(SETQ)) {
      Eval_testeq();
    } else {
      push(p1);
      Eval();
    }
    return restore();
  };

  Eval_expand = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    return expand();
  };

  expand = function() {
    save();
    p9 = pop();
    p5 = pop();
    if (istensor(p5)) {
      expand_tensor();
      restore();
      return;
    }
    if (car(p5) === symbol(ADD)) {
      push_integer(0);
      p1 = cdr(p5);
      while (iscons(p1)) {
        push(car(p1));
        push(p9);
        expand();
        add();
        p1 = cdr(p1);
      }
      restore();
      return;
    }
    push(p5);
    numerator();
    p3 = pop();
    push(p5);
    denominator();
    p2 = pop();
    remove_negative_exponents();
    push(p3);
    push(p2);
    push(p9);
    divpoly();
    p7 = pop();
    push(p3);
    push(p2);
    push(p7);
    multiply();
    subtract();
    p3 = pop();
    if (iszero(p3)) {
      push(p7);
      restore();
      return;
    }
    push(p2);
    push(p9);
    factorpoly();
    p2 = pop();
    expand_get_C();
    expand_get_B();
    expand_get_A();
    if (istensor(p4)) {
      push(p4);
      inv();
      push(p3);
      inner();
      push(p2);
      inner();
    } else {
      push(p3);
      push(p4);
      divide();
      push(p2);
      multiply();
    }
    push(p7);
    add();
    return restore();
  };

  expand_tensor = function() {
    var i, _i, _ref;
    i = 0;
    push(p5);
    copy_tensor();
    p5 = pop();
    for (i = _i = 0, _ref = p5.tensor.nelem; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      push(p5.tensor.elem[i]);
      push(p9);
      expand();
      p5.tensor.elem[i] = pop();
    }
    return push(p5);
  };

  remove_negative_exponents = function() {
    var h, i, j, k, n, _i;
    h = 0;
    i = 0;
    j = 0;
    k = 0;
    n = 0;
    h = tos;
    factors(p2);
    factors(p3);
    n = tos - h;
    j = 0;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      p1 = stack[h + i];
      if (car(p1) !== symbol(POWER)) {
        continue;
      }
      if (cadr(p1) !== p9) {
        continue;
      }
      push(caddr(p1));
      k = pop_integer();
      if (k === 0x80000000) {
        continue;
      }
      if (k < j) {
        j = k;
      }
    }
    tos = h;
    if (j === 0) {
      return;
    }
    push(p2);
    push(p9);
    push_integer(-j);
    power();
    multiply();
    p2 = pop();
    push(p3);
    push(p9);
    push_integer(-j);
    power();
    multiply();
    return p3 = pop();
  };

  expand_get_C = function() {
    var a, h, i, j, n, _i, _j;
    h = 0;
    i = 0;
    j = 0;
    n = 0;
    h = tos;
    if (car(p2) === symbol(MULTIPLY)) {
      p1 = cdr(p2);
      while (iscons(p1)) {
        p5 = car(p1);
        expand_get_CF();
        p1 = cdr(p1);
      }
    } else {
      p5 = p2;
      expand_get_CF();
    }
    n = tos - h;
    if (n === 1) {
      p4 = pop();
      return;
    }
    p4 = alloc_tensor(n * n);
    p4.tensor.ndim = 2;
    p4.tensor.dim[0] = n;
    p4.tensor.dim[1] = n;
    a = h;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      for (j = _j = 0; 0 <= n ? _j < n : _j > n; j = 0 <= n ? ++_j : --_j) {
        push(stack[a + j]);
        push(p9);
        push_integer(i);
        power();
        divide();
        push(p9);
        filter();
        p4.tensor.elem[n * i + j] = pop();
      }
    }
    return tos -= n;
  };

  expand_get_CF = function() {
    var d, i, j, n, _i, _results;
    d = 0;
    i = 0;
    j = 0;
    n = 0;
    if (!Find(p5, p9)) {
      return;
    }
    trivial_divide();
    if (car(p5) === symbol(POWER)) {
      push(caddr(p5));
      n = pop_integer();
      p6 = cadr(p5);
    } else {
      n = 1;
      p6 = p5;
    }
    push(p6);
    push(p9);
    degree();
    d = pop_integer();
    _results = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (j = _j = 0; 0 <= d ? _j < d : _j > d; j = 0 <= d ? ++_j : --_j) {
          push(p8);
          push(p6);
          push_integer(i);
          power();
          multiply();
          push(p9);
          push_integer(j);
          power();
          _results1.push(multiply());
        }
        return _results1;
      })());
    }
    return _results;
  };

  trivial_divide = function() {
    var h;
    h = 0;
    if (car(p2) === symbol(MULTIPLY)) {
      h = tos;
      p0 = cdr(p2);
      while (iscons(p0)) {
        if (!equal(car(p0), p5)) {
          push(car(p0));
          Eval();
        }
        p0 = cdr(p0);
      }
      multiply_all(tos - h);
    } else {
      push_integer(1);
    }
    return p8 = pop();
  };

  expand_get_B = function() {
    var i, n, _i;
    i = 0;
    n = 0;
    if (!istensor(p4)) {
      return;
    }
    n = p4.tensor.dim[0];
    p8 = alloc_tensor(n);
    p8.tensor.ndim = 1;
    p8.tensor.dim[0] = n;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      push(p3);
      push(p9);
      push_integer(i);
      power();
      divide();
      push(p9);
      filter();
      p8.tensor.elem[i] = pop();
    }
    return p3 = p8;
  };

  expand_get_A = function() {
    var h, i, n, _i;
    h = 0;
    i = 0;
    n = 0;
    if (!istensor(p4)) {
      push(p2);
      reciprocate();
      p2 = pop();
      return;
    }
    h = tos;
    if (car(p2) === symbol(MULTIPLY)) {
      p8 = cdr(p2);
      while (iscons(p8)) {
        p5 = car(p8);
        expand_get_AF();
        p8 = cdr(p8);
      }
    } else {
      p5 = p2;
      expand_get_AF();
    }
    n = tos - h;
    p8 = alloc_tensor(n);
    p8.tensor.ndim = 1;
    p8.tensor.dim[0] = n;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      p8.tensor.elem[i] = stack[h + i];
    }
    tos = h;
    return p2 = p8;
  };

  expand_get_AF = function() {
    var d, i, j, n, _i, _results;
    d = 0;
    i = 0;
    j = 0;
    n = 1;
    if (!Find(p5, p9)) {
      return;
    }
    if (car(p5) === symbol(POWER)) {
      push(caddr(p5));
      n = pop_integer();
      p5 = cadr(p5);
    }
    push(p5);
    push(p9);
    degree();
    d = pop_integer();
    _results = [];
    for (i = _i = n; n <= 0 ? _i < 0 : _i > 0; i = n <= 0 ? ++_i : --_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (j = _j = 0; 0 <= d ? _j < d : _j > d; j = 0 <= d ? ++_j : --_j) {
          push(p5);
          push_integer(i);
          power();
          reciprocate();
          push(p9);
          push_integer(j);
          power();
          _results1.push(multiply());
        }
        return _results1;
      })());
    }
    return _results;
  };

  Eval_expcos = function() {
    push(cadr(p1));
    Eval();
    return expcos();
  };

  expcos = function() {
    save();
    p1 = pop();
    push(imaginaryunit);
    push(p1);
    multiply();
    exponential();
    push_rational(1, 2);
    multiply();
    push(imaginaryunit);
    negate();
    push(p1);
    multiply();
    exponential();
    push_rational(1, 2);
    multiply();
    add();
    return restore();
  };

  Eval_expsin = function() {
    push(cadr(p1));
    Eval();
    return expsin();
  };

  expsin = function() {
    save();
    p1 = pop();
    push(imaginaryunit);
    push(p1);
    multiply();
    exponential();
    push(imaginaryunit);
    divide();
    push_rational(1, 2);
    multiply();
    push(imaginaryunit);
    negate();
    push(p1);
    multiply();
    exponential();
    push(imaginaryunit);
    divide();
    push_rational(1, 2);
    multiply();
    subtract();
    return restore();
  };

  Eval_factor = function() {
    var _results;
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    factor();
    p1 = cdddr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      factor_again();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  factor_again = function() {
    var h, n;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        factor_term();
        p1 = cdr(p1);
      }
    } else {
      push(p1);
      push(p2);
      factor_term();
    }
    n = tos - h;
    if (n > 1) {
      multiply_all_noexpand(n);
    }
    return restore();
  };

  factor_term = function() {
    save();
    factorpoly();
    p1 = pop();
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        p1 = cdr(p1);
      }
    } else {
      push(p1);
    }
    return restore();
  };

  factor = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (isinteger(p1)) {
      push(p1);
      factor_number();
    } else {
      push(p1);
      push(p2);
      factorpoly();
    }
    return restore();
  };

  factor_small_number = function() {
    var d, expo, i, n, _i;
    i = 0;
    save();
    n = pop_integer();
    if (n === 0x80000000) {
      stop("number too big to factor");
    }
    if (n < 0) {
      n = -n;
    }
    for (i = _i = 0; 0 <= MAXPRIMETAB ? _i < MAXPRIMETAB : _i > MAXPRIMETAB; i = 0 <= MAXPRIMETAB ? ++_i : --_i) {
      d = primetab[i];
      if (d > n / d) {
        break;
      }
      expo = 0;
      while (n % d === 0) {
        n /= d;
        expo++;
      }
      if (expo) {
        push_integer(d);
        push_integer(expo);
      }
    }
    if (n > 1) {
      push_integer(n);
      push_integer(1);
    }
    return restore();
  };

  factorial = function() {
    var n;
    n = 0;
    save();
    p1 = pop();
    push(p1);
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push_symbol(FACTORIAL);
      push(p1);
      list(2);
      restore();
      return;
    }
    bignum_factorial(n);
    return restore();
  };

  simplifyfactorials = function() {
    var x;
    x = 0;
    save();
    x = expanding;
    expanding = 0;
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      push(zero);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        simplifyfactorials();
        add();
        p1 = cdr(p1);
      }
      expanding = x;
      restore();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      sfac_product();
      expanding = x;
      restore();
      return;
    }
    push(p1);
    expanding = x;
    return restore();
  };

  sfac_product = function() {
    var i, j, n, s, _i, _j, _k, _ref, _ref1;
    i = 0;
    j = 0;
    n = 0;
    s = tos;
    p1 = cdr(p1);
    n = 0;
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
      n++;
    }
    for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (stack[s + i] === symbol(NIL)) {
        continue;
      }
      for (j = _j = _ref1 = i + 1; _ref1 <= n ? _j < n : _j > n; j = _ref1 <= n ? ++_j : --_j) {
        if (stack[s + j] === symbol(NIL)) {
          continue;
        }
        sfac_product_f(s, i, j);
      }
    }
    push(one);
    for (i = _k = 0; 0 <= n ? _k < n : _k > n; i = 0 <= n ? ++_k : --_k) {
      if (stack[s + i] === symbol(NIL)) {
        continue;
      }
      push(stack[s + i]);
      multiply();
    }
    p1 = pop();
    tos -= n;
    return push(p1);
  };

  sfac_product_f = function(s, a, b) {
    var i, n, _i;
    i = 0;
    n = 0;
    p1 = stack[s + a];
    p2 = stack[s + b];
    if (ispower(p1)) {
      p3 = caddr(p1);
      p1 = cadr(p1);
    } else {
      p3 = one;
    }
    if (ispower(p2)) {
      p4 = caddr(p2);
      p2 = cadr(p2);
    } else {
      p4 = one;
    }
    if (isfactorial(p1) && isfactorial(p2)) {
      push(p3);
      push(p4);
      add();
      yyexpand();
      n = pop_integer();
      if (n !== 0) {
        return;
      }
      push(cadr(p1));
      push(cadr(p2));
      subtract();
      yyexpand();
      n = pop_integer();
      if (n === 0 || n === 0x80000000) {
        return;
      }
      if (n < 0) {
        n = -n;
        p5 = p1;
        p1 = p2;
        p2 = p5;
        p5 = p3;
        p3 = p4;
        p4 = p5;
      }
      push(one);
      for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
        push(cadr(p2));
        push_integer(i);
        add();
        push(p3);
        power();
        multiply();
      }
      stack[s + a] = pop();
      return stack[s + b] = symbol(NIL);
    }
  };

  polycoeff = 0;

  factpoly_expo = 0;

  factorpoly = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (!Find(p1, p2)) {
      push(p1);
      restore();
      return;
    }
    if (!ispoly(p1, p2)) {
      push(p1);
      restore();
      return;
    }
    if (!issymbol(p2)) {
      push(p1);
      restore();
      return;
    }
    push(p1);
    push(p2);
    yyfactorpoly();
    return restore();
  };

  yyfactorpoly = function() {
    var h, i, _i;
    h = 0;
    i = 0;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    if (isfloating(p1)) {
      stop("floating point numbers in polynomial");
    }
    polycoeff = tos;
    push(p1);
    push(p2);
    factpoly_expo = coeff() - 1;
    rationalize_coefficients(h);
    while (factpoly_expo > 0) {
      if (iszero(stack[polycoeff + 0])) {
        push_integer(1);
        p4 = pop();
        push_integer(0);
        p5 = pop();
      } else if (get_factor() === 0) {
        if (verbosing) {
          printf("no factor found\n");
        }
        break;
      }
      push(p4);
      push(p2);
      multiply();
      push(p5);
      add();
      p8 = pop();
      if (verbosing) {
        printf("success\nFACTOR=");
        print(p8);
        printf("\n");
      }

      /*
      		if (isnegativeterm(p4))
      			push(p8)
      			negate()
      			p8 = pop()
      			push(p7)
      			negate_noexpand()
      			p7 = pop()
       */
      push(p7);
      push(p8);
      multiply_noexpand();
      p7 = pop();
      yydivpoly();
      while (factpoly_expo && iszero(stack[polycoeff + factpoly_expo])) {
        factpoly_expo--;
      }
    }
    push(zero);
    for (i = _i = 0; 0 <= factpoly_expo ? _i <= factpoly_expo : _i >= factpoly_expo; i = 0 <= factpoly_expo ? ++_i : --_i) {
      push(stack[polycoeff + i]);
      push(p2);
      push_integer(i);
      power();
      multiply();
      add();
    }
    p1 = pop();
    if (verbosing) {
      printf("POLY=");
      print(p1);
      printf("\n");
    }
    if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {
      push(p1);
      negate();
      p1 = pop();
      push(p7);
      negate_noexpand();
      p7 = pop();
    }
    push(p7);
    push(p1);
    multiply_noexpand();
    p7 = pop();
    if (verbosing) {
      printf("RESULT=");
      print(p7);
      printf("\n");
    }
    stack[h] = p7;
    tos = h + 1;
    return restore();
  };

  rationalize_coefficients = function(h) {
    var i, _i, _j;
    i = 0;
    p7 = one;
    for (i = _i = h; h <= tos ? _i < tos : _i > tos; i = h <= tos ? ++_i : --_i) {
      push(stack[i]);
      denominator();
      push(p7);
      lcm();
      p7 = pop();
    }
    for (i = _j = h; h <= tos ? _j < tos : _j > tos; i = h <= tos ? ++_j : --_j) {
      push(p7);
      push(stack[i]);
      multiply();
      stack[i] = pop();
    }
    push(p7);
    reciprocate();
    p7 = pop();
    if (DEBUG) {
      return console.log("rationalize_coefficients result");
    }
  };

  get_factor = function() {
    var a0, an, h, i, j, na0, nan, rootsTries_i, rootsTries_j, _i, _j, _k, _l, _m;
    i = 0;
    j = 0;
    h = 0;
    a0 = 0;
    an = 0;
    na0 = 0;
    nan = 0;
    if (verbosing) {
      push(zero);
      for (i = _i = 0; 0 <= factpoly_expo ? _i <= factpoly_expo : _i >= factpoly_expo; i = 0 <= factpoly_expo ? ++_i : --_i) {
        push(stack[polycoeff + i]);
        push(p2);
        push_integer(i);
        power();
        multiply();
        add();
      }
      p1 = pop();
      printf("POLY=");
      print(p1);
      printf("\n");
    }
    h = tos;
    an = tos;
    push(stack[polycoeff + factpoly_expo]);
    divisors_onstack();
    nan = tos - an;
    a0 = tos;
    push(stack[polycoeff + 0]);
    divisors_onstack();
    na0 = tos - a0;
    if (verbosing) {
      printf("divisors of base term");
      for (i = _j = 0; 0 <= na0 ? _j < na0 : _j > na0; i = 0 <= na0 ? ++_j : --_j) {
        printf(", ");
        print(stack[a0 + i]);
      }
      printf("\n");
      printf("divisors of leading term");
      for (i = _k = 0; 0 <= nan ? _k < nan : _k > nan; i = 0 <= nan ? ++_k : --_k) {
        printf(", ");
        print(stack[an + i]);
      }
      printf("\n");
    }
    for (rootsTries_i = _l = 0; 0 <= nan ? _l < nan : _l > nan; rootsTries_i = 0 <= nan ? ++_l : --_l) {
      for (rootsTries_j = _m = 0; 0 <= na0 ? _m < na0 : _m > na0; rootsTries_j = 0 <= na0 ? ++_m : --_m) {
        p4 = stack[an + rootsTries_i];
        p5 = stack[a0 + rootsTries_j];
        push(p5);
        push(p4);
        divide();
        negate();
        p3 = pop();
        Evalpoly();
        if (verbosing) {
          printf("try A=");
          print(p4);
          printf(", B=");
          print(p5);
          printf(", root ");
          print(p2);
          printf("=-B/A=");
          print(p3);
          printf(", POLY(");
          print(p3);
          printf(")=");
          print(p6);
          printf("\n");
        }
        if (iszero(p6)) {
          tos = h;
          if (DEBUG) {
            console.log("get_factor returning 1");
          }
          return 1;
        }
        push(p5);
        negate();
        p5 = pop();
        push(p3);
        negate();
        p3 = pop();
        Evalpoly();
        if (verbosing) {
          printf("try A=");
          print(p4);
          printf(", B=");
          print(p5);
          printf(", root ");
          print(p2);
          printf("=-B/A=");
          print(p3);
          printf(", POLY(");
          print(p3);
          printf(")=");
          print(p6);
          printf("\n");
        }
        if (iszero(p6)) {
          tos = h;
          if (DEBUG) {
            console.log("get_factor returning 1");
          }
          return 1;
        }
      }
    }
    tos = h;
    if (DEBUG) {
      console.log("get_factor returning 0");
    }
    return 0;
  };

  yydivpoly = function() {
    var i, _i;
    i = 0;
    p6 = zero;
    for (i = _i = factpoly_expo; factpoly_expo <= 0 ? _i < 0 : _i > 0; i = factpoly_expo <= 0 ? ++_i : --_i) {
      push(stack[polycoeff + i]);
      stack[polycoeff + i] = p6;
      push(p4);
      divide();
      p6 = pop();
      push(stack[polycoeff + i - 1]);
      push(p6);
      push(p5);
      multiply();
      subtract();
      stack[polycoeff + i - 1] = pop();
    }
    stack[polycoeff + 0] = p6;
    if (DEBUG) {
      return console.log("yydivpoly Q:");
    }
  };

  Evalpoly = function() {
    var i, _i;
    i = 0;
    push(zero);
    for (i = _i = factpoly_expo; factpoly_expo <= 0 ? _i <= 0 : _i >= 0; i = factpoly_expo <= 0 ? ++_i : --_i) {
      push(p3);
      multiply();
      push(stack[polycoeff + i]);
      if (DEBUG) {
        console.log("Evalpoly top of stack:");
        print1(stack[tos - i]);
      }
      add();
    }
    return p6 = pop();
  };

  factors = function(p) {
    var h;
    h = tos;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      while (iscons(p)) {
        push_term_factors(car(p));
        p = cdr(p);
      }
    } else {
      push_term_factors(p);
    }
    return tos - h;
  };

  push_term_factors = function(p) {
    var _results;
    if (car(p) === symbol(MULTIPLY)) {
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        push(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    } else {
      return push(p);
    }
  };


  /*
  Remove terms that involve a given symbol or expression. For example...
  
  	filter(x^2 + x + 1, x)		=>	1
  
  	filter(x^2 + x + 1, x^2)	=>	x + 1
   */

  Eval_filter = function() {
    var _results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      filter();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };


  /*
   For example...
  
  	push(F)
  	push(X)
  	filter()
  	F = pop()
   */

  filter = function() {
    save();
    p2 = pop();
    p1 = pop();
    filter_main();
    return restore();
  };

  filter_main = function() {
    if (car(p1) === symbol(ADD)) {
      return filter_sum();
    } else if (istensor(p1)) {
      return filter_tensor();
    } else if (Find(p1, p2)) {
      return push_integer(0);
    } else {
      return push(p1);
    }
  };

  filter_sum = function() {
    var _results;
    push_integer(0);
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      filter();
      add();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  filter_tensor = function() {
    var i, n, _i, _j, _ref;
    i = 0;
    n = 0;
    n = p1.tensor.nelem;
    p3 = alloc_tensor(n);
    p3.tensor.ndim = p1.tensor.ndim;
    for (i = _i = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
      push(p1.tensor.elem[i]);
      push(p2);
      filter();
      p3.tensor.elem[i] = pop();
    }
    return push(p3);
  };

  Eval_float = function() {
    push(cadr(p1));
    Eval();
    yyfloat();
    return Eval();
  };

  yyfloat = function() {
    var h, i, _i, _ref;
    i = 0;
    h = 0;
    save();
    p1 = pop();
    if (iscons(p1)) {
      h = tos;
      while (iscons(p1)) {
        push(car(p1));
        yyfloat();
        p1 = cdr(p1);
      }
      list(tos - h);
    } else if (p1.k === TENSOR) {
      push(p1);
      copy_tensor();
      p1 = pop();
      for (i = _i = 0, _ref = p1.tensor.nelem; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        push(p1.tensor.elem[i]);
        yyfloat();
        p1.tensor.elem[i] = pop();
      }
      push(p1);
    } else if (p1.k === NUM) {
      push(p1);
      bignum_float();
    } else if (p1 === symbol(PI)) {
      push_double(Math.PI);
    } else if (p1 === symbol(E)) {
      push_double(Math.E);
    } else {
      push(p1);
    }
    return restore();
  };

  Eval_floor = function() {
    push(cadr(p1));
    Eval();
    return yfloor();
  };

  yfloor = function() {
    save();
    yyfloor();
    return restore();
  };

  yyfloor = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (!isnum(p1)) {
      push_symbol(FLOOR);
      push(p1);
      list(2);
      return;
    }
    if (isdouble(p1)) {
      d = Math.floor(p1.d);
      push_double(d);
      return;
    }
    if (isinteger(p1)) {
      push(p1);
      return;
    }
    p3 = new U();
    p3.k = NUM;
    p3.q.a = mdiv(p1.q.a, p1.q.b);
    p3.q.b = mint(1);
    push(p3);
    if (isnegativenumber(p1)) {
      push_integer(-1);
      return add();
    }
  };

  Eval_for = function() {
    var i, j, k, _i;
    i = 0;
    j = 0;
    k = 0;
    p6 = cadr(p1);
    if (!issymbol(p6)) {
      stop("for: 1st arg?");
    }
    push(caddr(p1));
    Eval();
    j = pop_integer();
    if (j === 0x80000000) {
      stop("for: 2nd arg?");
    }
    push(cadddr(p1));
    Eval();
    k = pop_integer();
    if (k === 0x80000000) {
      stop("for: 3rd arg?");
    }
    p1 = cddddr(p1);
    p4 = get_binding(p6);
    p3 = get_arglist(p6);
    for (i = _i = j; j <= k ? _i <= k : _i >= k; i = j <= k ? ++_i : --_i) {
      push_integer(i);
      p5 = pop();
      set_binding(p6, p5);
      p2 = p1;
      while (iscons(p2)) {
        push(car(p2));
        Eval();
        pop();
        p2 = cdr(p2);
      }
    }
    set_binding_and_arglist(p6, p4, p3);
    return push_symbol(NIL);
  };

  Eval_gamma = function() {
    push(cadr(p1));
    Eval();
    return gamma();
  };

  gamma = function() {
    save();
    gammaf();
    return restore();
  };

  gammaf = function() {
    p1 = pop();
    if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {
      push_symbol(PI);
      push_rational(1, 2);
      power();
      return;
    }
    if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {
      push_symbol(PI);
      push_rational(1, 2);
      power();
      push_rational(1, 2);
      multiply();
      return;
    }
    if (isnegativeterm(p1)) {
      push_symbol(PI);
      push_integer(-1);
      multiply();
      push_symbol(PI);
      push(p1);
      multiply();
      sine();
      push(p1);
      multiply();
      push(p1);
      negate();
      gamma();
      multiply();
      divide();
      return;
    }
    if (car(p1) === symbol(ADD)) {
      gamma_of_sum();
      return;
    }
    push_symbol(GAMMA);
    push(p1);
    list(2);
  };

  gamma_of_sum = function() {
    p3 = cdr(p1);
    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {
      push(cadr(p3));
      push(cadr(p3));
      gamma();
      return multiply();
    } else {
      if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {
        push(cadr(p3));
        gamma();
        push(cadr(p3));
        push_integer(-1);
        add();
        return divide();
      } else {
        push_symbol(GAMMA);
        push(p1);
        list(2);
      }
    }
  };

  Eval_gcd = function() {
    var _results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      gcd();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  gcd = function() {
    var x;
    x = expanding;
    save();
    gcd_main();
    restore();
    return expanding = x;
  };

  gcd_main = function() {
    expanding = 1;
    p2 = pop();
    p1 = pop();
    if (equal(p1, p2)) {
      push(p1);
      return;
    }
    if (isrational(p1) && isrational(p2)) {
      push(p1);
      push(p2);
      gcd_numbers();
      return;
    }
    if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {
      gcd_expr_expr();
      return;
    }
    if (car(p1) === symbol(ADD)) {
      gcd_expr(p1);
      p1 = pop();
    }
    if (car(p2) === symbol(ADD)) {
      gcd_expr(p2);
      p2 = pop();
    }
    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {
      gcd_term_term();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      gcd_term_factor();
      return;
    }
    if (car(p2) === symbol(MULTIPLY)) {
      gcd_factor_term();
      return;
    }
    if (car(p1) === symbol(POWER)) {
      p3 = caddr(p1);
      p1 = cadr(p1);
    } else {
      p3 = one;
    }
    if (car(p2) === symbol(POWER)) {
      p4 = caddr(p2);
      p2 = cadr(p2);
    } else {
      p4 = one;
    }
    if (!equal(p1, p2)) {
      push(one);
      return;
    }
    if (isnum(p3) && isnum(p4)) {
      push(p1);
      if (lessp(p3, p4)) {
        push(p3);
      } else {
        push(p4);
      }
      power();
      return;
    }
    push(p3);
    push(p4);
    divide();
    p5 = pop();
    if (isnum(p5)) {
      push(p1);
      if (car(p3) === symbol(MULTIPLY) && isnum(cadr(p3))) {
        p5 = cadr(p3);
      } else {
        p5 = one;
      }
      if (car(p4) === symbol(MULTIPLY) && isnum(cadr(p4))) {
        p6 = cadr(p4);
      } else {
        p6 = one;
      }
      if (lessp(p5, p6)) {
        push(p3);
      } else {
        push(p4);
      }
      power();
      return;
    }
    push(p3);
    push(p4);
    subtract();
    p5 = pop();
    if (!isnum(p5)) {
      push(one);
      return;
    }
    push(p1);
    if (isnegativenumber(p5)) {
      push(p3);
    } else {
      push(p4);
    }
    return power();
  };

  gcd_expr_expr = function() {
    if (length(p1) !== length(p2)) {
      push(one);
      return;
    }
    p3 = cdr(p1);
    push(car(p3));
    p3 = cdr(p3);
    while (iscons(p3)) {
      push(car(p3));
      gcd();
      p3 = cdr(p3);
    }
    p3 = pop();
    p4 = cdr(p2);
    push(car(p4));
    p4 = cdr(p4);
    while (iscons(p4)) {
      push(car(p4));
      gcd();
      p4 = cdr(p4);
    }
    p4 = pop();
    push(p1);
    push(p3);
    divide();
    p5 = pop();
    push(p2);
    push(p4);
    divide();
    p6 = pop();
    if (equal(p5, p6)) {
      push(p5);
      push(p3);
      push(p4);
      gcd();
      return multiply();
    } else {
      return push(one);
    }
  };

  gcd_expr = function(p) {
    var _results;
    p = cdr(p);
    push(car(p));
    p = cdr(p);
    _results = [];
    while (iscons(p)) {
      push(car(p));
      gcd();
      _results.push(p = cdr(p));
    }
    return _results;
  };

  gcd_term_term = function() {
    var _results;
    push(one);
    p3 = cdr(p1);
    _results = [];
    while (iscons(p3)) {
      p4 = cdr(p2);
      while (iscons(p4)) {
        push(car(p3));
        push(car(p4));
        gcd();
        multiply();
        p4 = cdr(p4);
      }
      _results.push(p3 = cdr(p3));
    }
    return _results;
  };

  gcd_term_factor = function() {
    var _results;
    push(one);
    p3 = cdr(p1);
    _results = [];
    while (iscons(p3)) {
      push(car(p3));
      push(p2);
      gcd();
      multiply();
      _results.push(p3 = cdr(p3));
    }
    return _results;
  };

  gcd_factor_term = function() {
    var _results;
    push(one);
    p4 = cdr(p2);
    _results = [];
    while (iscons(p4)) {
      push(p1);
      push(car(p4));
      gcd();
      multiply();
      _results.push(p4 = cdr(p4));
    }
    return _results;
  };

  guess = function() {
    var p;
    p = pop();
    push(p);
    if (Find(p, symbol(SYMBOL_X))) {
      return push_symbol(SYMBOL_X);
    } else if (Find(p, symbol(SYMBOL_Y))) {
      return push_symbol(SYMBOL_Y);
    } else if (Find(p, symbol(SYMBOL_Z))) {
      return push_symbol(SYMBOL_Z);
    } else if (Find(p, symbol(SYMBOL_T))) {
      return push_symbol(SYMBOL_T);
    } else if (Find(p, symbol(SYMBOL_S))) {
      return push_symbol(SYMBOL_S);
    } else {
      return push_symbol(SYMBOL_X);
    }
  };

  hermite = function() {
    save();
    yyhermite();
    return restore();
  };

  yyhermite = function() {
    var n;
    n = 0;
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push_symbol(HERMITE);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    if (issymbol(p1)) {
      return yyhermite2(n);
    } else {
      p3 = p1;
      p1 = symbol(SECRETX);
      yyhermite2(n);
      p1 = p3;
      push(symbol(SECRETX));
      push(p1);
      subst();
      return Eval();
    }
  };

  yyhermite2 = function(n) {
    var i, _i, _results;
    i = 0;
    push_integer(1);
    push_integer(0);
    p4 = pop();
    _results = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      p5 = p4;
      p4 = pop();
      push(p1);
      push(p4);
      multiply();
      push_integer(i);
      push(p5);
      multiply();
      subtract();
      push_integer(2);
      _results.push(multiply());
    }
    return _results;
  };

  hilbert = function() {
    var i, j, n, _i, _j;
    i = 0;
    j = 0;
    n = 0;
    save();
    p2 = pop();
    push(p2);
    n = pop_integer();
    if (n < 2) {
      push_symbol(HILBERT);
      push(p2);
      list(2);
      restore();
      return;
    }
    push_zero_matrix(n, n);
    p1 = pop();
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      for (j = _j = 0; 0 <= n ? _j < n : _j > n; j = 0 <= n ? ++_j : --_j) {
        push_integer(i + j + 1);
        inverse();
        p1.tensor.elem[i * n + j] = pop();
      }
    }
    push(p1);
    return restore();
  };


  /*
   Returns the coefficient of the imaginary part of complex z
  
  	z		imag(z)
  	-		-------
  
  	a + i b		b
  
  	exp(i a)	sin(a)
   */

  Eval_imag = function() {
    push(cadr(p1));
    Eval();
    return imag();
  };

  imag = function() {
    save();
    rect();
    p1 = pop();
    push(p1);
    push(p1);
    conjugate();
    subtract();
    push_integer(2);
    divide();
    push(imaginaryunit);
    divide();
    return restore();
  };

  index_function = function(n) {
    var i, k, m, ndim, nelem, s, t, _i, _j, _k, _l, _m;
    i = 0;
    k = 0;
    m = 0;
    ndim = 0;
    nelem = 0;
    t = 0;
    save();
    s = tos - n;
    p1 = stack[s];
    if (!istensor(p1)) {
      tos -= n;
      push(p1);
      restore();
      return;
    }
    ndim = p1.tensor.ndim;
    m = n - 1;
    if (m > ndim) {
      stop("too many indices for tensor");
    }
    k = 0;
    for (i = _i = 0; 0 <= m ? _i < m : _i > m; i = 0 <= m ? ++_i : --_i) {
      push(stack[s + i + 1]);
      t = pop_integer();
      if (t < 1 || t > p1.tensor.dim[i]) {
        stop("index out of range");
      }
      k = k * p1.tensor.dim[i] + t - 1;
    }
    if (ndim === m) {
      tos -= n;
      push(p1.tensor.elem[k]);
      restore();
      return;
    }
    for (i = _j = m; m <= ndim ? _j < ndim : _j > ndim; i = m <= ndim ? ++_j : --_j) {
      k = k * p1.tensor.dim[i] + 0;
    }
    nelem = 1;
    for (i = _k = m; m <= ndim ? _k < ndim : _k > ndim; i = m <= ndim ? ++_k : --_k) {
      nelem *= p1.tensor.dim[i];
    }
    p2 = alloc_tensor(nelem);
    p2.tensor.ndim = ndim - m;
    for (i = _l = m; m <= ndim ? _l < ndim : _l > ndim; i = m <= ndim ? ++_l : --_l) {
      p2.tensor.dim[i - m] = p1.tensor.dim[i];
    }
    for (i = _m = 0; 0 <= nelem ? _m < nelem : _m > nelem; i = 0 <= nelem ? ++_m : --_m) {
      p2.tensor.elem[i] = p1.tensor.elem[k + i];
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    tos -= n;
    push(p2);
    return restore();
  };

  set_component = function(n) {
    var i, k, m, ndim, s, t, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3;
    i = 0;
    k = 0;
    m = 0;
    ndim = 0;
    t = 0;
    save();
    if (n < 3) {
      stop("error in indexed assign");
    }
    s = tos - n;
    p2 = stack[s];
    p1 = stack[s + 1];
    if (!istensor(p1)) {
      stop("error in indexed assign");
    }
    ndim = p1.tensor.ndim;
    m = n - 2;
    if (m > ndim) {
      stop("error in indexed assign");
    }
    k = 0;
    for (i = _i = 0; 0 <= m ? _i < m : _i > m; i = 0 <= m ? ++_i : --_i) {
      push(stack[s + i + 2]);
      t = pop_integer();
      if (t < 1 || t > p1.tensor.dim[i]) {
        stop("error in indexed assign\n");
      }
      k = k * p1.tensor.dim[i] + t - 1;
    }
    for (i = _j = m; m <= ndim ? _j < ndim : _j > ndim; i = m <= ndim ? ++_j : --_j) {
      k = k * p1.tensor.dim[i] + 0;
    }
    p3 = alloc_tensor(p1.tensor.nelem);
    p3.tensor.ndim = p1.tensor.ndim;
    for (i = _k = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = _l = 0, _ref1 = p1.tensor.nelem; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
      p3.tensor.elem[i] = p1.tensor.elem[i];
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p3.tensor.nelem !== p3.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    p1 = p3;
    if (ndim === m) {
      if (istensor(p2)) {
        stop("error in indexed assign");
      }
      p1.tensor.elem[k] = p2;
      if (p1.tensor.nelem !== p1.tensor.elem.length) {
        console.log("something wrong in tensor dimensions");
        debugger;
      }
      tos -= n;
      push(p1);
      restore();
      return;
    }
    if (!istensor(p2)) {
      stop("error in indexed assign");
    }
    if (ndim - m !== p2.tensor.ndim) {
      stop("error in indexed assign");
    }
    for (i = _m = 0, _ref2 = p2.tensor.ndim; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; i = 0 <= _ref2 ? ++_m : --_m) {
      if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {
        stop("error in indexed assign");
      }
    }
    for (i = _n = 0, _ref3 = p2.tensor.nelem; 0 <= _ref3 ? _n < _ref3 : _n > _ref3; i = 0 <= _ref3 ? ++_n : --_n) {
      p1.tensor.elem[k + i] = p2.tensor.elem[i];
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    tos -= n;
    push(p1);
    return restore();
  };

  Eval_inner = function() {
    var _results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      inner();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  inner = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (istensor(p1) && istensor(p2)) {
      inner_f();
    } else {
      push(p1);
      push(p2);
      if (istensor(p1)) {
        tensor_times_scalar();
      } else if (istensor(p2)) {
        scalar_times_tensor();
      } else {
        multiply();
      }
    }
    return restore();
  };

  inner_f = function() {
    var a, ak, b, bk, c, i, j, k, n, ndim, _i, _j, _k, _l, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
    i = 0;
    n = p1.tensor.dim[p1.tensor.ndim - 1];
    if (n !== p2.tensor.dim[0]) {
      debugger;
      stop("inner: tensor dimension check");
    }
    ndim = p1.tensor.ndim + p2.tensor.ndim - 2;
    if (ndim > MAXDIM) {
      stop("inner: rank of result exceeds maximum");
    }
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    ak = 1;
    for (i = _i = 0, _ref = p1.tensor.ndim - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ak *= p1.tensor.dim[i];
    }
    bk = 1;
    for (i = _j = 1, _ref1 = p2.tensor.ndim; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
      bk *= p2.tensor.dim[i];
    }
    p3 = alloc_tensor(ak * bk);
    c = p3.tensor.elem;
    for (i = _k = 0; 0 <= ak ? _k < ak : _k > ak; i = 0 <= ak ? ++_k : --_k) {
      for (j = _l = 0; 0 <= n ? _l < n : _l > n; j = 0 <= n ? ++_l : --_l) {
        if (iszero(a[i * n + j])) {
          continue;
        }
        for (k = _m = 0; 0 <= bk ? _m < bk : _m > bk; k = 0 <= bk ? ++_m : --_m) {
          push(a[i * n + j]);
          push(b[j * bk + k]);
          multiply();
          push(c[i * bk + k]);
          add();
          c[i * bk + k] = pop();
        }
      }
    }
    if (ndim === 0) {
      return push(p3.tensor.elem[0]);
    } else {
      p3.tensor.ndim = ndim;
      j = 0;
      for (i = _n = 0, _ref2 = p1.tensor.ndim - 1; 0 <= _ref2 ? _n < _ref2 : _n > _ref2; i = 0 <= _ref2 ? ++_n : --_n) {
        p3.tensor.dim[i] = p1.tensor.dim[i];
      }
      j = p1.tensor.ndim - 1;
      for (i = _o = 0, _ref3 = p2.tensor.ndim - 1; 0 <= _ref3 ? _o < _ref3 : _o > _ref3; i = 0 <= _ref3 ? ++_o : --_o) {
        p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];
      }
      return push(p3);
    }
  };


  /*
   Table of integrals
  
  The symbol f is just a dummy symbol for creating a list f(A,B,C,C,...) where
  
  	A	is the template expression
  
  	B	is the result expression
  
  	C	is an optional list of conditional expressions
   */

  itab = ["f(a,a*x)", "f(1/x,log(x))", "f(x^a,x^(a+1)/(a+1))", "f(exp(a*x),1/a*exp(a*x))", "f(exp(a*x+b),1/a*exp(a*x+b))", "f(x*exp(a*x^2),exp(a*x^2)/(2*a))", "f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))", "f(log(a*x),x*log(a*x)-x)", "f(a^x,a^x/log(a),or(not(number(a)),a>0))", "f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))", "f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))", "f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))", "f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))", "f(1/(a+b*x),1/b*log(a+b*x))", "f(1/(a+b*x)^2,-1/(b*(a+b*x)))", "f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)", "f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)", "f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))", "f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))", "f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))", "f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))", "f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))", "f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))", "f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))", "f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))", "f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))", "f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))", "f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))", "f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))", "f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))", "f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))", "f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))", "f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))", "f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))", "f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))", "f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))", "f(1/(a+b*x^4),1/2*1/a*(a/b/4)^(1/4)*(1/2*log((x^2+2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2))/(x^2-2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2)))+arctan(2*(a/b/4)^(1/4)*x/(2*(a/b/4)^(1/2)-x^2))),or(not(number(a*b)),a*b>0))", "f(1/(a+b*x^4),1/2*(-a/b)^(1/4)/a*(1/2*log((x+(-a/b)^(1/4))/(x-(-a/b)^(1/4)))+arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))", "f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))", "f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))", "f(x^2/(a+b*x^4),1/4*1/b*(a/b/4)^(-1/4)*(1/2*log((x^2-2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4))/(x^2+2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4)))+arctan(2*(a/b/4)^(1/4)*x/(2*sqrt(a/b/4)-x^2))),or(not(number(a*b)),a*b>0))", "f(x^2/(a+b*x^4),1/4*1/b*(-a/b)^(-1/4)*(log((x-(-a/b)^(1/4))/(x+(-a/b)^(1/4)))+2*arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))", "f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))", "f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))", "f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)", "f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)", "f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))", "f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))", "f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)", "f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)", "f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)", "f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))", "f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))", "f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))", "f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))", "f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))", "f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))", "f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))", "f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))", "f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))", "f(x/sqrt(x^2+a),sqrt(x^2+a))", "f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))", "f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))", "f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))", "f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))", "f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))", "f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))", "f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))", "f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))", "f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))", "f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))", "f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))", "f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)", "f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))", "f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))", "f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))", "f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))", "f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))", "f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))", "f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))", "f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))", "f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))", "f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))", "f(x/sqrt(a-x^2),-sqrt(a-x^2))", "f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))", "f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))", "f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))", "f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))", "f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))", "f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))", "f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))", "f(sin(a*x),-cos(a*x)/a)", "f(cos(a*x),sin(a*x)/a)", "f(tan(a*x),-log(cos(a*x))/a)", "f(1/tan(a*x),log(sin(a*x))/a)", "f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)", "f(1/sin(a*x),log(tan(a*x/2))/a)", "f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))", "f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))", "f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))", "f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))", "f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))", "f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))", "f(1/sin(a*x)^2,-1/(a*tan(a*x)))", "f(1/cos(a*x)^2,tan(a*x)/a)", "f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))", "f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)", "f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))", "f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)", "f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))", "f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)", "f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)", "f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)", "f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))", "f(sin(a+b*x),-cos(a+b*x)/b)", "f(cos(a+b*x),sin(a+b*x)/b)", "f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)", "f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)", "f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)", "f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)", "f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)", "f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)", "f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)", "f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)", "f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)", "f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)", "f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)", "f(arccos(a*x),x*arccos(a*x)+sqrt(1-a^2*x^2)/a)", "f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)", "f(log(a*x),x*log(a*x)-x)", "f(x*log(a*x),x^2*log(a*x)/2-x^2/4)", "f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)", "f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)", "f(1/x*1/(a+log(x)),log(a+log(x)))", "f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)", "f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)", "f(sinh(x),cosh(x))", "f(cosh(x),sinh(x))", "f(tanh(x),log(cosh(x)))", "f(x*sinh(x),x*cosh(x)-sinh(x))", "f(x*cosh(x),x*sinh(x)-cosh(x))", "f(sinh(x)^2,sinh(2*x)/4-x/2)", "f(tanh(x)^2,x-tanh(x))", "f(cosh(x)^2,sinh(2*x)/4+x/2)", "f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)", "f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)", "f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)", "f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))", "f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)", "f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)", "f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)", "f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))", "f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))", "f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))", "f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))", "f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))", "f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))", 0];

  Eval_integral = function() {
    var doNothing, i, n, _i, _j;
    i = 0;
    n = 0;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
      push(symbol(NIL));
    } else if (isnum(p2)) {
      guess();
      push(p2);
    } else {
      push(p2);
      p1 = cdr(p1);
      push(car(p1));
      Eval();
    }
    p5 = pop();
    p4 = pop();
    p3 = pop();
    while (1.) {
      if (isnum(p5)) {
        push(p5);
        n = pop_integer();
        if (n === 0x80000000) {
          stop("nth integral: check n");
        }
      } else {
        n = 1;
      }
      push(p3);
      if (n >= 0) {
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          push(p4);
          integral();
        }
      } else {
        n = -n;
        for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
          push(p4);
          derivative();
        }
      }
      p3 = pop();
      if (p5 === symbol(NIL)) {
        break;
      }
      if (isnum(p5)) {
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
        if (p5 === symbol(NIL)) {
          break;
        }
        if (isnum(p5)) {
          doNothing = 1;
        } else {
          p4 = p5;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p5 = pop();
        }
      } else {
        p4 = p5;
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
      }
    }
    return push(p3);
  };

  integral = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      integral_of_sum();
    } else if (car(p1) === symbol(MULTIPLY)) {
      integral_of_product();
    } else {
      integral_of_form();
    }
    p1 = pop();
    if (Find(p1, symbol(INTEGRAL))) {
      stop("integral: sorry, could not find a solution");
    }
    push(p1);
    simplify();
    Eval();
    return restore();
  };

  integral_of_sum = function() {
    var _results;
    p1 = cdr(p1);
    push(car(p1));
    push(p2);
    integral();
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      integral();
      add();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  integral_of_product = function() {
    push(p1);
    push(p2);
    partition();
    p1 = pop();
    integral_of_form();
    return multiply();
  };

  integral_of_form = function() {
    push(p1);
    push(p2);
    transform(itab);
    p3 = pop();
    if (p3 === symbol(NIL)) {
      push_symbol(INTEGRAL);
      push(p1);
      push(p2);
      return list(3);
    } else {
      return push(p3);
    }
  };

  INV_check_arg = function() {
    if (!istensor(p1)) {
      return 0;
    } else if (p1.tensor.ndim !== 2) {
      return 0;
    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {
      return 0;
    } else {
      return 1;
    }
  };

  inv = function() {
    var a, i, n, _i;
    i = 0;
    n = 0;
    save();
    p1 = pop();
    if (INV_check_arg() === 0) {
      push_symbol(INV);
      push(p1);
      list(2);
      restore();
      return;
    }
    n = p1.tensor.nelem;
    a = p1.tensor.elem;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      if (!isnum(a[i])) {
        break;
      }
    }
    if (i === n) {
      yyinvg();
    } else {
      push(p1);
      adj();
      push(p1);
      det();
      p2 = pop();
      if (iszero(p2)) {
        stop("inverse of singular matrix");
      }
      push(p2);
      divide();
    }
    return restore();
  };

  invg = function() {
    save();
    p1 = pop();
    if (INV_check_arg() === 0) {
      push_symbol(INVG);
      push(p1);
      list(2);
      restore();
      return;
    }
    yyinvg();
    return restore();
  };

  yyinvg = function() {
    var h, i, j, n, _i, _j, _k, _l, _ref, _ref1;
    h = 0;
    i = 0;
    j = 0;
    n = 0;
    n = p1.tensor.dim[0];
    h = tos;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      for (j = _j = 0; 0 <= n ? _j < n : _j > n; j = 0 <= n ? ++_j : --_j) {
        if (i === j) {
          push(one);
        } else {
          push(zero);
        }
      }
    }
    for (i = _k = 0, _ref = n * n; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
      push(p1.tensor.elem[i]);
    }
    INV_decomp(n);
    p1 = alloc_tensor(n * n);
    p1.tensor.ndim = 2;
    p1.tensor.dim[0] = n;
    p1.tensor.dim[1] = n;
    for (i = _l = 0, _ref1 = n * n; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
      p1.tensor.elem[i] = stack[h + i];
    }
    tos -= 2 * n * n;
    return push(p1);
  };

  INV_decomp = function(n) {
    var a, d, i, j, u, _i, _j, _k, _l, _ref, _results;
    a = 0;
    d = 0;
    i = 0;
    j = 0;
    u = 0;
    a = tos - n * n;
    u = a - n * n;
    _results = [];
    for (d = _i = 0; 0 <= n ? _i < n : _i > n; d = 0 <= n ? ++_i : --_i) {
      if (equal(stack[a + n * d + d], zero)) {
        for (i = _j = _ref = d + 1; _ref <= n ? _j < n : _j > n; i = _ref <= n ? ++_j : --_j) {
          if (!equal(stack[a + n * i + d], zero)) {
            break;
          }
        }
        if (i === n) {
          stop("inverse of singular matrix");
        }
        for (j = _k = 0; 0 <= n ? _k < n : _k > n; j = 0 <= n ? ++_k : --_k) {
          p2 = stack[a + n * d + j];
          stack[a + n * d + j] = stack[a + n * i + j];
          stack[a + n * i + j] = p2;
          p2 = stack[u + n * d + j];
          stack[u + n * d + j] = stack[u + n * i + j];
          stack[u + n * i + j] = p2;
        }
      }
      p2 = stack[a + n * d + d];
      for (j = _l = 0; 0 <= n ? _l < n : _l > n; j = 0 <= n ? ++_l : --_l) {
        if (j > d) {
          push(stack[a + n * d + j]);
          push(p2);
          divide();
          stack[a + n * d + j] = pop();
        }
        push(stack[u + n * d + j]);
        push(p2);
        divide();
        stack[u + n * d + j] = pop();
      }
      _results.push((function() {
        var _m, _results1;
        _results1 = [];
        for (i = _m = 0; 0 <= n ? _m < n : _m > n; i = 0 <= n ? ++_m : --_m) {
          if (i === d) {
            continue;
          }
          p2 = stack[a + n * i + d];
          _results1.push((function() {
            var _n, _results2;
            _results2 = [];
            for (j = _n = 0; 0 <= n ? _n < n : _n > n; j = 0 <= n ? ++_n : --_n) {
              if (j > d) {
                push(stack[a + n * i + j]);
                push(stack[a + n * d + j]);
                push(p2);
                multiply();
                subtract();
                stack[a + n * i + j] = pop();
              }
              push(stack[u + n * i + j]);
              push(stack[u + n * d + j]);
              push(p2);
              multiply();
              subtract();
              _results2.push(stack[u + n * i + j] = pop());
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  iszero = function(p) {
    var i, _i, _ref;
    i = 0;
    switch (p.k) {
      case NUM:
        if (MZERO(p.q.a)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === 0.0) {
          return 1;
        }
        break;
      case TENSOR:
        for (i = _i = 0, _ref = p.tensor.nelem; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (!iszero(p.tensor.elem[i])) {
            return 0;
          }
        }
        return 1;
    }
    return 0;
  };

  isnegativenumber = function(p) {
    switch (p.k) {
      case NUM:
        if (MSIGN(p.q.a) === -1) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d < 0.0) {
          return 1;
        }
    }
    return 0;
  };

  isplusone = function(p) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === 1.0) {
          return 1;
        }
    }
    return 0;
  };

  isminusone = function(p) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === -1.0) {
          return 1;
        }
    }
    return 0;
  };

  isinteger = function(p) {
    if (p.k === NUM && MEQUAL(p.q.b, 1)) {
      return 1;
    } else {
      return 0;
    }
  };

  isnonnegativeinteger = function(p) {
    if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {
      return 1;
    } else {
      return 0;
    }
  };

  isposint = function(p) {
    if (isinteger(p) && MSIGN(p.q.a) === 1) {
      return 1;
    } else {
      return 0;
    }
  };

  ispoly = function(p, x) {
    if (Find(p, x)) {
      return ispoly_expr(p, x);
    } else {
      return 0;
    }
  };

  ispoly_expr = function(p, x) {
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      while (iscons(p)) {
        if (!ispoly_term(car(p), x)) {
          return 0;
        }
        p = cdr(p);
      }
      return 1;
    } else {
      return ispoly_term(p, x);
    }
  };

  ispoly_term = function(p, x) {
    if (car(p) === symbol(MULTIPLY)) {
      p = cdr(p);
      while (iscons(p)) {
        if (!ispoly_factor(car(p), x)) {
          return 0;
        }
        p = cdr(p);
      }
      return 1;
    } else {
      return ispoly_factor(p, x);
    }
  };

  ispoly_factor = function(p, x) {
    if (equal(p, x)) {
      return 1;
    }
    if (car(p) === symbol(POWER) && equal(cadr(p), x)) {
      if (isposint(caddr(p))) {
        return 1;
      } else {
        return 0;
      }
    }
    if (Find(p, x)) {
      return 0;
    } else {
      return 1;
    }
  };

  isnegativeterm = function(p) {
    if (isnegativenumber(p)) {
      return 1;
    } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  isimaginarynumber = function(p) {
    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isnum(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit)) {
      return 1;
    } else {
      return 0;
    }
  };

  iscomplexnumber = function(p) {
    if ((car(p) === symbol(ADD) && length(p) === 3 && isnum(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {
      return 1;
    } else {
      return 0;
    }
  };

  iseveninteger = function(p) {
    if (isinteger(p) && p.q.a.isEven()) {
      return 1;
    } else {
      return 0;
    }
  };

  isnegative = function(p) {
    if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {
      return 1;
    } else if (isnegativeterm(p)) {
      return 1;
    } else {
      return 0;
    }
  };

  issymbolic = function(p) {
    if (issymbol(p)) {
      return 1;
    } else {
      while (iscons(p)) {
        if (issymbolic(car(p))) {
          return 1;
        }
        p = cdr(p);
      }
      return 0;
    }
  };

  isintegerfactor = function(p) {
    if (isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  isoneover = function(p) {
    if (car(p) === symbol(POWER) && isminusone(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  isfraction = function(p) {
    if (p.k === NUM && !MEQUAL(p.q.b, 1)) {
      return 1;
    } else {
      return 0;
    }
  };

  equaln = function(p, n) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === n) {
          return 1;
        }
    }
    return 0;
  };

  equalq = function(p, a, b) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === a / b) {
          return 1;
        }
    }
    return 0;
  };

  isoneoversqrttwo = function(p) {
    if (car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2)) {
      return 1;
    } else {
      return 0;
    }
  };

  isminusoneoversqrttwo = function(p) {
    if (car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3) {
      return 1;
    } else {
      return 0;
    }
  };

  isfloating = function(p) {
    if (p.k === DOUBLE) {
      return 1;
    }
    while (iscons(p)) {
      if (isfloating(car(p))) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  };

  isimaginaryunit = function(p) {
    if (equal(p, imaginaryunit)) {
      return 1;
    } else {
      return 0;
    }
  };

  isquarterturn = function(p) {
    var minussign, n;
    n = 0;
    minussign = 0;
    if (car(p) !== symbol(MULTIPLY)) {
      return 0;
    }
    if (equal(cadr(p), imaginaryunit)) {
      if (caddr(p) !== symbol(PI)) {
        return 0;
      }
      if (length(p) !== 3) {
        return 0;
      }
      return 2;
    }
    if (!isnum(cadr(p))) {
      return 0;
    }
    if (!equal(caddr(p), imaginaryunit)) {
      return 0;
    }
    if (cadddr(p) !== symbol(PI)) {
      return 0;
    }
    if (length(p) !== 4) {
      return 0;
    }
    push(cadr(p));
    push_integer(2);
    multiply();
    n = pop_integer();
    if (n === 0x80000000) {
      return 0;
    }
    if (n < 1) {
      minussign = 1;
      n = -n;
    }
    switch (n % 4) {
      case 0:
        n = 1;
        break;
      case 1:
        if (minussign) {
          n = 4;
        } else {
          n = 3;
        }
        break;
      case 2:
        n = 2;
        break;
      case 3:
        if (minussign) {
          n = 3;
        } else {
          n = 4;
        }
    }
    return n;
  };

  isnpi = function(p) {
    var doNothing, n;
    n = 0;
    if (p === symbol(PI)) {
      return 2;
    }
    if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {
      doNothing = 0;
    } else {
      return 0;
    }
    push(cadr(p));
    push_integer(2);
    multiply();
    n = pop_integer();
    if (n === 0x80000000) {
      return 0;
    }
    if (n < 0) {
      n = 4 - (-n) % 4;
    } else {
      n = 1 + (n - 1) % 4;
    }
    return n;
  };

  $.iszero = iszero;

  $.isnegativenumber = isnegativenumber;

  $.isplusone = isplusone;

  $.isminusone = isminusone;

  $.isinteger = isinteger;

  $.isnonnegativeinteger = isnonnegativeinteger;

  $.isposint = isposint;

  $.isnegativeterm = isnegativeterm;

  $.isimaginarynumber = isimaginarynumber;

  $.iscomplexnumber = iscomplexnumber;

  $.iseveninteger = iseveninteger;

  $.isnegative = isnegative;

  $.issymbolic = issymbolic;

  $.isintegerfactor = isintegerfactor;

  $.isoneover = isoneover;

  $.isfraction = isfraction;

  $.isoneoversqrttwo = isoneoversqrttwo;

  $.isminusoneoversqrttwo = isminusoneoversqrttwo;

  $.isfloating = isfloating;

  $.isimaginaryunit = isimaginaryunit;

  $.isquarterturn = isquarterturn;

  $.isnpi = isnpi;

  Eval_isprime = function() {
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };


  /*
   Laguerre function
  
  Example
  
  	laguerre(x,3)
  
  Result
  
  	   1   3    3   2
  	- --- x  + --- x  - 3 x + 1
  	   6        2
  
  The computation uses the following recurrence relation.
  
  	L(x,0,k) = 1
  
  	L(x,1,k) = -x + k + 1
  
  	n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)
  
  In the "for" loop i = n-1 so the recurrence relation becomes
  
  	(i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)
   */

  Eval_laguerre = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push_integer(0);
    } else {
      push(p2);
    }
    return laguerre();
  };

  laguerre = function() {
    var n;
    n = 0;
    save();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push_symbol(LAGUERRE);
      push(p1);
      push(p2);
      push(p3);
      list(4);
      restore();
      return;
    }
    if (issymbol(p1)) {
      laguerre2(n);
    } else {
      p4 = p1;
      p1 = symbol(SECRETX);
      laguerre2(n);
      p1 = p4;
      push(symbol(SECRETX));
      push(p1);
      subst();
      Eval();
    }
    return restore();
  };

  laguerre2 = function(n) {
    var i, _i, _results;
    i = 0;
    push_integer(1);
    push_integer(0);
    p6 = pop();
    _results = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      p5 = p6;
      p6 = pop();
      push_integer(2 * i + 1);
      push(p1);
      subtract();
      push(p3);
      add();
      push(p6);
      multiply();
      push_integer(i);
      push(p3);
      add();
      push(p5);
      multiply();
      subtract();
      push_integer(i + 1);
      _results.push(divide());
    }
    return _results;
  };

  Eval_lcm = function() {
    var _results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      lcm();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  lcm = function() {
    var x;
    x = 0;
    x = expanding;
    save();
    yylcm();
    restore();
    return expanding = x;
  };

  yylcm = function() {
    expanding = 1;
    p2 = pop();
    p1 = pop();
    push(p1);
    push(p2);
    gcd();
    push(p1);
    divide();
    push(p2);
    divide();
    return inverse();
  };


  /*
   Return the leading coefficient of a polynomial.
  
  Example
  
  	leading(5x^2+x+1,x)
  
  Result
  
  	5
  
  The result is undefined if P is not a polynomial.
   */

  Eval_leading = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p1 = pop();
    if (p1 === symbol(NIL)) {
      guess();
    } else {
      push(p1);
    }
    return leading();
  };

  leading = function() {
    save();
    p2 = pop();
    p1 = pop();
    push(p1);
    push(p2);
    degree();
    p3 = pop();
    push(p1);
    push(p2);
    push(p3);
    power();
    divide();
    push(p2);
    filter();
    return restore();
  };


  /*
   Legendre function
  
  Example
  
  	legendre(x,3,0)
  
  Result
  
  	 5   3    3
  	--- x  - --- x
  	 2        2
  
  The computation uses the following recurrence relation.
  
  	P(x,0) = 1
  
  	P(x,1) = x
  
  	n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)
  
  In the "for" loop we have i = n-1 so the recurrence relation becomes
  
  	(i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)
  
  For m > 0
  
  	P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)
   */

  Eval_legendre = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push_integer(0);
    } else {
      push(p2);
    }
    return legendre();
  };

  legendre = function() {
    save();
    __legendre();
    return restore();
  };

  __legendre = function() {
    var m, n;
    m = 0;
    n = 0;
    p3 = pop();
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    push(p3);
    m = pop_integer();
    if (n < 0 || n === 0x80000000 || m < 0 || m === 0x80000000) {
      push_symbol(LEGENDRE);
      push(p1);
      push(p2);
      push(p3);
      list(4);
      return;
    }
    if (issymbol(p1)) {
      __legendre2(n, m);
    } else {
      p4 = p1;
      p1 = symbol(SECRETX);
      __legendre2(n, m);
      p1 = p4;
      push(symbol(SECRETX));
      push(p1);
      subst();
      Eval();
    }
    return __legendre3(m);
  };

  __legendre2 = function(n, m) {
    var i, _i, _j, _results;
    i = 0;
    push_integer(1);
    push_integer(0);
    p6 = pop();
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      p5 = p6;
      p6 = pop();
      push_integer(2 * i + 1);
      push(p1);
      multiply();
      push(p6);
      multiply();
      push_integer(i);
      push(p5);
      multiply();
      subtract();
      push_integer(i + 1);
      divide();
    }
    _results = [];
    for (i = _j = 0; 0 <= m ? _j < m : _j > m; i = 0 <= m ? ++_j : --_j) {
      push(p1);
      _results.push(derivative());
    }
    return _results;
  };

  __legendre3 = function(m) {
    if (m === 0) {
      return;
    }
    if (car(p1) === symbol(COS)) {
      push(cadr(p1));
      sine();
      square();
    } else if (car(p1) === symbol(SIN)) {
      push(cadr(p1));
      cosine();
      square();
    } else {
      push_integer(1);
      push(p1);
      square();
      subtract();
    }
    push_integer(m);
    push_rational(1, 2);
    multiply();
    power();
    multiply();
    if (m % 2) {
      return negate();
    }
  };

  list = function(n) {
    var listIterator, _i, _results;
    listIterator = 0;
    push(symbol(NIL));
    _results = [];
    for (listIterator = _i = 0; 0 <= n ? _i < n : _i > n; listIterator = 0 <= n ? ++_i : --_i) {
      _results.push(cons());
    }
    return _results;
  };

  Eval_log = function() {
    push(cadr(p1));
    Eval();
    return logarithm();
  };

  logarithm = function() {
    save();
    yylog();
    return restore();
  };

  yylog = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (p1 === symbol(E)) {
      push_integer(1);
      return;
    }
    if (equaln(p1, 1)) {
      push_integer(0);
      return;
    }
    if (isnegativenumber(p1)) {
      push(p1);
      negate();
      logarithm();
      push(imaginaryunit);
      push_symbol(PI);
      multiply();
      add();
      return;
    }
    if (isdouble(p1)) {
      d = Math.log(p1.d);
      push_double(d);
      return;
    }
    if (isfraction(p1)) {
      push(p1);
      numerator();
      logarithm();
      push(p1);
      denominator();
      logarithm();
      subtract();
      return;
    }
    if (car(p1) === symbol(POWER)) {
      push(caddr(p1));
      push(cadr(p1));
      logarithm();
      multiply();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      push_integer(0);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        logarithm();
        add();
        p1 = cdr(p1);
      }
      return;
    }
    push_symbol(LOG);
    push(p1);
    return list(2);
  };

  madd = function(a, b) {
    return a.add(b);
  };

  msub = function(a, b) {
    return a.subtract(b);
  };

  addf = function(a, b) {
    return a.add(b);
  };

  subf = function(a, b) {
    return a.subtract(b);
  };

  ucmp = function(a, b) {
    return a.compareAbs(b);
  };


  /*
   Magnitude of complex z
  
  	z		mag(z)
  	-		------
  
  	a		a
  
  	-a		a
  
  	(-1)^a		1
  
  	exp(a + i b)	exp(a)
  
  	a b		mag(a) mag(b)
  
  	a + i b		sqrt(a^2 + b^2)
  
  Notes
  
  	1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)
  
  	2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then
  
  		mag(numerator(z)) / mag(denominator(z))
  
  	   must be used to get the correct answer. Now the operation is
  	   automatic.
   */

  Eval_mag = function() {
    push(cadr(p1));
    Eval();
    return mag();
  };

  mag = function() {
    save();
    p1 = pop();
    push(p1);
    numerator();
    yymag();
    push(p1);
    denominator();
    yymag();
    divide();
    return restore();
  };

  yymag = function() {
    save();
    p1 = pop();
    if (isnegativenumber(p1)) {
      push(p1);
      negate();
    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {
      push_integer(1);
    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {
      push(caddr(p1));
      real();
      exponential();
    } else if (car(p1) === symbol(MULTIPLY)) {
      push_integer(1);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        mag();
        multiply();
        p1 = cdr(p1);
      }
    } else if (car(p1) === symbol(ADD)) {
      push(p1);
      rect();
      p1 = pop();
      push(p1);
      real();
      push_integer(2);
      power();
      push(p1);
      imag();
      push_integer(2);
      power();
      add();
      push_rational(1, 2);
      power();
      simplify_trig();
    } else {
      push(p1);
    }
    return restore();
  };

  mgcd = function(u, v) {
    return bigInt.gcd(u, v);
  };

  new_string = function(s) {
    save();
    p1 = new U();
    p1.k = STR;
    p1.str = s;
    push(p1);
    return restore();
  };

  out_of_memory = function() {
    return stop("out of memory");
  };

  push_zero_matrix = function(i, j) {
    push(alloc_tensor(i * j));
    stack[tos - 1].tensor.ndim = 2;
    stack[tos - 1].tensor.dim[0] = i;
    return stack[tos - 1].tensor.dim[1] = j;
  };

  push_identity_matrix = function(n) {
    var i, _i;
    push_zero_matrix(n, n);
    i = 0;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      stack[tos - 1].tensor.elem[i * n + i] = one;
    }
    if (stack[tos - 1].tensor.nelem !== stack[tos - 1].tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
  };

  push_cars = function(p) {
    var _results;
    _results = [];
    while (iscons(p)) {
      push(car(p));
      _results.push(p = cdr(p));
    }
    return _results;
  };

  peek = function() {
    save();
    p1 = pop();
    push(p1);
    printline(p1);
    return restore();
  };

  peek2 = function() {
    print_lisp(stack[tos - 2]);
    return print_lisp(stack[tos - 1]);
  };

  equal = function(p1, p2) {
    if (cmp_expr(p1, p2) === 0) {
      return 1;
    } else {
      return 0;
    }
  };

  lessp = function(p1, p2) {
    if (cmp_expr(p1, p2) < 0) {
      return 1;
    } else {
      return 0;
    }
  };

  sign = function(n) {
    if (n < 0) {
      return -1;
    } else if (n > 0) {
      return 1;
    } else {
      return 0;
    }
  };

  cmp_expr = function(p1, p2) {
    var n;
    n = 0;
    if (p1 === p2) {
      return 0;
    }
    if (p1 === symbol(NIL)) {
      return -1;
    }
    if (p2 === symbol(NIL)) {
      return 1;
    }
    if (isnum(p1) && isnum(p2)) {
      return sign(compare_numbers(p1, p2));
    }
    if (isnum(p1)) {
      return -1;
    }
    if (isnum(p2)) {
      return 1;
    }
    if (isstr(p1) && isstr(p2)) {
      return sign(strcmp(p1.str, p2.str));
    }
    if (isstr(p1)) {
      return -1;
    }
    if (isstr(p2)) {
      return 1;
    }
    if (issymbol(p1) && issymbol(p2)) {
      return sign(strcmp(get_printname(p1), get_printname(p2)));
    }
    if (issymbol(p1)) {
      return -1;
    }
    if (issymbol(p2)) {
      return 1;
    }
    if (istensor(p1) && istensor(p2)) {
      return compare_tensors(p1, p2);
    }
    if (istensor(p1)) {
      return -1;
    }
    if (istensor(p2)) {
      return 1;
    }
    while (iscons(p1) && iscons(p2)) {
      n = cmp_expr(car(p1), car(p2));
      if (n !== 0) {
        return n;
      }
      p1 = cdr(p1);
      p2 = cdr(p2);
    }
    if (iscons(p2)) {
      return -1;
    }
    if (iscons(p1)) {
      return 1;
    }
    return 0;
  };

  length = function(p) {
    var n;
    n = 0;
    while (iscons(p)) {
      p = cdr(p);
      n++;
    }
    return n;
  };

  unique = function(p) {
    save();
    p1 = symbol(NIL);
    p2 = symbol(NIL);
    unique_f(p);
    if (p2 !== symbol(NIL)) {
      p1 = symbol(NIL);
    }
    p = p1;
    restore();
    return p;
  };

  unique_f = function(p) {
    if (isstr(p)) {
      if (p1 === symbol(NIL)) {
        p1 = p;
      } else if (p !== p1) {
        p2 = p;
      }
      return;
    }
    while (iscons(p)) {
      unique_f(car(p));
      if (p2 !== symbol(NIL)) {
        return;
      }
      p = cdr(p);
    }
  };

  ssqrt = function() {
    push_rational(1, 2);
    return power();
  };

  yyexpand = function() {
    var x;
    x = expanding;
    expanding = 1;
    Eval();
    return expanding = x;
  };

  exponential = function() {
    push_symbol(E);
    swap();
    return power();
  };

  square = function() {
    push_integer(2);
    return power();
  };

  sort_stack = function(n) {
    var h, subsetOfStack;
    h = tos - n;
    subsetOfStack = stack.slice(h, h + n);
    subsetOfStack.sort(cmp_expr);
    return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
  };

  $.equal = equal;

  $.length = length;

  mmul = function(a, b) {
    return a.multiply(b);
  };

  mdiv = function(a, b) {
    return a.divide(b);
  };


  /*
  static void
  addf(unsigned int *a, unsigned int *b, int len)
  {
  	int i
  	long long t = 0; # can be signed or unsigned 
  	for (i = 0; i < len; i++) {
  		t += (long long) a[i] + b[i]
  		a[i] = (unsigned int) t
  		t >>= 32
  	}
  }
  
  // a = a - b
  
  static void
  subf(unsigned int *a, unsigned int *b, int len)
  {
  	int i
  	long long t = 0; # must be signed
  	for (i = 0; i < len; i++) {
  		t += (long long) a[i] - b[i]
  		a[i] = (unsigned int) t
  		t >>= 32
  	}
  }
  
  // a = b * c
  
  // 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000
  
  static void
  mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)
  {
  	int i
  	unsigned long long t = 0; # must be unsigned
  	for (i = 0; i < len; i++) {
  		t += (unsigned long long) b[i] * c
  		a[i] = (unsigned int) t
  		t >>= 32
  	}
  	a[i] = (unsigned int) t
  }
   */

  mmod = function(a, b) {
    return a.mod(b);
  };

  mdivrem = function(a, b) {
    var toReturn;
    toReturn = a.divmod(b);
    return [toReturn.quotient, toReturn.remainder];
  };

  Eval_mod = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return mod();
  };

  mod = function() {
    var n;
    n = 0;
    save();
    p2 = pop();
    p1 = pop();
    if (iszero(p2)) {
      stop("mod function: divide by zero");
    }
    if (!isnum(p1) || !isnum(p2)) {
      push_symbol(MOD);
      push(p1);
      push(p2);
      list(3);
      restore();
      return;
    }
    if (isdouble(p1)) {
      push(p1);
      n = pop_integer();
      if (n === 0x80000000) {
        stop("mod function: cannot convert float value to integer");
      }
      push_integer(n);
      p1 = pop();
    }
    if (isdouble(p2)) {
      push(p2);
      n = pop_integer();
      if (n === 0x80000000) {
        stop("mod function: cannot convert float value to integer");
      }
      push_integer(n);
      p2 = pop();
    }
    if (!isinteger(p1) || !isinteger(p2)) {
      stop("mod function: integer arguments expected");
    }
    p3 = new U();
    p3.k = NUM;
    p3.q.a = mmod(p1.q.a, p2.q.a);
    p3.q.b = mint(1);
    push(p3);
    return restore();
  };

  mpow = function(a, n) {
    return a.pow(n);
  };

  mprime = function(n) {
    return n.isProbablePrime();
  };

  mroot = function(n, index) {
    var i, j, k, x, y, _i;
    n = n.abs();
    i = 0;
    j = 0;
    k = 0;
    if (index === 0) {
      stop("root index is zero");
    }
    k = 0;
    while (n.shiftRight(k) > 0) {
      k++;
    }
    if (k === 0) {
      return mint(0);
    }
    k = Math.floor((k - 1) / index);
    j = Math.floor(k / 32 + 1);
    x = bigInt(j);
    for (i = _i = 0; 0 <= j ? _i < j : _i > j; i = 0 <= j ? ++_i : --_i) {
      x = x.and(bigInt(1).shiftLeft(i).not());
    }
    while (k >= 0) {
      x = x.or(bigInt(1).shiftLeft(k));
      y = mpow(x, index);
      switch (mcmp(y, n)) {
        case 0:
          return x;
        case 1:
          x = x.and(bigInt(1).shiftLeft(k).not());
      }
      k--;
    }
    return 0;
  };

  multiply = function() {
    if (esc_flag) {
      stop("escape key stop");
    }
    if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      return multiply_numbers();
    } else {
      save();
      yymultiply();
      return restore();
    }
  };

  yymultiply = function() {
    var h, i, n, _i;
    h = 0;
    i = 0;
    n = 0;
    p2 = pop();
    p1 = pop();
    h = tos;
    if (iszero(p1) || iszero(p2)) {
      push(zero);
      return;
    }
    if (expanding && isadd(p1)) {
      p1 = cdr(p1);
      push(zero);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        multiply();
        add();
        p1 = cdr(p1);
      }
      return;
    }
    if (expanding && isadd(p2)) {
      p2 = cdr(p2);
      push(zero);
      while (iscons(p2)) {
        push(p1);
        push(car(p2));
        multiply();
        add();
        p2 = cdr(p2);
      }
      return;
    }
    if (!istensor(p1) && istensor(p2)) {
      push(p1);
      push(p2);
      scalar_times_tensor();
      return;
    }
    if (istensor(p1) && !istensor(p2)) {
      push(p1);
      push(p2);
      tensor_times_scalar();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
    } else {
      push(p1);
      list(1);
      p1 = pop();
    }
    if (car(p2) === symbol(MULTIPLY)) {
      p2 = cdr(p2);
    } else {
      push(p2);
      list(1);
      p2 = pop();
    }
    if (isnum(car(p1)) && isnum(car(p2))) {
      push(car(p1));
      push(car(p2));
      multiply_numbers();
      p1 = cdr(p1);
      p2 = cdr(p2);
    } else if (isnum(car(p1))) {
      push(car(p1));
      p1 = cdr(p1);
    } else if (isnum(car(p2))) {
      push(car(p2));
      p2 = cdr(p2);
    } else {
      push(one);
    }
    parse_p1();
    parse_p2();
    while (iscons(p1) && iscons(p2)) {
      if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {
        push_symbol(OPERATOR);
        push(cdar(p1));
        push(cdar(p2));
        append();
        cons();
        p1 = cdr(p1);
        p2 = cdr(p2);
        parse_p1();
        parse_p2();
        continue;
      }
      switch (cmp_expr(p3, p4)) {
        case -1:
          push(car(p1));
          p1 = cdr(p1);
          parse_p1();
          break;
        case 1:
          push(car(p2));
          p2 = cdr(p2);
          parse_p2();
          break;
        case 0:
          combine_factors(h);
          p1 = cdr(p1);
          p2 = cdr(p2);
          parse_p1();
          parse_p2();
          break;
        default:
          stop("internal error 2");
      }
    }
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
    }
    while (iscons(p2)) {
      push(car(p2));
      p2 = cdr(p2);
    }
    __normalize_radical_factors(h);
    if (expanding) {
      for (i = _i = h; h <= tos ? _i < tos : _i > tos; i = h <= tos ? ++_i : --_i) {
        if (isadd(stack[i])) {
          multiply_all(tos - h);
          return;
        }
      }
    }
    n = tos - h;
    if (n === 1) {
      return;
    }
    if (isrational(stack[h]) && equaln(stack[h], 1)) {
      if (n === 2) {
        p7 = pop();
        pop();
        push(p7);
      } else {
        stack[h] = symbol(MULTIPLY);
        list(n);
      }
      return;
    }
    list(n);
    p7 = pop();
    push_symbol(MULTIPLY);
    push(p7);
    return cons();
  };

  parse_p1 = function() {
    p3 = car(p1);
    p5 = one;
    if (car(p3) === symbol(POWER)) {
      p5 = caddr(p3);
      return p3 = cadr(p3);
    }
  };

  parse_p2 = function() {
    p4 = car(p2);
    p6 = one;
    if (car(p4) === symbol(POWER)) {
      p6 = caddr(p4);
      return p4 = cadr(p4);
    }
  };

  combine_factors = function(h) {
    push(p4);
    push(p5);
    push(p6);
    add();
    power();
    p7 = pop();
    if (isnum(p7)) {
      push(stack[h]);
      push(p7);
      multiply_numbers();
      return stack[h] = pop();
    } else if (car(p7) === symbol(MULTIPLY)) {
      if (isnum(cadr(p7)) && cdddr(p7) === symbol(NIL)) {
        push(stack[h]);
        push(cadr(p7));
        multiply_numbers();
        stack[h] = pop();
        return push(caddr(p7));
      } else {
        return push(p7);
      }
    } else {
      return push(p7);
    }
  };

  gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];

  combine_gammas = function(h) {
    var n;
    n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];
    if (n < 0) {
      n = -n;
      push(stack[h]);
      negate();
      stack[h] = pop();
    }
    if (n > 1) {
      return push(_gamma[n]);
    }
  };

  multiply_noexpand = function() {
    var x;
    x = expanding;
    expanding = 0;
    multiply();
    return expanding = x;
  };

  multiply_all = function(n) {
    var h, i, _i;
    i = 0;
    if (n === 1) {
      return;
    }
    if (n === 0) {
      push(one);
      return;
    }
    h = tos - n;
    push(stack[h]);
    for (i = _i = 1; 1 <= n ? _i < n : _i > n; i = 1 <= n ? ++_i : --_i) {
      push(stack[h + i]);
      multiply();
    }
    stack[h] = pop();
    return tos = h + 1;
  };

  multiply_all_noexpand = function(n) {
    var x;
    x = expanding;
    expanding = 0;
    multiply_all(n);
    return expanding = x;
  };

  divide = function() {
    if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      return divide_numbers();
    } else {
      inverse();
      return multiply();
    }
  };

  inverse = function() {
    if (isnum(stack[tos - 1])) {
      return invert_number();
    } else {
      push_integer(-1);
      return power();
    }
  };

  reciprocate = function() {
    if (isnum(stack[tos - 1])) {
      return invert_number();
    } else {
      push_integer(-1);
      return power();
    }
  };

  negate = function() {
    if (isnum(stack[tos - 1])) {
      return negate_number();
    } else {
      push_integer(-1);
      return multiply();
    }
  };

  negate_expand = function() {
    var x;
    x = expanding;
    expanding = 1;
    negate();
    return expanding = x;
  };

  negate_noexpand = function() {
    var x;
    x = expanding;
    expanding = 0;
    negate();
    return expanding = x;
  };

  __normalize_radical_factors = function(h) {
    var i, _i, _j, _k, _ref, _ref1, _ref2;
    i = 0;
    if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {
      return;
    }
    for (i = _i = _ref = h + 1; _ref <= tos ? _i < tos : _i > tos; i = _ref <= tos ? ++_i : --_i) {
      if (__is_radical_number(stack[i])) {
        break;
      }
    }
    if (i === tos) {
      return;
    }
    save();
    push(stack[h]);
    mp_numerator();
    p1 = pop();
    for (i = _j = _ref1 = h + 1; _ref1 <= tos ? _j < tos : _j > tos; i = _ref1 <= tos ? ++_j : --_j) {
      if (isplusone(p1) || isminusone(p1)) {
        break;
      }
      if (!__is_radical_number(stack[i])) {
        continue;
      }
      p3 = cadr(stack[i]);
      p4 = caddr(stack[i]);
      if (!isnegativenumber(p4)) {
        continue;
      }
      push(p1);
      push(p3);
      divide();
      p5 = pop();
      if (!isinteger(p5)) {
        continue;
      }
      p1 = p5;
      push_symbol(POWER);
      push(p3);
      push(one);
      push(p4);
      add();
      list(3);
      stack[i] = pop();
    }
    push(stack[h]);
    mp_denominator();
    p2 = pop();
    for (i = _k = _ref2 = h + 1; _ref2 <= tos ? _k < tos : _k > tos; i = _ref2 <= tos ? ++_k : --_k) {
      if (isplusone(p2)) {
        break;
      }
      if (!__is_radical_number(stack[i])) {
        continue;
      }
      p3 = cadr(stack[i]);
      p4 = caddr(stack[i]);
      if (isnegativenumber(p4)) {
        continue;
      }
      push(p2);
      push(p3);
      divide();
      p5 = pop();
      if (!isinteger(p5)) {
        continue;
      }
      p2 = p5;
      push_symbol(POWER);
      push(p3);
      push(p4);
      push(one);
      subtract();
      list(3);
      stack[i] = pop();
    }
    push(p1);
    push(p2);
    divide();
    stack[h] = pop();
    return restore();
  };

  __is_radical_number = function(p) {
    if (car(p) === symbol(POWER) && isnum(cadr(p)) && isnum(caddr(p)) && !isminusone(cadr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  NROOTS_YMAX = 101;

  NROOTS_DELTA = 1.0e-6;

  NROOTS_EPSILON = 1.0e-9;

  NROOTS_ABS = function(z) {
    return Math.sqrt(z.r * z.r + z.i * z.i);
  };

  theRandom = 0.0;

  NROOTS_RANDOM = function() {
    return 4.0 * Math.random() - 2.0;
  };

  numericRootOfPolynomial = (function() {
    function numericRootOfPolynomial() {}

    numericRootOfPolynomial.prototype.r = 0.0;

    numericRootOfPolynomial.prototype.i = 0.0;

    return numericRootOfPolynomial;

  })();

  nroots_a = new numericRootOfPolynomial();

  nroots_b = new numericRootOfPolynomial();

  nroots_x = new numericRootOfPolynomial();

  nroots_y = new numericRootOfPolynomial();

  nroots_fa = new numericRootOfPolynomial();

  nroots_fb = new numericRootOfPolynomial();

  nroots_dx = new numericRootOfPolynomial();

  nroots_df = new numericRootOfPolynomial();

  nroots_c = [];

  for (initNRoots = _i = 0; 0 <= NROOTS_YMAX ? _i < NROOTS_YMAX : _i > NROOTS_YMAX; initNRoots = 0 <= NROOTS_YMAX ? ++_i : --_i) {
    nroots_c[initNRoots] = new numericRootOfPolynomial();
  }

  Eval_nroots = function() {
    var h, i, k, n, _j, _k, _l;
    h = 0;
    i = 0;
    k = 0;
    n = 0;
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    p2 = pop();
    p1 = pop();
    if (!ispoly(p1, p2)) {
      stop("nroots: polynomial?");
    }
    h = tos;
    push(p1);
    push(p2);
    n = coeff();
    if (n > NROOTS_YMAX) {
      stop("nroots: degree?");
    }
    for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
      push(stack[h + i]);
      real();
      yyfloat();
      Eval();
      p1 = pop();
      push(stack[h + i]);
      imag();
      yyfloat();
      Eval();
      p2 = pop();
      if (!isdouble(p1) || !isdouble(p2)) {
        stop("nroots: coefficients?");
      }
      nroots_c[i].r = p1.d;
      nroots_c[i].i = p2.d;
    }
    tos = h;
    monic(n);
    for (k = _k = n; _k > 1; k = _k += -1) {
      findroot(k);
      if (Math.abs(nroots_a.r) < NROOTS_DELTA) {
        nroots_a.r = 0.0;
      }
      if (Math.abs(nroots_a.i) < NROOTS_DELTA) {
        nroots_a.i = 0.0;
      }
      push_double(nroots_a.r);
      push_double(nroots_a.i);
      push(imaginaryunit);
      multiply();
      add();
      NROOTS_divpoly(k);
    }
    n = tos - h;
    if (n > 1) {
      sort_stack(n);
      p1 = alloc_tensor(n);
      p1.tensor.ndim = 1;
      p1.tensor.dim[0] = n;
      for (i = _l = 0; 0 <= n ? _l < n : _l > n; i = 0 <= n ? ++_l : --_l) {
        p1.tensor.elem[i] = stack[h + i];
      }
      tos = h;
      return push(p1);
    }
  };

  monic = function(n) {
    var k, t, _j, _ref;
    k = 0;
    t = 0.0;
    nroots_y.r = nroots_c[n - 1].r;
    nroots_y.i = nroots_c[n - 1].i;
    t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;
    for (k = _j = 0, _ref = n - 1; 0 <= _ref ? _j < _ref : _j > _ref; k = 0 <= _ref ? ++_j : --_j) {
      nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;
      nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;
    }
    nroots_c[n - 1].r = 1.0;
    return nroots_c[n - 1].i = 0.0;
  };

  findroot = function(n) {
    var j, k, nrabs, t, _j, _k;
    j = 0;
    k = 0;
    t = 0.0;
    if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {
      nroots_a.r = 0.0;
      nroots_a.i = 0.0;
      return;
    }
    for (j = _j = 0; _j < 100; j = ++_j) {
      nroots_a.r = NROOTS_RANDOM();
      nroots_a.i = NROOTS_RANDOM();
      compute_fa(n);
      nroots_b.r = nroots_a.r;
      nroots_b.i = nroots_a.i;
      nroots_fb.r = nroots_fa.r;
      nroots_fb.i = nroots_fa.i;
      nroots_a.r = NROOTS_RANDOM();
      nroots_a.i = NROOTS_RANDOM();
      for (k = _k = 0; _k < 1000; k = ++_k) {
        compute_fa(n);
        nrabs = NROOTS_ABS(nroots_fa);
        if (DEBUG) {
          console.log("nrabs: " + nrabs);
        }
        if (nrabs < NROOTS_EPSILON) {
          return;
        }
        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {
          nroots_x.r = nroots_a.r;
          nroots_x.i = nroots_a.i;
          nroots_a.r = nroots_b.r;
          nroots_a.i = nroots_b.i;
          nroots_b.r = nroots_x.r;
          nroots_b.i = nroots_x.i;
          nroots_x.r = nroots_fa.r;
          nroots_x.i = nroots_fa.i;
          nroots_fa.r = nroots_fb.r;
          nroots_fa.i = nroots_fb.i;
          nroots_fb.r = nroots_x.r;
          nroots_fb.i = nroots_x.i;
        }
        nroots_dx.r = nroots_b.r - nroots_a.r;
        nroots_dx.i = nroots_b.i - nroots_a.i;
        nroots_df.r = nroots_fb.r - nroots_fa.r;
        nroots_df.i = nroots_fb.i - nroots_fa.i;
        t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;
        if (t === 0.0) {
          break;
        }
        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;
        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;
        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);
        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);
      }
    }
    return stop("nroots: convergence error");
  };

  compute_fa = function(n) {
    var k, t, _j, _results;
    k = 0;
    t = 0.0;
    nroots_x.r = nroots_a.r;
    nroots_x.i = nroots_a.i;
    nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;
    nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;
    _results = [];
    for (k = _j = 2; 2 <= n ? _j < n : _j > n; k = 2 <= n ? ++_j : --_j) {
      t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;
      nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;
      nroots_x.r = t;
      nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;
      _results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);
    }
    return _results;
  };

  NROOTS_divpoly = function(n) {
    var k, _j, _k, _ref, _ref1, _results;
    k = 0;
    for (k = _j = _ref = n - 1; _ref <= 0 ? _j < 0 : _j > 0; k = _ref <= 0 ? ++_j : --_j) {
      nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;
      nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;
    }
    if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {
      stop("nroots: residual error");
    }
    _results = [];
    for (k = _k = 0, _ref1 = n - 1; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; k = 0 <= _ref1 ? ++_k : --_k) {
      nroots_c[k].r = nroots_c[k + 1].r;
      _results.push(nroots_c[k].i = nroots_c[k + 1].i);
    }
    return _results;
  };

  Eval_numerator = function() {
    push(cadr(p1));
    Eval();
    return numerator();
  };

  numerator = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      push(p1);
      rationalize();
      p1 = pop();
    }
    if (car(p1) === symbol(MULTIPLY)) {
      h = tos;
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        numerator();
        p1 = cdr(p1);
      }
      multiply_all(tos - h);
    } else if (isrational(p1)) {
      push(p1);
      mp_numerator();
    } else if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
      push(one);
    } else {
      push(p1);
    }
    return restore();
  };

  Eval_outer = function() {
    var _results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    _results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      outer();
      _results.push(p1 = cdr(p1));
    }
    return _results;
  };

  outer = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (istensor(p1) && istensor(p2)) {
      yyouter();
    } else {
      push(p1);
      push(p2);
      if (istensor(p1)) {
        tensor_times_scalar();
      } else if (istensor(p2)) {
        scalar_times_tensor();
      } else {
        multiply();
      }
    }
    return restore();
  };

  yyouter = function() {
    var i, j, k, ndim, nelem, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3;
    i = 0;
    j = 0;
    k = 0;
    ndim = 0;
    nelem = 0;
    ndim = p1.tensor.ndim + p2.tensor.ndim;
    if (ndim > MAXDIM) {
      stop("outer: rank of result exceeds maximum");
    }
    nelem = p1.tensor.nelem * p2.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = _j = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    j = i;
    for (i = _k = 0, _ref1 = p2.tensor.ndim; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
      p3.tensor.dim[j + i] = p2.tensor.dim[i];
    }
    k = 0;
    for (i = _l = 0, _ref2 = p1.tensor.nelem; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
      for (j = _m = 0, _ref3 = p2.tensor.nelem; 0 <= _ref3 ? _m < _ref3 : _m > _ref3; j = 0 <= _ref3 ? ++_m : --_m) {
        push(p1.tensor.elem[i]);
        push(p2.tensor.elem[j]);
        multiply();
        p3.tensor.elem[k++] = pop();
      }
    }
    return push(p3);
  };


  /*
   Partition a term
  
  	Input stack:
  
  		term (factor or product of factors)
  
  		free variable
  
  	Output stack:
  
  		constant expression
  
  		variable expression
   */

  partition = function() {
    save();
    p2 = pop();
    p1 = pop();
    push_integer(1);
    p3 = pop();
    p4 = p3;
    p1 = cdr(p1);
    while (iscons(p1)) {
      if (Find(car(p1), p2)) {
        push(p4);
        push(car(p1));
        multiply();
        p4 = pop();
      } else {
        push(p3);
        push(car(p1));
        multiply();
        p3 = pop();
      }
      p1 = cdr(p1);
    }
    push(p3);
    push(p4);
    return restore();
  };


  /*
  Convert complex z to polar form
  
  	Input:		push	z
  
  	Output:		Result on stack
  
  	polar(z) = mag(z) * exp(i * arg(z))
   */

  Eval_polar = function() {
    push(cadr(p1));
    Eval();
    return polar();
  };

  polar = function() {
    save();
    p1 = pop();
    push(p1);
    mag();
    push(imaginaryunit);
    push(p1);
    arg();
    multiply();
    exponential();
    multiply();
    return restore();
  };

  n_factor_number = 0;

  factor_number = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {
      push(p1);
      restore();
      return;
    }
    n_factor_number = p1.q.a;
    h = tos;
    factor_a();
    if (tos - h > 1) {
      list(tos - h);
      push_symbol(MULTIPLY);
      swap();
      cons();
    }
    return restore();
  };

  factor_a = function() {
    var k, _j;
    k = 0;
    if (n_factor_number.isNegative()) {
      n_factor_number = setSignTo(n_factor_number, 1);
      push_integer(-1);
    }
    for (k = _j = 0; _j < 10000; k = ++_j) {
      try_kth_prime(k);
      if (n_factor_number.compare(1) === 0) {
        return;
      }
    }
    return factor_b();
  };

  try_kth_prime = function(k) {
    var count, d, q, r, _ref;
    count = 0;
    d = mint(primetab[k]);
    count = 0;
    while (1.) {
      if (n_factor_number.compare(1) === 0) {
        if (count) {
          push_factor(d, count);
        }
        return;
      }
      _ref = mdivrem(n_factor_number, d), q = _ref[0], r = _ref[1];
      if (r.isZero()) {
        count++;
        n_factor_number = q;
      } else {
        break;
      }
    }
    if (count) {
      push_factor(d, count);
    }
    if (mcmp(q, d) === -1) {
      push_factor(n_factor_number, 1);
      return n_factor_number = mint(1);
    }
  };

  factor_b = function() {
    var bigint_one, g, k, l, t, x, xprime;
    k = 0;
    l = 0;
    bigint_one = mint(1);
    x = mint(5);
    xprime = mint(2);
    k = 1;
    l = 1;
    while (1.) {
      if (mprime(n_factor_number)) {
        push_factor(n_factor_number, 1);
        return 0;
      }
      while (1.) {
        if (esc_flag) {
          stop("esc");
        }
        t = msub(xprime, x);
        t = setSignTo(t, 1);
        g = mgcd(t, n_factor_number);
        if (MEQUAL(g, 1)) {
          if (--k === 0) {
            xprime = x;
            l *= 2;
            k = l;
          }
          t = mmul(x, x);
          x = madd(t, bigint_one);
          t = mmod(x, n_factor_number);
          x = t;
          continue;
        }
        push_factor(g, 1);
        if (mcmp(g, n_factor_number) === 0) {
          return -1;
        }
        t = mdiv(n_factor_number, g);
        n_factor_number = t;
        t = mmod(x, n_factor_number);
        x = t;
        t = mmod(xprime, n_factor_number);
        xprime = t;
        break;
      }
    }
  };

  push_factor = function(d, count) {
    p1 = new U();
    p1.k = NUM;
    p1.q.a = d;
    p1.q.b = mint(1);
    push(p1);
    if (count > 1) {
      push_symbol(POWER);
      swap();
      p1 = new U();
      p1.k = NUM;
      p1.q.a = mint(count);
      p1.q.b = mint(1);
      push(p1);
      return list(3);
    }
  };


  /* Power function
  
  	Input:		push	Base
  
  			push	Exponent
  
  	Output:		Result on stack
   */

  Eval_power = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return power();
  };

  power = function() {
    save();
    yypower();
    return restore();
  };

  yypower = function() {
    var n;
    n = 0;
    p2 = pop();
    p1 = pop();
    if (isrational(p1) && isrational(p2)) {
      push(p1);
      push(p2);
      qpow();
      return;
    }
    if (isnum(p1) && isnum(p2)) {
      push(p1);
      push(p2);
      dpow();
      return;
    }
    if (istensor(p1)) {
      power_tensor();
      return;
    }
    if (p1 === symbol(E) && car(p2) === symbol(LOG)) {
      push(cadr(p2));
      return;
    }
    if (p1 === symbol(E) && isdouble(p2)) {
      push_double(exp(p2.d));
      return;
    }
    if (equal(p1, one) || iszero(p2)) {
      push(one);
      return;
    }
    if (equal(p2, one)) {
      push(p1);
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      push(car(p1));
      push(p2);
      power();
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        power();
        multiply();
        p1 = cdr(p1);
      }
      return;
    }
    if (car(p1) === symbol(POWER)) {
      push(cadr(p1));
      push(caddr(p1));
      push(p2);
      multiply();
      power();
      return;
    }
    if (expanding && isadd(p1) && isnum(p2)) {
      push(p2);
      n = pop_integer();
      if (n > 1 && n !== 0x80000000) {
        power_sum(n);
        return;
      }
    }
    if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {
      push_integer(1);
      push(cadr(p1));
      cosine();
      push_integer(2);
      power();
      subtract();
      push(p2);
      push_rational(1, 2);
      multiply();
      power();
      return;
    }
    if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {
      push_integer(1);
      push(cadr(p1));
      sine();
      push_integer(2);
      power();
      subtract();
      push(p2);
      push_rational(1, 2);
      multiply();
      power();
      return;
    }
    if (iscomplexnumber(p1)) {
      if (isinteger(p2)) {
        push(p1);
        conjugate();
        p3 = pop();
        push(p3);
        push(p3);
        push(p1);
        multiply();
        divide();
        push(p2);
        negate();
        power();
        return;
      }
      if (isnum(p2)) {
        push(p1);
        mag();
        push(p2);
        power();
        push_integer(-1);
        push(p1);
        arg();
        push(p2);
        multiply();
        push(symbol(PI));
        divide();
        power();
        multiply();
        return;

        /*
        			push(p1)
        			mag()
        			push(p2)
        			power()
        			push(symbol(E))
        			push(p1)
        			arg()
        			push(p2)
        			multiply()
        			push(imaginaryunit)
        			multiply()
        			power()
        			multiply()
         */
      }
    }
    if (simplify_polar()) {
      return;
    }
    push_symbol(POWER);
    push(p1);
    push(p2);
    return list(3);
  };

  power_sum = function(n) {
    var a, i, j, k, _j, _k, _l;
    a = [];
    i = 0;
    j = 0;
    k = 0;
    k = length(p1) - 1;
    push_frame(k * (n + 1));
    p1 = cdr(p1);
    for (i = _j = 0; 0 <= k ? _j < k : _j > k; i = 0 <= k ? ++_j : --_j) {
      for (j = _k = 0; 0 <= n ? _k <= n : _k >= n; j = 0 <= n ? ++_k : --_k) {
        push(car(p1));
        push_integer(j);
        power();
        stack[frame + i * (n + 1) + j] = pop();
      }
      p1 = cdr(p1);
    }
    push_integer(n);
    factorial();
    p1 = pop();
    for (i = _l = 0; 0 <= k ? _l < k : _l > k; i = 0 <= k ? ++_l : --_l) {
      a[i] = 0;
    }
    push(zero);
    multinomial_sum(k, n, a, 0, n);
    return pop_frame(k * (n + 1));
  };

  multinomial_sum = function(k, n, a, i, m) {
    var j, _j, _k, _l;
    j = 0;
    if (i < k - 1) {
      for (j = _j = 0; 0 <= m ? _j <= m : _j >= m; j = 0 <= m ? ++_j : --_j) {
        a[i] = j;
        multinomial_sum(k, n, a, i + 1, m - j);
      }
      return;
    }
    a[i] = m;
    push(p1);
    for (j = _k = 0; 0 <= k ? _k < k : _k > k; j = 0 <= k ? ++_k : --_k) {
      push_integer(a[j]);
      factorial();
      divide();
    }
    for (j = _l = 0; 0 <= k ? _l < k : _l > k; j = 0 <= k ? ++_l : --_l) {
      push(stack[frame + j * (n + 1) + a[j]]);
      multiply();
    }
    return add();
  };

  simplify_polar = function() {
    var doNothing, n;
    n = 0;
    n = isquarterturn(p2);
    switch (n) {
      case 0:
        doNothing = 1;
        break;
      case 1:
        push_integer(1);
        return 1;
      case 2:
        push_integer(-1);
        return 1;
      case 3:
        push(imaginaryunit);
        return 1;
      case 4:
        push(imaginaryunit);
        negate();
        return 1;
    }
    if (car(p2) === symbol(ADD)) {
      p3 = cdr(p2);
      while (iscons(p3)) {
        n = isquarterturn(car(p3));
        if (n) {
          break;
        }
        p3 = cdr(p3);
      }
      switch (n) {
        case 0:
          return 0;
        case 1:
          push_integer(1);
          break;
        case 2:
          push_integer(-1);
          break;
        case 3:
          push(imaginaryunit);
          break;
        case 4:
          push(imaginaryunit);
          negate();
      }
      push(p2);
      push(car(p3));
      subtract();
      exponential();
      multiply();
      return 1;
    }
    return 0;
  };

  Eval_prime = function() {
    push(cadr(p1));
    Eval();
    return prime();
  };

  prime = function() {
    var n;
    n = 0;
    n = pop_integer();
    if (n < 1 || n > MAXPRIMETAB) {
      stop("prime: Argument out of range.");
    }
    n = primetab[n - 1];
    return push_integer(n);
  };

  power_str = "^";

  stringToBePrinted = "";

  print_str = function(s) {
    return stringToBePrinted += s;
  };

  print_char = function(c) {
    return stringToBePrinted += c;
  };

  collectResultLine = function(p) {
    stringToBePrinted = "";
    print_expr(p);
    return stringToBePrinted;
  };

  printline = function(p) {
    stringToBePrinted = "";
    print_expr(p);
    return console.log(stringToBePrinted);
  };

  print_denom = function(p, d) {
    save();
    p1 = cadr(p);
    p2 = caddr(p);
    if (d === 1 && !isminusone(p2)) {
      print_char('(');
    }
    if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) {
      print_char('(');
      print_expr(p1);
      print_char(')');
    } else {
      print_expr(p1);
    }
    if (isminusone(p2)) {
      restore();
      return;
    }
    if (test_flag === 0) {
      print_str(power_str);
    } else {
      print_char('^');
    }
    push(p2);
    negate();
    p2 = pop();
    if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) {
      print_char('(');
      print_expr(p2);
      print_char(')');
    } else {
      print_expr(p2);
    }
    if (d === 1) {
      print_char(')');
    }
    return restore();
  };

  print_a_over_b = function(p) {
    var d, doNothing, n;
    flag = 0;
    n = 0;
    d = 0;
    save();
    n = 0;
    d = 0;
    p1 = cdr(p);
    p2 = car(p1);
    if (isrational(p2)) {
      push(p2);
      mp_numerator();
      absval();
      p3 = pop();
      push(p2);
      mp_denominator();
      p4 = pop();
      if (!isplusone(p3)) {
        n++;
      }
      if (!isplusone(p4)) {
        d++;
      }
      p1 = cdr(p1);
    } else {
      p3 = one;
      p4 = one;
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (is_denominator(p2)) {
        d++;
      } else {
        n++;
      }
      p1 = cdr(p1);
    }
    if (n === 0) {
      print_char('1');
    } else {
      flag = 0;
      p1 = cdr(p);
      if (isrational(car(p1))) {
        p1 = cdr(p1);
      }
      if (!isplusone(p3)) {
        print_factor(p3);
        flag = 1;
      }
      while (iscons(p1)) {
        p2 = car(p1);
        if (is_denominator(p2)) {
          doNothing = 1;
        } else {
          if (flag) {
            print_multiply_sign();
          }
          print_factor(p2);
          flag = 1;
        }
        p1 = cdr(p1);
      }
    }
    if (test_flag === 0) {
      print_str(" / ");
    } else {
      print_str("/");
    }
    if (d > 1) {
      print_char('(');
    }
    flag = 0;
    p1 = cdr(p);
    if (isrational(car(p1))) {
      p1 = cdr(p1);
    }
    if (!isplusone(p4)) {
      print_factor(p4);
      flag = 1;
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (is_denominator(p2)) {
        if (flag) {
          print_multiply_sign();
        }
        print_denom(p2, d);
        flag = 1;
      }
      p1 = cdr(p1);
    }
    if (d > 1) {
      print_char(')');
    }
    return restore();
  };

  print_expr = function(p) {
    var _results;
    if (isadd(p)) {
      p = cdr(p);
      if (sign_of_term(car(p)) === '-') {
        print_str("-");
      }
      print_term(car(p));
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        if (sign_of_term(car(p)) === '+') {
          if (test_flag === 0) {
            print_str(" + ");
          } else {
            print_str("+");
          }
        } else {
          if (test_flag === 0) {
            print_str(" - ");
          } else {
            print_str("-");
          }
        }
        print_term(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    } else {
      if (sign_of_term(p) === '-') {
        print_str("-");
      }
      return print_term(p);
    }
  };

  sign_of_term = function(p) {
    if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && lessp(cadr(p), zero)) {
      return '-';
    } else if (isnum(p) && lessp(p, zero)) {
      return '-';
    } else {
      return '+';
    }
  };

  print_term = function(p) {
    var _results;
    if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {
      print_a_over_b(p);
      return;
    }
    if (car(p) === symbol(MULTIPLY)) {
      p = cdr(p);
      if (isminusone(car(p))) {
        p = cdr(p);
      }
      print_factor(car(p));
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        print_multiply_sign();
        print_factor(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    } else {
      return print_factor(p);
    }
  };

  print_subexpr = function(p) {
    print_char('(');
    print_expr(p);
    return print_char(')');
  };

  print_factorial_function = function(p) {
    p = cadr(p);
    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {
      print_subexpr(p);
    } else {
      print_expr(p);
    }
    return print_char('!');
  };

  print_tensor = function(p) {
    return print_tensor_inner(p, 0, 0);
  };

  print_tensor_inner = function(p, j, k) {
    var i, _j, _ref;
    i = 0;
    print_str("(");
    for (i = _j = 0, _ref = p.tensor.dim[j]; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      if (j + 1 === p.tensor.ndim) {
        print_expr(p.tensor.elem[k]);
        k++;
      } else {
        k = print_tensor_inner(p, j + 1, k);
      }
      if (i + 1 < p.tensor.dim[j]) {
        if (test_flag === 0) {
          print_str(",");
        } else {
          print_str(",");
        }
      }
    }
    print_str(")");
    return k;
  };

  print_factor = function(p) {
    if (isnum(p)) {
      print_number(p);
      return;
    }
    if (isstr(p)) {
      print_str(p.str);
      return;
    }
    if (istensor(p)) {
      print_tensor(p);
      return;
    }
    if (isadd(p) || car(p) === symbol(MULTIPLY)) {
      print_str("(");
      print_expr(p);
      print_str(")");
      return;
    }
    if (car(p) === symbol(POWER)) {
      if (cadr(p) === symbol(E)) {
        print_str("exp(");
        print_expr(caddr(p));
        print_str(")");
        return;
      }
      if (isminusone(caddr(p))) {
        if (test_flag === 0) {
          print_str("1 / ");
        } else {
          print_str("1/");
        }
        if (iscons(cadr(p))) {
          print_str("(");
          print_expr(cadr(p));
          print_str(")");
        } else {
          print_expr(cadr(p));
        }
        return;
      }
      if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {
        print_str("(");
        print_expr(cadr(p));
        print_str(")");
      } else if (isnum(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {
        print_str("(");
        print_factor(cadr(p));
        print_str(")");
      } else {
        print_factor(cadr(p));
      }
      if (test_flag === 0) {
        print_str(power_str);
      } else {
        print_str("^");
      }
      if (iscons(caddr(p)) || isfraction(caddr(p)) || (isnum(caddr(p)) && lessp(caddr(p), zero))) {
        print_str("(");
        print_expr(caddr(p));
        print_str(")");
      } else {
        print_factor(caddr(p));
      }
      return;
    }
    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {
      print_index_function(p);
      return;
    }
    if (car(p) === symbol(FACTORIAL)) {
      print_factorial_function(p);
      return;
    }
    if (iscons(p)) {
      print_factor(car(p));
      p = cdr(p);
      print_str("(");
      if (iscons(p)) {
        print_expr(car(p));
        p = cdr(p);
        while (iscons(p)) {
          if (test_flag === 0) {
            print_str(",");
          } else {
            print_str(",");
          }
          print_expr(car(p));
          p = cdr(p);
        }
      }
      print_str(")");
      return;
    }
    if (p === symbol(DERIVATIVE)) {
      return print_char('d');
    } else if (p === symbol(E)) {
      return print_str("exp(1)");
    } else if (p === symbol(PI)) {
      return print_str("pi");
    } else {
      return print_str(get_printname(p));
    }
  };

  print1 = function(p, accumulator) {
    var topLevelCall;
    topLevelCall = false;
    if (accumulator == null) {
      topLevelCall = true;
      accumulator = "";
    }
    switch (p.k) {
      case CONS:
        accumulator += "(";
        accumulator = print1(car(p), accumulator);
        if (p === cdr(p)) {
          console.log("oh no recursive!");
          debugger;
        }
        p = cdr(p);
        while (iscons(p)) {
          accumulator += " ";
          accumulator = print1(car(p), accumulator);
          p = cdr(p);
          if (p === cdr(p)) {
            console.log("oh no recursive!");
            debugger;
          }
        }
        if (p !== symbol(NIL)) {
          accumulator += " . ";
          accumulator = print1(p, accumulator);
        }
        accumulator += ")";
        break;
      case STR:
        accumulator += p.str;
        break;
      case NUM:
      case DOUBLE:
        accumulator = print_number(p, accumulator);
        break;
      case SYM:
        accumulator += get_printname(p);
        break;
      default:
        accumulator += "<tensor>";
    }
    if (topLevelCall) {
      return console.log(accumulator);
    } else {
      return accumulator;
    }
  };

  print_multiply_sign = function() {
    if (test_flag === 0) {
      return print_str(" ");
    } else {
      return print_str("*");
    }
  };

  is_denominator = function(p) {
    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  any_denominators = function(p) {
    var q;
    p = cdr(p);
    while (iscons(p)) {
      q = car(p);
      if (is_denominator(q)) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  };

  Eval_product = function() {
    var i, j, k, _j;
    i = 0;
    j = 0;
    k = 0;
    p6 = cadr(p1);
    if (!issymbol(p6)) {
      stop("product: 1st arg?");
    }
    push(caddr(p1));
    Eval();
    j = pop_integer();
    if (j === 0x80000000) {
      stop("product: 2nd arg?");
    }
    push(cadddr(p1));
    Eval();
    k = pop_integer();
    if (k === 0x80000000) {
      stop("product: 3rd arg?");
    }
    p1 = caddddr(p1);
    p4 = get_binding(p6);
    p3 = get_arglist(p6);
    push_integer(1);
    for (i = _j = j; j <= k ? _j <= k : _j >= k; i = j <= k ? ++_j : --_j) {
      push_integer(i);
      p5 = pop();
      set_binding(p6, p5);
      push(p1);
      Eval();
      multiply();
    }
    return set_binding_and_arglist(p6, p4, p3);
  };

  qadd = function() {
    var a, ab, b, ba, c;
    save();
    p2 = pop();
    p1 = pop();
    ab = mmul(p1.q.a, p2.q.b);
    ba = mmul(p1.q.b, p2.q.a);
    a = madd(ab, ba);
    if (MZERO(a)) {
      push(zero);
      restore();
      return;
    }
    b = mmul(p1.q.b, p2.q.b);
    c = mgcd(a, b);
    c = makeSignSameAs(c, b);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = mdiv(a, c);
    p1.q.b = mdiv(b, c);
    push(p1);
    return restore();
  };

  qdiv = function() {
    var aa, bb, c;
    save();
    p2 = pop();
    p1 = pop();
    if (MZERO(p2.q.a)) {
      stop("divide by zero");
    }
    if (MZERO(p1.q.a)) {
      push(zero);
      restore();
      return;
    }
    aa = mmul(p1.q.a, p2.q.b);
    bb = mmul(p1.q.b, p2.q.a);
    c = mgcd(aa, bb);
    c = makeSignSameAs(c, bb);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = mdiv(aa, c);
    p1.q.b = mdiv(bb, c);
    push(p1);
    return restore();
  };

  qmul = function() {
    var aa, bb, c;
    save();
    p2 = pop();
    p1 = pop();
    if (MZERO(p1.q.a) || MZERO(p2.q.a)) {
      push(zero);
      restore();
      return;
    }
    aa = mmul(p1.q.a, p2.q.a);
    bb = mmul(p1.q.b, p2.q.b);
    c = mgcd(aa, bb);
    c = makeSignSameAs(c, bb);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = mdiv(aa, c);
    p1.q.b = mdiv(bb, c);
    push(p1);
    return restore();
  };

  qpow = function() {
    save();
    qpowf();
    return restore();
  };

  qpowf = function() {
    var a, b, expo, t, x, y;
    expo = 0;
    p2 = pop();
    p1 = pop();
    if (isplusone(p1) || iszero(p2)) {
      push_integer(1);
      return;
    }
    if (iszero(p1)) {
      if (isnegativenumber(p2)) {
        stop("divide by zero");
      }
      push(zero);
      return;
    }
    if (isplusone(p2)) {
      push(p1);
      return;
    }
    if (isinteger(p2)) {
      push(p2);
      expo = pop_integer();
      if (expo === 0x80000000) {
        push_symbol(POWER);
        push(p1);
        push(p2);
        list(3);
        return;
      }
      x = mpow(p1.q.a, Math.abs(expo));
      y = mpow(p1.q.b, Math.abs(expo));
      if (expo < 0) {
        t = x;
        x = y;
        y = t;
        x = makeSignSameAs(x, y);
        y = makePositive(y);
      }
      p3 = new U();
      p3.k = NUM;
      p3.q.a = x;
      p3.q.b = y;
      push(p3);
      return;
    }
    if (isminusone(p1)) {
      push(p2);
      normalize_angle();
      return;
    }
    if (isnegativenumber(p1)) {
      push(p1);
      negate();
      push(p2);
      qpow();
      push_integer(-1);
      push(p2);
      qpow();
      multiply();
      return;
    }
    if (!isinteger(p1)) {
      push(p1);
      mp_numerator();
      push(p2);
      qpow();
      push(p1);
      mp_denominator();
      push(p2);
      negate();
      qpow();
      multiply();
      return;
    }
    if (is_small_integer(p1)) {
      push(p1);
      push(p2);
      quickfactor();
      return;
    }
    if (!p2.q.a.isSmall || !p2.q.b.isSmall) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    a = p2.q.a;
    b = p2.q.b;
    x = mroot(p1.q.a, b);
    if (x === 0) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    y = mpow(x, a);
    p3 = new U();
    p3.k = NUM;
    if (p2.q.a.isNegative()) {
      p3.q.a = bigInt(1);
      p3.q.b = y;
    } else {
      p3.q.a = y;
      p3.q.b = bigInt(1);
    }
    return push(p3);
  };

  normalize_angle = function() {
    save();
    p1 = pop();
    if (isinteger(p1)) {
      if (p1.q.a.isOdd()) {
        push_integer(-1);
      } else {
        push_integer(1);
      }
      restore();
      return;
    }
    push(p1);
    bignum_truncate();
    p2 = pop();
    if (isnegativenumber(p1)) {
      push(p2);
      push_integer(-1);
      add();
      p2 = pop();
    }
    push(p1);
    push(p2);
    subtract();
    p3 = pop();
    push_symbol(POWER);
    push_integer(-1);
    push(p3);
    list(3);
    if (p2.q.a.isOdd()) {
      negate();
    }
    return restore();
  };

  is_small_integer = function(p) {
    return p.q.a.isSmall;
  };

  quickfactor = function() {
    var h, i, n, stackIndex, _j;
    i = 0;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    push(p1);
    factor_small_number();
    n = tos - h;
    stackIndex = h;
    for (i = _j = 0; _j < n; i = _j += 2) {
      push(stack[stackIndex + i]);
      push(stack[stackIndex + i + 1]);
      push(p2);
      multiply();
      quickpower();
    }
    multiply_all(tos - h - n);
    p1 = pop();
    tos = h;
    push(p1);
    return restore();
  };

  quickpower = function() {
    var expo;
    expo = 0;
    save();
    p2 = pop();
    p1 = pop();
    push(p2);
    bignum_truncate();
    p3 = pop();
    push(p2);
    push(p3);
    subtract();
    p4 = pop();
    if (!iszero(p4)) {
      push_symbol(POWER);
      push(p1);
      push(p4);
      list(3);
    }
    push(p3);
    expo = pop_integer();
    if (expo === 0x80000000) {
      push_symbol(POWER);
      push(p1);
      push(p3);
      list(3);
      restore();
      return;
    }
    if (expo === 0) {
      restore();
      return;
    }
    push(p1);
    bignum_power_number(expo);
    return restore();
  };

  Eval_quotient = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    p1 = pop();
    if (p1 === symbol(NIL)) {
      p1 = symbol(SYMBOL_X);
    }
    push(p1);
    return divpoly();
  };

  divpoly = function() {
    var dividend, divisor, h, i, m, n, x, _j;
    h = 0;
    i = 0;
    m = 0;
    n = 0;
    x = 0;
    save();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    h = tos;
    dividend = tos;
    push(p1);
    push(p3);
    m = coeff() - 1;
    divisor = tos;
    push(p2);
    push(p3);
    n = coeff() - 1;
    x = m - n;
    push_integer(0);
    p5 = pop();
    while (x >= 0) {
      push(stack[dividend + m]);
      push(stack[divisor + n]);
      divide();
      p4 = pop();
      for (i = _j = 0; 0 <= n ? _j <= n : _j >= n; i = 0 <= n ? ++_j : --_j) {
        push(stack[dividend + x + i]);
        push(stack[divisor + i]);
        push(p4);
        multiply();
        subtract();
        stack[dividend + x + i] = pop();
      }
      push(p5);
      push(p4);
      push(p3);
      push_integer(x);
      power();
      multiply();
      add();
      p5 = pop();
      m--;
      x--;
    }
    tos = h;
    push(p5);
    return restore();
  };

  DEBUG = 0;

  Eval_rationalize = function() {
    push(cadr(p1));
    Eval();
    return rationalize();
  };

  rationalize = function() {
    var x;
    x = expanding;
    save();
    yyrationalize();
    restore();
    return expanding = x;
  };

  yyrationalize = function() {
    p1 = pop();
    if (istensor(p1)) {
      __rationalize_tensor();
      return;
    }
    expanding = 0;
    if (car(p1) !== symbol(ADD)) {
      push(p1);
      return;
    }
    if (DEBUG) {
      printf("rationalize: this is the input expr:\n");
      printline(p1);
    }
    push(one);
    multiply_denominators(p1);
    p2 = pop();
    if (DEBUG) {
      printf("rationalize: this is the common denominator:\n");
      printline(p2);
    }
    push(zero);
    p3 = cdr(p1);
    while (iscons(p3)) {
      push(p2);
      push(car(p3));
      multiply();
      add();
      p3 = cdr(p3);
    }
    if (DEBUG) {
      printf("rationalize: original expr times common denominator:\n");
      printline(stack[tos - 1]);
    }
    Condense();
    if (DEBUG) {
      printf("rationalize: after factoring:\n");
      printline(stack[tos - 1]);
    }
    push(p2);
    divide();
    if (DEBUG) {
      printf("rationalize: after dividing by common denom. (and we're done):\n");
      return printline(stack[tos - 1]);
    }
  };

  multiply_denominators = function(p) {
    var _results;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        multiply_denominators_term(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    } else {
      return multiply_denominators_term(p);
    }
  };

  multiply_denominators_term = function(p) {
    var _results;
    if (car(p) === symbol(MULTIPLY)) {
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        multiply_denominators_factor(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    } else {
      return multiply_denominators_factor(p);
    }
  };

  multiply_denominators_factor = function(p) {
    if (car(p) !== symbol(POWER)) {
      return;
    }
    push(p);
    p = caddr(p);
    if (isnegativenumber(p)) {
      inverse();
      __lcm();
      return;
    }
    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
      inverse();
      __lcm();
      return;
    }
    return pop();
  };

  __rationalize_tensor = function() {
    var i, n, _j;
    i = 0;
    push(p1);
    Eval();
    p1 = pop();
    if (!istensor(p1)) {
      push(p1);
      return;
    }
    n = p1.tensor.nelem;
    for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
      push(p1.tensor.elem[i]);
      rationalize();
      p1.tensor.elem[i] = pop();
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    return push(p1);
  };

  __lcm = function() {
    save();
    p1 = pop();
    p2 = pop();
    push(p1);
    push(p2);
    multiply();
    push(p1);
    push(p2);
    gcd();
    divide();
    return restore();
  };


  /*
   Returns the real part of complex z
  
  	z		real(z)
  	-		-------
  
  	a + i b		a
  
  	exp(i a)	cos(a)
   */

  Eval_real = function() {
    push(cadr(p1));
    Eval();
    return real();
  };

  real = function() {
    save();
    rect();
    p1 = pop();
    push(p1);
    push(p1);
    conjugate();
    add();
    push_integer(2);
    divide();
    return restore();
  };


  /*
  Convert complex z to rectangular form
  
  	Input:		push	z
  
  	Output:		Result on stack
   */

  Eval_rect = function() {
    push(cadr(p1));
    Eval();
    return rect();
  };

  rect = function() {
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      push_integer(0);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        rect();
        add();
        p1 = cdr(p1);
      }
    } else {
      push(p1);
      mag();
      push(p1);
      arg();
      p1 = pop();
      push(p1);
      cosine();
      push(imaginaryunit);
      push(p1);
      sine();
      multiply();
      add();
      multiply();
    }
    return restore();
  };

  Eval_roots = function() {
    p2 = cadr(p1);
    if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {
      push(cadr(p2));
      Eval();
      push(caddr(p2));
      Eval();
      subtract();
    } else {
      push(p2);
      Eval();
      p2 = pop();
      if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {
        push(cadr(p2));
        Eval();
        push(caddr(p2));
        Eval();
        subtract();
      } else {
        push(p2);
      }
    }
    push(caddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    p2 = pop();
    p1 = pop();
    if (!ispoly(p1, p2)) {
      stop("roots: 1st argument is not a polynomial");
    }
    push(p1);
    push(p2);
    return roots();
  };

  roots = function() {
    var h, i, n, _j;
    h = 0;
    i = 0;
    n = 0;
    h = tos - 2;
    roots2();
    n = tos - h;
    if (n === 0) {
      stop("roots: the polynomial is not factorable, try nroots");
    }
    if (n === 1) {
      return;
    }
    sort_stack(n);
    save();
    p1 = alloc_tensor(n);
    p1.tensor.ndim = 1;
    p1.tensor.dim[0] = n;
    for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
      p1.tensor.elem[i] = stack[h + i];
    }
    tos = h;
    push(p1);
    return restore();
  };

  roots2 = function() {
    save();
    p2 = pop();
    p1 = pop();
    push(p1);
    push(p2);
    factorpoly();
    p1 = pop();
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        roots3();
        p1 = cdr(p1);
      }
    } else {
      push(p1);
      push(p2);
      roots3();
    }
    return restore();
  };

  roots3 = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (car(p1) === symbol(POWER) && ispoly(cadr(p1), p2) && isposint(caddr(p1))) {
      push(cadr(p1));
      push(p2);
      mini_solve();
    } else if (ispoly(p1, p2)) {
      push(p1);
      push(p2);
      mini_solve();
    }
    return restore();
  };

  mini_solve = function() {
    var n;
    n = 0;
    save();
    p2 = pop();
    p1 = pop();
    push(p1);
    push(p2);
    n = coeff();
    if (n === 2) {
      p3 = pop();
      p4 = pop();
      push(p4);
      push(p3);
      divide();
      negate();
      restore();
      return;
    }
    if (n === 3) {
      p3 = pop();
      p4 = pop();
      p5 = pop();
      push(p4);
      push(p4);
      multiply();
      push_integer(4);
      push(p3);
      multiply();
      push(p5);
      multiply();
      subtract();
      push_rational(1, 2);
      power();
      p6 = pop();
      push(p6);
      push(p4);
      subtract();
      push(p3);
      divide();
      push_rational(1, 2);
      multiply();
      push(p6);
      push(p4);
      add();
      negate();
      push(p3);
      divide();
      push_rational(1, 2);
      multiply();
      restore();
      return;
    }
    tos -= n;
    return restore();
  };

  T_INTEGER = 1001;

  T_DOUBLE = 1002;

  T_SYMBOL = 1003;

  T_FUNCTION = 1004;

  T_NEWLINE = 1006;

  T_STRING = 1007;

  T_GTEQ = 1008;

  T_LTEQ = 1009;

  T_EQ = 1010;

  token = "";

  newline_flag = 0;

  meta_mode = 0;

  input_str = 0;

  scan_str = 0;

  token_str = 0;

  token_buf = 0;

  scanned = "";

  scan = function(s) {
    if (DEBUG) {
      console.log("#### scanning " + s);
    }
    scanned = s;
    meta_mode = 0;
    expanding++;
    input_str = 0;
    scan_str = 0;
    get_next_token();
    if (token === "") {
      push(symbol(NIL));
      expanding--;
      return 0;
    }
    scan_stmt();
    expanding--;
    return token_str - input_str;
  };

  scan_meta = function(s) {
    scanned = s;
    meta_mode = 1;
    expanding++;
    input_str = 0;
    scan_str = 0;
    get_next_token();
    if (token === "") {
      push(symbol(NIL));
      expanding--;
      return 0;
    }
    scan_stmt();
    expanding--;
    return token_str - input_str;
  };

  scan_stmt = function() {
    scan_relation();
    if (token === '=') {
      get_next_token();
      push_symbol(SETQ);
      swap();
      scan_relation();
      return list(3);
    }
  };

  scan_relation = function() {
    scan_expression();
    switch (token) {
      case T_EQ:
        push_symbol(TESTEQ);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
      case T_LTEQ:
        push_symbol(TESTLE);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
      case T_GTEQ:
        push_symbol(TESTGE);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
      case '<':
        push_symbol(TESTLT);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
      case '>':
        push_symbol(TESTGT);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
    }
  };

  scan_expression = function() {
    var h;
    h = tos;
    switch (token) {
      case '+':
        get_next_token();
        scan_term();
        break;
      case '-':
        get_next_token();
        scan_term();
        negate();
        break;
      default:
        scan_term();
    }
    while (newline_flag === 0 && (token === '+' || token === '-')) {
      if (token === '+') {
        get_next_token();
        scan_term();
      } else {
        get_next_token();
        scan_term();
        negate();
      }
    }
    if (tos - h > 1) {
      list(tos - h);
      push_symbol(ADD);
      swap();
      return cons();
    }
  };

  is_factor = function() {
    switch (token) {
      case '*':
      case '/':
        return 1;
      case '(':
      case T_SYMBOL:
      case T_FUNCTION:
      case T_INTEGER:
      case T_DOUBLE:
      case T_STRING:
        if (newline_flag) {
          scan_str = token_str;
          return 0;
        } else {
          return 1;
        }
    }
    return 0;
  };

  scan_term = function() {
    var h;
    h = tos;
    scan_power();
    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
      pop();
    }
    while (is_factor()) {
      if (token === '*') {
        get_next_token();
        scan_power();
      } else if (token === '/') {
        get_next_token();
        scan_power();
        inverse();
      } else {
        scan_power();
      }
      if (tos > h + 1 && isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
        multiply();
      }
      if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
        pop();
      }
    }
    if (h === tos) {
      return push_integer(1);
    } else if (tos - h > 1) {
      list(tos - h);
      push_symbol(MULTIPLY);
      swap();
      return cons();
    }
  };

  scan_power = function() {
    scan_factor();
    if (token === '^') {
      get_next_token();
      push_symbol(POWER);
      swap();
      scan_power();
      return list(3);
    }
  };

  scan_factor = function() {
    var h, _results;
    h = tos;
    if (token === '(') {
      scan_subexpr();
    } else if (token === T_SYMBOL) {
      scan_symbol();
    } else if (token === T_FUNCTION) {
      scan_function_call();
    } else if (token === T_INTEGER) {
      bignum_scan_integer(token_buf);
      get_next_token();
    } else if (token === T_DOUBLE) {
      bignum_scan_float(token_buf);
      get_next_token();
    } else if (token === T_STRING) {
      scan_string();
    } else {
      scan_error("syntax error");
    }
    if (token === '[') {
      get_next_token();
      push_symbol(INDEX);
      swap();
      scan_expression();
      while (token === ',') {
        get_next_token();
        scan_expression();
      }
      if (token !== ']') {
        scan_error("] expected");
      }
      get_next_token();
      list(tos - h);
    }
    _results = [];
    while (token === '!') {
      get_next_token();
      push_symbol(FACTORIAL);
      swap();
      _results.push(list(2));
    }
    return _results;
  };

  scan_symbol = function() {
    if (token !== T_SYMBOL) {
      scan_error("symbol expected");
    }
    if (meta_mode && token_buf.length === 1) {
      switch (token_buf[0]) {
        case 'a':
          push(symbol(METAA));
          break;
        case 'b':
          push(symbol(METAB));
          break;
        case 'x':
          push(symbol(METAX));
          break;
        default:
          push(usr_symbol(token_buf));
      }
    } else {
      push(usr_symbol(token_buf));
    }
    return get_next_token();
  };

  scan_string = function() {
    new_string(token_buf);
    return get_next_token();
  };

  scan_function_call = function() {
    var n, p;
    n = 1;
    p = new U();
    p = usr_symbol(token_buf);
    push(p);
    get_next_token();
    get_next_token();
    if (token !== ')') {
      scan_stmt();
      n++;
      while (token === ',') {
        get_next_token();
        scan_stmt();
        n++;
      }
    }
    if (token !== ')') {
      scan_error(") expected");
    }
    get_next_token();
    return list(n);
  };

  scan_subexpr = function() {
    var n;
    n = 0;
    if (token !== '(') {
      scan_error("( expected");
    }
    get_next_token();
    scan_stmt();
    if (token === ',') {
      n = 1;
      while (token === ',') {
        get_next_token();
        scan_stmt();
        n++;
      }
      build_tensor(n);
    }
    if (token !== ')') {
      scan_error(") expected");
    }
    return get_next_token();
  };

  scan_error = function(errmsg) {
    errorMessage = "";
    while (input_str !== scan_str) {
      if ((scanned[input_str] === '\n' || scanned[input_str] === '\r') && input_str + 1 === scan_str) {
        break;
      }
      errorMessage += scanned[input_str++];
    }
    errorMessage += " ? ";
    while (scanned[input_str] && (scanned[input_str] !== '\n' && scanned[input_str] !== '\r')) {
      errorMessage += scanned[input_str++];
    }
    errorMessage += '\n';
    return stop(errmsg);
  };

  build_tensor = function(n) {
    var i, _j;
    i = 0;
    save();
    p2 = alloc_tensor(n);
    p2.tensor.ndim = 1;
    p2.tensor.dim[0] = n;
    for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
      p2.tensor.elem[i] = stack[tos - n + i];
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    tos -= n;
    push(p2);
    return restore();
  };

  get_next_token = function() {
    newline_flag = 0;
    while (1.) {
      get_token();
      if (token !== T_NEWLINE) {
        break;
      }
      newline_flag = 1;
    }
    if (DEBUG) {
      return console.log("get_next_token token: " + token);
    }
  };

  get_token = function() {
    while (isspace(scanned[scan_str])) {
      if (scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
        token = T_NEWLINE;
        scan_str++;
        return;
      }
      scan_str++;
    }
    token_str = scan_str;
    if (scan_str === scanned.length) {
      token = "";
      return;
    }
    if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {
      while (isdigit(scanned[scan_str])) {
        scan_str++;
      }
      if (scanned[scan_str] === '.') {
        scan_str++;
        while (isdigit(scanned[scan_str])) {
          scan_str++;
        }
        if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {
          scan_str += 2;
          while (isdigit(scanned[scan_str])) {
            scan_str++;
          }
        }
        token = T_DOUBLE;
      } else {
        token = T_INTEGER;
      }
      update_token_buf(token_str, scan_str);
      return;
    }
    if (isalpha(scanned[scan_str])) {
      while (isalnum(scanned[scan_str])) {
        scan_str++;
      }
      if (scanned[scan_str] === '(') {
        token = T_FUNCTION;
      } else {
        token = T_SYMBOL;
      }
      update_token_buf(token_str, scan_str);
      return;
    }
    if (scanned[scan_str] === '"') {
      scan_str++;
      while (scanned[scan_str] !== '"') {
        if (scan_str === scanned.length || scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
          scan_error("runaway string");
        }
        scan_str++;
      }
      scan_str++;
      token = T_STRING;
      update_token_buf(token_str + 1, scan_str - 1);
      return;
    }
    if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {
      while (scanned[scan_str] && scanned[scan_str] !== '\n' && scanned[scan_str] !== '\r') {
        scan_str++;
      }
      if (scanned[scan_str]) {
        scan_str++;
      }
      token = T_NEWLINE;
      return;
    }
    if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {
      scan_str += 2;
      token = T_EQ;
      return;
    }
    if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {
      scan_str += 2;
      token = T_LTEQ;
      return;
    }
    if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {
      scan_str += 2;
      token = T_GTEQ;
      return;
    }
    return token = scanned[scan_str++];
  };

  update_token_buf = function(a, b) {
    return token_buf = scanned.substring(a, b);
  };

  $.scan = scan;

  Eval_sgn = function() {
    push(cadr(p1));
    Eval();
    return sgn();
  };

  sgn = function() {
    save();
    yysgn();
    return restore();
  };

  yysgn = function() {
    p1 = pop();
    if (isdouble(p1)) {
      if (p1.d > 0) {
        push_integer(1);
        return;
      } else {
        if (p1.d === 0) {
          push_integer(1);
          return;
        } else {
          push_integer(-1);
          return;
        }
      }
    }
    if (isrational(p1)) {
      if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {
        push_integer(-1);
        return;
      } else {
        if (MZERO(mmul(p1.q.a, p1.q.b))) {
          push_integer(0);
          return;
        } else {
          push_integer(1);
          return;
        }
      }
    }
    if (iscomplexnumber(p1)) {
      push_integer(-1);
      push(p1);
      absval();
      power();
      push(p1);
      multiply();
      return;
    }
    if (isnegativeterm(p1)) {
      push_symbol(SGN);
      push(p1);
      negate();
      list(2);
      push_integer(-1);
      multiply();
      return;
    }

    /*
    	push_integer(2)
    	push(p1)
    	heaviside()
    	multiply()
    	push_integer(-1)
    	add()
     */
    push_symbol(SGN);
    push(p1);
    return list(2);
  };


  /*
   Simplify factorials
  
  The following script
  
  	F(n,k) = k binomial(n,k)
  	(F(n,k) + F(n,k-1)) / F(n+1,k)
  
  generates
  
         k! n!             n! (1 - k + n)!              k! n!
   -------------------- + -------------------- - ----------------------
   (-1 + k)! (1 + n)!     (1 + n)! (-k + n)!     k (-1 + k)! (1 + n)!
  
  Simplify each term to get
  
     k       1 - k + n       1
  ------- + ----------- - -------
   1 + n       1 + n       1 + n
  
  Then simplify the sum to get
  
     n
  -------
   1 + n
   */

  Eval_simfac = function() {
    push(cadr(p1));
    Eval();
    return simfac();
  };

  simfac = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      h = tos;
      p1 = cdr(p1);
      while (p1 !== symbol(NIL)) {
        push(car(p1));
        simfac_term();
        p1 = cdr(p1);
      }
      add_all(tos - h);
    } else {
      push(p1);
      simfac_term();
    }
    return restore();
  };


  /*
  void
  simfac(void)
  {
  	int h
  	save()
  	p1 = pop()
  	if (car(p1) == symbol(ADD)) {
  		h = tos
  		p1 = cdr(p1)
  		while (p1 != symbol(NIL)) {
  			push(car(p1))
  			simfac_term()
  			p1 = cdr(p1)
  		}
  		addk(tos - h)
  		p1 = pop()
  		if (find(p1, symbol(FACTORIAL))) {
  			push(p1)
  			if (car(p1) == symbol(ADD)) {
  				Condense()
  				simfac_term()
  			}
  		}
  	} else {
  		push(p1)
  		simfac_term()
  	}
  	restore()
  }
  
  #endif
   */

  simfac_term = function() {
    var doNothing, h;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) !== symbol(MULTIPLY)) {
      push(p1);
      restore();
      return;
    }
    h = tos;
    p1 = cdr(p1);
    while (p1 !== symbol(NIL)) {
      push(car(p1));
      p1 = cdr(p1);
    }
    while (yysimfac(h)) {
      doNothing = 1;
    }
    multiply_all_noexpand(tos - h);
    return restore();
  };

  yysimfac = function(h) {
    var i, j, _j, _k;
    i = 0;
    j = 0;
    for (i = _j = h; h <= tos ? _j < tos : _j > tos; i = h <= tos ? ++_j : --_j) {
      p1 = stack[i];
      for (j = _k = h; h <= tos ? _k < tos : _k > tos; j = h <= tos ? ++_k : --_k) {
        if (i === j) {
          continue;
        }
        p2 = stack[j];
        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {
          push(cadr(p1));
          push(one);
          subtract();
          factorial();
          stack[i] = pop();
          stack[j] = one;
          return 1;
        }
        if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {
          push(p1);
          push_integer(-1);
          add();
          factorial();
          reciprocate();
          stack[i] = pop();
          stack[j] = one;
          return 1;
        }
        if (car(p2) === symbol(FACTORIAL)) {
          push(p1);
          push(cadr(p2));
          subtract();
          p3 = pop();
          if (isplusone(p3)) {
            push(p1);
            factorial();
            stack[i] = pop();
            stack[j] = one;
            return 1;
          }
        }
        if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {
          push(cadr(p1));
          push(cadr(cadr(p2)));
          subtract();
          p3 = pop();
          if (isplusone(p3)) {
            push(cadr(p1));
            factorial();
            reciprocate();
            stack[i] = pop();
            stack[j] = one;
            return 1;
          }
        }
        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {
          push(cadr(p1));
          push(cadr(cadr(p2)));
          subtract();
          p3 = pop();
          if (isplusone(p3)) {
            stack[i] = cadr(p1);
            stack[j] = one;
            return 1;
          }
          if (isminusone(p3)) {
            push(cadr(cadr(p2)));
            reciprocate();
            stack[i] = pop();
            stack[j] = one;
            return 1;
          }
          if (equaln(p3, 2)) {
            stack[i] = cadr(p1);
            push(cadr(p1));
            push_integer(-1);
            add();
            stack[j] = pop();
            return 1;
          }
          if (equaln(p3, -2)) {
            push(cadr(cadr(p2)));
            reciprocate();
            stack[i] = pop();
            push(cadr(cadr(p2)));
            push_integer(-1);
            add();
            reciprocate();
            stack[j] = pop();
            return 1;
          }
        }
      }
    }
    return 0;
  };

  Eval_simplify = function() {
    push(cadr(p1));
    Eval();
    return simplify();
  };

  simplify = function() {
    save();
    simplify_main();
    return restore();
  };

  simplify_main = function() {
    p1 = pop();
    if (istensor(p1)) {
      simplify_tensor();
      return;
    }
    if (Find(p1, symbol(FACTORIAL))) {
      push(p1);
      simfac();
      p2 = pop();
      push(p1);
      rationalize();
      simfac();
      p3 = pop();
      if (count(p2) < count(p3)) {
        p1 = p2;
      } else {
        p1 = p3;
      }
    }
    f1();
    f2();
    f3();
    f4();
    f5();
    f9();
    return push(p1);
  };

  simplify_tensor = function() {
    var i, _j, _k, _ref, _ref1;
    i = 0;
    p2 = alloc_tensor(p1.tensor.nelem);
    p2.tensor.ndim = p1.tensor.ndim;
    for (i = _j = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      p2.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = _k = 0, _ref1 = p1.tensor.nelem; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
      push(p1.tensor.elem[i]);
      simplify();
      p2.tensor.elem[i] = pop();
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (iszero(p2)) {
      p2 = zero;
    }
    return push(p2);
  };

  count = function(p) {
    var n;
    if (iscons(p)) {
      n = 0;
      while (iscons(p)) {
        n += count(car(p)) + 1;
        p = cdr(p);
      }
    } else {
      n = 1;
    }
    return n;
  };

  f1 = function() {
    if (car(p1) !== symbol(ADD)) {
      return;
    }
    push(p1);
    rationalize();
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  f2 = function() {
    if (car(p1) !== symbol(ADD)) {
      return;
    }
    push(p1);
    Condense();
    p2 = pop();
    if (count(p2) <= count(p1)) {
      return p1 = p2;
    }
  };

  f3 = function() {
    push(p1);
    rationalize();
    negate();
    rationalize();
    negate();
    rationalize();
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  f4 = function() {
    if (iszero(p1)) {
      return;
    }
    push(p1);
    rationalize();
    inverse();
    rationalize();
    inverse();
    rationalize();
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  simplify_trig = function() {
    save();
    p1 = pop();
    f5();
    push(p1);
    return restore();
  };

  f5 = function() {
    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {
      return;
    }
    p2 = p1;
    trigmode = 1;
    push(p2);
    Eval();
    p3 = pop();
    trigmode = 2;
    push(p2);
    Eval();
    p4 = pop();
    trigmode = 0;
    if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {
      p3 = p4;
    }
    if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {
      return p1 = p3;
    }
  };

  f9 = function() {
    if (car(p1) !== symbol(ADD)) {
      return;
    }
    push_integer(0);
    p2 = cdr(p1);
    while (iscons(p2)) {
      push(car(p2));
      simplify();
      add();
      p2 = cdr(p2);
    }
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  nterms = function(p) {
    if (car(p) !== symbol(ADD)) {
      return 1;
    } else {
      return length(p) - 1;
    }
  };

  Eval_sin = function() {
    push(cadr(p1));
    Eval();
    return sine();
  };

  sine = function() {
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      sine_of_angle_sum();
    } else {
      sine_of_angle();
    }
    return restore();
  };

  sine_of_angle_sum = function() {
    p2 = cdr(p1);
    while (iscons(p2)) {
      p4 = car(p2);
      if (isnpi(p4)) {
        push(p1);
        push(p4);
        subtract();
        p3 = pop();
        push(p3);
        sine();
        push(p4);
        cosine();
        multiply();
        push(p3);
        cosine();
        push(p4);
        sine();
        multiply();
        add();
        return;
      }
      p2 = cdr(p2);
    }
    return sine_of_angle();
  };

  sine_of_angle = function() {
    var d, n;
    if (car(p1) === symbol(ARCSIN)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.sin(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (isnegative(p1)) {
      push(p1);
      negate();
      sine();
      negate();
      return;
    }
    if (car(p1) === symbol(ARCTAN)) {
      push(cadr(p1));
      push_integer(1);
      push(cadr(p1));
      push_integer(2);
      power();
      add();
      push_rational(-1, 2);
      power();
      multiply();
      return;
    }
    push(p1);
    push_integer(180);
    multiply();
    push_symbol(PI);
    divide();
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push(symbol(SIN));
      push(p1);
      list(2);
      return;
    }
    switch (n % 360) {
      case 0:
      case 180:
        return push_integer(0);
      case 30:
      case 150:
        return push_rational(1, 2);
      case 210:
      case 330:
        return push_rational(-1, 2);
      case 45:
      case 135:
        push_rational(1, 2);
        push_integer(2);
        push_rational(1, 2);
        power();
        return multiply();
      case 225:
      case 315:
        push_rational(-1, 2);
        push_integer(2);
        push_rational(1, 2);
        power();
        return multiply();
      case 60:
      case 120:
        push_rational(1, 2);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 240:
      case 300:
        push_rational(-1, 2);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 90:
        return push_integer(1);
      case 270:
        return push_integer(-1);
      default:
        push(symbol(SIN));
        push(p1);
        return list(2);
    }
  };

  Eval_sinh = function() {
    push(cadr(p1));
    Eval();
    return ysinh();
  };

  ysinh = function() {
    save();
    yysinh();
    return restore();
  };

  yysinh = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (car(p1) === symbol(ARCSINH)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.sinh(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (iszero(p1)) {
      push(zero);
      return;
    }
    push_symbol(SINH);
    push(p1);
    return list(2);
  };


  /*
  	Substitute new expr for old expr in expr.
  
  	Input:	push	expr
  
  		push	old expr
  
  		push	new expr
  
  	Output:	Result on stack
   */

  subst = function() {
    var i, _j, _k, _ref, _ref1;
    i = 0;
    save();
    p3 = pop();
    p2 = pop();
    if (p2 === symbol(NIL) || p3 === symbol(NIL)) {
      restore();
      return;
    }
    p1 = pop();
    if (istensor(p1)) {
      p4 = alloc_tensor(p1.tensor.nelem);
      p4.tensor.ndim = p1.tensor.ndim;
      for (i = _j = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        p4.tensor.dim[i] = p1.tensor.dim[i];
      }
      for (i = _k = 0, _ref1 = p1.tensor.nelem; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        push(p1.tensor.elem[i]);
        push(p2);
        push(p3);
        subst();
        p4.tensor.elem[i] = pop();
        if (p4.tensor.nelem !== p4.tensor.elem.length) {
          console.log("something wrong in tensor dimensions");
          debugger;
        }
      }
      push(p4);
    } else if (equal(p1, p2)) {
      push(p3);
    } else if (iscons(p1)) {
      push(car(p1));
      push(p2);
      push(p3);
      subst();
      push(cdr(p1));
      push(p2);
      push(p3);
      subst();
      cons();
    } else {
      push(p1);
    }
    return restore();
  };

  Eval_tan = function() {
    push(cadr(p1));
    Eval();
    return tangent();
  };

  tangent = function() {
    save();
    yytangent();
    return restore();
  };

  yytangent = function() {
    var d, n;
    n = 0;
    d = 0.0;
    p1 = pop();
    if (car(p1) === symbol(ARCTAN)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.tan(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (isnegative(p1)) {
      push(p1);
      negate();
      tangent();
      negate();
      return;
    }
    push(p1);
    push_integer(180);
    multiply();
    push_symbol(PI);
    divide();
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push(symbol(TAN));
      push(p1);
      list(2);
      return;
    }
    switch (n % 360) {
      case 0:
      case 180:
        return push_integer(0);
      case 30:
      case 210:
        push_rational(1, 3);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 150:
      case 330:
        push_rational(-1, 3);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 45:
      case 225:
        return push_integer(1);
      case 135:
      case 315:
        return push_integer(-1);
      case 60:
      case 240:
        push_integer(3);
        push_rational(1, 2);
        return power();
      case 120:
      case 300:
        push_integer(3);
        push_rational(1, 2);
        power();
        return negate();
      default:
        push(symbol(TAN));
        push(p1);
        return list(2);
    }
  };

  Eval_tanh = function() {
    var d;
    d = 0.0;
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (car(p1) === symbol(ARCTANH)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.tanh(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (iszero(p1)) {
      push(zero);
      return;
    }
    push_symbol(TANH);
    push(p1);
    return list(2);
  };


  /*
  Taylor expansion of a function
  
  	push(F)
  	push(X)
  	push(N)
  	push(A)
  	taylor()
   */

  Eval_taylor = function() {
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push_integer(24);
    } else {
      push(p2);
    }
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push_integer(0);
    } else {
      push(p2);
    }
    return taylor();
  };

  taylor = function() {
    var i, k, _j;
    i = 0;
    k = 0;
    save();
    p4 = pop();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    push(p3);
    k = pop_integer();
    if (k === 0x80000000) {
      push_symbol(TAYLOR);
      push(p1);
      push(p2);
      push(p3);
      push(p4);
      list(5);
      restore();
      return;
    }
    push(p1);
    push(p2);
    push(p4);
    subst();
    Eval();
    push_integer(1);
    p5 = pop();
    for (i = _j = 1; 1 <= k ? _j <= k : _j >= k; i = 1 <= k ? ++_j : --_j) {
      push(p1);
      push(p2);
      derivative();
      p1 = pop();
      if (iszero(p1)) {
        break;
      }
      push(p5);
      push(p2);
      push(p4);
      subtract();
      multiply();
      p5 = pop();
      push(p1);
      push(p2);
      push(p4);
      subst();
      Eval();
      push(p5);
      multiply();
      push_integer(i);
      factorial();
      divide();
      add();
    }
    return restore();
  };

  Eval_tensor = function() {
    var a, b, i, ndim, nelem, _j, _k;
    i = 0;
    ndim = 0;
    nelem = 0;
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    nelem = p1.tensor.nelem;
    ndim = p1.tensor.ndim;
    p2 = alloc_tensor(nelem);
    p2.tensor.ndim = ndim;
    for (i = _j = 0; 0 <= ndim ? _j < ndim : _j > ndim; i = 0 <= ndim ? ++_j : --_j) {
      p2.tensor.dim[i] = p1.tensor.dim[i];
    }
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    for (i = _k = 0; 0 <= nelem ? _k < nelem : _k > nelem; i = 0 <= nelem ? ++_k : --_k) {
      push(a[i]);
      Eval();
      b[i] = pop();
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p2);
    return promote_tensor();
  };

  tensor_plus_tensor = function() {
    var a, b, c, i, ndim, nelem, _j, _k, _l;
    i = 0;
    ndim = 0;
    nelem = 0;
    save();
    p2 = pop();
    p1 = pop();
    ndim = p1.tensor.ndim;
    if (ndim !== p2.tensor.ndim) {
      push(symbol(NIL));
      restore();
      return;
    }
    for (i = _j = 0; 0 <= ndim ? _j < ndim : _j > ndim; i = 0 <= ndim ? ++_j : --_j) {
      if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {
        push(symbol(NIL));
        restore();
        return;
      }
    }
    nelem = p1.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = _k = 0; 0 <= ndim ? _k < ndim : _k > ndim; i = 0 <= ndim ? ++_k : --_k) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    c = p3.tensor.elem;
    for (i = _l = 0; 0 <= nelem ? _l < nelem : _l > nelem; i = 0 <= nelem ? ++_l : --_l) {
      push(a[i]);
      push(b[i]);
      add();
      c[i] = pop();
    }
    push(p3);
    return restore();
  };

  tensor_times_scalar = function() {
    var a, b, i, ndim, nelem, _j, _k;
    i = 0;
    ndim = 0;
    nelem = 0;
    save();
    p2 = pop();
    p1 = pop();
    ndim = p1.tensor.ndim;
    nelem = p1.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = _j = 0; 0 <= ndim ? _j < ndim : _j > ndim; i = 0 <= ndim ? ++_j : --_j) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    a = p1.tensor.elem;
    b = p3.tensor.elem;
    for (i = _k = 0; 0 <= nelem ? _k < nelem : _k > nelem; i = 0 <= nelem ? ++_k : --_k) {
      push(a[i]);
      push(p2);
      multiply();
      b[i] = pop();
    }
    push(p3);
    return restore();
  };

  scalar_times_tensor = function() {
    var a, b, i, ndim, nelem, _j, _k;
    i = 0;
    ndim = 0;
    nelem = 0;
    save();
    p2 = pop();
    p1 = pop();
    ndim = p2.tensor.ndim;
    nelem = p2.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = _j = 0; 0 <= ndim ? _j < ndim : _j > ndim; i = 0 <= ndim ? ++_j : --_j) {
      p3.tensor.dim[i] = p2.tensor.dim[i];
    }
    a = p2.tensor.elem;
    b = p3.tensor.elem;
    for (i = _k = 0; 0 <= nelem ? _k < nelem : _k > nelem; i = 0 <= nelem ? ++_k : --_k) {
      push(p1);
      push(a[i]);
      multiply();
      b[i] = pop();
    }
    push(p3);
    return restore();
  };

  is_square_matrix = function(p) {
    if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {
      return 1;
    } else {
      return 0;
    }
  };

  d_tensor_tensor = function() {
    var a, b, c, i, j, ndim, nelem, _j, _k, _l, _ref;
    i = 0;
    j = 0;
    ndim = 0;
    nelem = 0;
    ndim = p1.tensor.ndim;
    nelem = p1.tensor.nelem;
    if (ndim + 1 >= MAXDIM) {
      push_symbol(DERIVATIVE);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    p3 = alloc_tensor(nelem * p2.tensor.nelem);
    p3.tensor.ndim = ndim + 1;
    for (i = _j = 0; 0 <= ndim ? _j < ndim : _j > ndim; i = 0 <= ndim ? ++_j : --_j) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    p3.tensor.dim[ndim] = p2.tensor.dim[0];
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    c = p3.tensor.elem;
    for (i = _k = 0; 0 <= nelem ? _k < nelem : _k > nelem; i = 0 <= nelem ? ++_k : --_k) {
      for (j = _l = 0, _ref = p2.tensor.nelem; 0 <= _ref ? _l < _ref : _l > _ref; j = 0 <= _ref ? ++_l : --_l) {
        push(a[i]);
        push(b[j]);
        derivative();
        c[i * p2.tensor.nelem + j] = pop();
      }
    }
    return push(p3);
  };

  d_scalar_tensor = function() {
    var a, b, i, _j, _ref;
    p3 = alloc_tensor(p2.tensor.nelem);
    p3.tensor.ndim = 1;
    p3.tensor.dim[0] = p2.tensor.dim[0];
    a = p2.tensor.elem;
    b = p3.tensor.elem;
    for (i = _j = 0, _ref = p2.tensor.nelem; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      push(p1);
      push(a[i]);
      derivative();
      b[i] = pop();
    }
    return push(p3);
  };

  d_tensor_scalar = function() {
    var a, b, i, _j, _k, _ref, _ref1;
    i = 0;
    p3 = alloc_tensor(p1.tensor.nelem);
    p3.tensor.ndim = p1.tensor.ndim;
    for (i = _j = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    a = p1.tensor.elem;
    b = p3.tensor.elem;
    for (i = _k = 0, _ref1 = p1.tensor.nelem; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
      push(a[i]);
      push(p2);
      derivative();
      b[i] = pop();
    }
    return push(p3);
  };

  compare_tensors = function(p1, p2) {
    var i, _j, _k, _ref, _ref1;
    i = 0;
    if (p1.tensor.ndim < p2.tensor.ndim) {
      return -1;
    }
    if (p1.tensor.ndim > p2.tensor.ndim) {
      return 1;
    }
    for (i = _j = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {
        return -1;
      }
      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {
        return 1;
      }
    }
    for (i = _k = 0, _ref1 = p1.tensor.nelem; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
      if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {
        continue;
      }
      if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {
        return -1;
      } else {
        return 1;
      }
    }
    return 0;
  };

  power_tensor = function() {
    var i, k, n, _j, _k, _results;
    i = 0;
    k = 0;
    n = 0;
    k = p1.tensor.ndim - 1;
    if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    push(p2);
    n = pop_integer();
    if (n === 0x80000000) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    if (n === 0) {
      if (p1.tensor.ndim !== 2) {
        stop("power(tensor,0) with tensor rank not equal to 2");
      }
      n = p1.tensor.dim[0];
      p1 = alloc_tensor(n * n);
      p1.tensor.ndim = 2;
      p1.tensor.dim[0] = n;
      p1.tensor.dim[1] = n;
      for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
        p1.tensor.elem[n * i + i] = one;
      }
      if (p1.tensor.nelem !== p1.tensor.elem.length) {
        console.log("something wrong in tensor dimensions");
        debugger;
      }
      push(p1);
      return;
    }
    if (n < 0) {
      n = -n;
      push(p1);
      inv();
      p1 = pop();
    }
    push(p1);
    _results = [];
    for (i = _k = 1; 1 <= n ? _k < n : _k > n; i = 1 <= n ? ++_k : --_k) {
      push(p1);
      inner();
      if (iszero(stack[tos - 1])) {
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  copy_tensor = function() {
    var i, _j, _k, _ref, _ref1;
    i = 0;
    save();
    p1 = pop();
    p2 = alloc_tensor(p1.tensor.nelem);
    p2.tensor.ndim = p1.tensor.ndim;
    for (i = _j = 0, _ref = p1.tensor.ndim; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      p2.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = _k = 0, _ref1 = p1.tensor.nelem; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
      p2.tensor.elem[i] = p1.tensor.elem[i];
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p2);
    return restore();
  };

  promote_tensor = function() {
    var i, j, k, ndim, nelem, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4;
    i = 0;
    j = 0;
    k = 0;
    nelem = 0;
    ndim = 0;
    save();
    p1 = pop();
    if (!istensor(p1)) {
      push(p1);
      restore();
      return;
    }
    p2 = p1.tensor.elem[0];
    for (i = _j = 1, _ref = p1.tensor.nelem; 1 <= _ref ? _j < _ref : _j > _ref; i = 1 <= _ref ? ++_j : --_j) {
      if (!compatible(p2, p1.tensor.elem[i])) {
        stop("Cannot promote tensor due to inconsistent tensor components.");
      }
    }
    if (!istensor(p2)) {
      push(p1);
      restore();
      return;
    }
    ndim = p1.tensor.ndim + p2.tensor.ndim;
    if (ndim > MAXDIM) {
      stop("tensor rank > 24");
    }
    nelem = p1.tensor.nelem * p2.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = _k = 0, _ref1 = p1.tensor.ndim; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (j = _l = 0, _ref2 = p2.tensor.ndim; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; j = 0 <= _ref2 ? ++_l : --_l) {
      p3.tensor.dim[i + j] = p2.tensor.dim[j];
    }
    k = 0;
    for (i = _m = 0, _ref3 = p1.tensor.nelem; 0 <= _ref3 ? _m < _ref3 : _m > _ref3; i = 0 <= _ref3 ? ++_m : --_m) {
      p2 = p1.tensor.elem[i];
      for (j = _n = 0, _ref4 = p2.tensor.nelem; 0 <= _ref4 ? _n < _ref4 : _n > _ref4; j = 0 <= _ref4 ? ++_n : --_n) {
        p3.tensor.elem[k++] = p2.tensor.elem[j];
      }
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p3.tensor.nelem !== p3.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p3);
    return restore();
  };

  compatible = function(p, q) {
    var i, _j, _ref;
    if (!istensor(p) && !istensor(q)) {
      return 1;
    }
    if (!istensor(p) || !istensor(q)) {
      return 0;
    }
    if (p.tensor.ndim !== q.tensor.ndim) {
      return 0;
    }
    for (i = _j = 0, _ref = p.tensor.ndim; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      if (p.tensor.dim[i] !== q.tensor.dim[i]) {
        return 0;
      }
    }
    return 1;
  };

  Eval_test = function() {
    p1 = cdr(p1);
    while (iscons(p1)) {
      if (cdr(p1) === symbol(NIL)) {
        push(car(p1));
        Eval();
        return;
      }
      push(car(p1));
      Eval_predicate();
      p2 = pop();
      if (!iszero(p2)) {
        push(cadr(p1));
        Eval();
        return;
      }
      p1 = cddr(p1);
    }
    return push_integer(0);
  };

  Eval_testeq = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    subtract();
    p1 = pop();
    if (iszero(p1)) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_testge = function() {
    if (cmp_args() >= 0) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_testgt = function() {
    if (cmp_args() > 0) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_testle = function() {
    if (cmp_args() <= 0) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_testlt = function() {
    if (cmp_args() < 0) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_not = function() {
    push(cadr(p1));
    Eval_predicate();
    p1 = pop();
    if (iszero(p1)) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_and = function() {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval_predicate();
      p2 = pop();
      if (iszero(p2)) {
        push_integer(0);
        return;
      }
      p1 = cdr(p1);
    }
    return push_integer(1);
  };

  Eval_or = function() {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval_predicate();
      p2 = pop();
      if (!iszero(p2)) {
        push_integer(1);
        return;
      }
      p1 = cdr(p1);
    }
    return push_integer(0);
  };

  cmp_args = function() {
    var t;
    t = 0;
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    subtract();
    p1 = pop();
    if (p1.k !== NUM && p1.k !== DOUBLE) {
      push(p1);
      yyfloat();
      Eval();
      p1 = pop();
    }
    if (iszero(p1)) {
      return 0;
    }
    switch (p1.k) {
      case NUM:
        if (MSIGN(p1.q.a) === -1) {
          t = -1;
        } else {
          t = 1;
        }
        break;
      case DOUBLE:
        if (p1.d < 0.0) {
          t = -1;
        } else {
          t = 1;
        }
        break;
      default:
        stop("relational operator: cannot determine due to non-numerical comparison");
        t = 0;
    }
    return t;
  };


  /*
  Transform an expression using table look-up
  
  The expression and free variable are on the stack.
  
  The argument s is a null terminated list of transform rules.
  
  For example, see itab.cpp
  
  Internally, the following symbols are used:
  
  	F	input expression
  
  	X	free variable, i.e. F of X
  
  	A	template expression
  
  	B	result expression
  
  	C	list of conditional expressions
   */

  transform = function(s) {
    var eachEntry, h, _j, _len;
    h = 0;
    save();
    p4 = pop();
    p3 = pop();
    push(get_binding(symbol(METAA)));
    push(get_binding(symbol(METAB)));
    push(get_binding(symbol(METAX)));
    set_binding(symbol(METAX), p4);
    h = tos;
    push_integer(1);
    push(p3);
    push(p4);
    polyform();
    push(p4);
    decomp();
    for (_j = 0, _len = s.length; _j < _len; _j++) {
      eachEntry = s[_j];
      if (DEBUG) {
        console.log("scanning table entry " + eachEntry);
      }
      if (eachEntry) {
        scan_meta(eachEntry);
        p1 = pop();
        p5 = cadr(p1);
        p6 = caddr(p1);
        p7 = cdddr(p1);
        if (f_equals_a(h)) {
          break;
        }
      }
    }
    tos = h;
    if (eachEntry) {
      push(p6);
      Eval();
      p1 = pop();
    } else {
      p1 = symbol(NIL);
    }
    set_binding(symbol(METAX), pop());
    set_binding(symbol(METAB), pop());
    set_binding(symbol(METAA), pop());
    push(p1);
    return restore();
  };

  f_equals_a = function(h) {
    var i, j, _j, _k;
    i = 0;
    j = 0;
    for (i = _j = h; h <= tos ? _j < tos : _j > tos; i = h <= tos ? ++_j : --_j) {
      set_binding(symbol(METAA), stack[i]);
      for (j = _k = h; h <= tos ? _k < tos : _k > tos; j = h <= tos ? ++_k : --_k) {
        set_binding(symbol(METAB), stack[j]);
        p1 = p7;
        while (iscons(p1)) {
          push(car(p1));
          Eval();
          p2 = pop();
          if (iszero(p2)) {
            break;
          }
          p1 = cdr(p1);
        }
        if (iscons(p1)) {
          continue;
        }
        push(p3);
        push(p5);
        Eval();
        subtract();
        p1 = pop();
        if (iszero(p1)) {
          return 1;
        }
      }
    }
    return 0;
  };

  Eval_transpose = function() {
    push(cadr(p1));
    Eval();
    if (cddr(p1) === symbol(NIL)) {
      push_integer(1);
      push_integer(2);
    } else {
      push(caddr(p1));
      Eval();
      push(cadddr(p1));
      Eval();
    }
    return transpose();
  };

  transpose = function() {
    var a, ai, an, b, i, j, k, l, m, ndim, nelem, t, _j, _k, _l, _m, _n, _o, _ref;
    i = 0;
    j = 0;
    k = 0;
    l = 0;
    m = 0;
    ndim = 0;
    nelem = 0;
    t = 0;
    ai = [];
    an = [];
    for (i = _j = 0; 0 <= MAXDIM ? _j < MAXDIM : _j > MAXDIM; i = 0 <= MAXDIM ? ++_j : --_j) {
      ai[i] = 0;
      an[i] = 0;
    }
    save();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    if (!istensor(p1)) {
      if (!iszero(p1)) {
        stop("transpose: tensor expected, 1st arg is not a tensor");
      }
      push(zero);
      restore();
      return;
    }
    ndim = p1.tensor.ndim;
    nelem = p1.tensor.nelem;
    if (ndim === 1) {
      push(p1);
      restore();
      return;
    }
    push(p2);
    l = pop_integer();
    push(p3);
    m = pop_integer();
    if (l < 1 || l > ndim || m < 1 || m > ndim) {
      stop("transpose: index out of range");
    }
    l--;
    m--;
    p2 = alloc_tensor(nelem);
    p2.tensor.ndim = ndim;
    for (i = _k = 0; 0 <= ndim ? _k < ndim : _k > ndim; i = 0 <= ndim ? ++_k : --_k) {
      p2.tensor.dim[i] = p1.tensor.dim[i];
    }
    p2.tensor.dim[l] = p1.tensor.dim[m];
    p2.tensor.dim[m] = p1.tensor.dim[l];
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    for (i = _l = 0; 0 <= ndim ? _l < ndim : _l > ndim; i = 0 <= ndim ? ++_l : --_l) {
      ai[i] = 0;
      an[i] = p1.tensor.dim[i];
    }
    for (i = _m = 0; 0 <= nelem ? _m < nelem : _m > nelem; i = 0 <= nelem ? ++_m : --_m) {
      t = ai[l];
      ai[l] = ai[m];
      ai[m] = t;
      t = an[l];
      an[l] = an[m];
      an[m] = t;
      k = 0;
      for (j = _n = 0; 0 <= ndim ? _n < ndim : _n > ndim; j = 0 <= ndim ? ++_n : --_n) {
        k = (k * an[j]) + ai[j];
      }
      t = ai[l];
      ai[l] = ai[m];
      ai[m] = t;
      t = an[l];
      an[l] = an[m];
      an[m] = t;
      b[k] = a[i];
      for (j = _o = _ref = ndim - 1; _ref <= 0 ? _o <= 0 : _o >= 0; j = _ref <= 0 ? ++_o : --_o) {
        if (++ai[j] < an[j]) {
          break;
        }
        ai[j] = 0;
      }
    }
    push(p2);
    return restore();
  };

  Eval_user_function = function() {
    var h;
    if (car(p1) === symbol(SYMBOL_D) && get_arglist(symbol(SYMBOL_D)) === symbol(NIL)) {
      Eval_derivative();
      return;
    }
    p3 = get_binding(car(p1));
    p4 = get_arglist(car(p1));
    p5 = cdr(p1);
    if (p3 === car(p1)) {
      h = tos;
      push(p3);
      p1 = p5;
      while (iscons(p1)) {
        push(car(p1));
        Eval();
        p1 = cdr(p1);
      }
      list(tos - h);
      return;
    }
    p1 = p4;
    p2 = p5;
    h = tos;
    while (iscons(p1) && iscons(p2)) {
      push(car(p1));
      push(car(p2));
      Eval();
      p1 = cdr(p1);
      p2 = cdr(p2);
    }
    list(tos - h);
    p6 = pop();
    push(p3);
    if (iscons(p6)) {
      push(p6);
      rewrite_args();
    }
    return Eval();
  };

  rewrite_args = function() {
    var h, n;
    n = 0;
    save();
    p2 = pop();
    p1 = pop();
    if (istensor(p1)) {
      n = rewrite_args_tensor();
      restore();
      return n;
    }
    if (iscons(p1)) {
      h = tos;
      push(car(p1));
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        n += rewrite_args();
        p1 = cdr(p1);
      }
      list(tos - h);
      restore();
      return n;
    }
    if (!issymbol(p1)) {
      push(p1);
      restore();
      return 0;
    }
    p3 = p2;
    while (iscons(p3)) {
      if (p1 === car(p3)) {
        push(cadr(p3));
        restore();
        return 1;
      }
      p3 = cddr(p3);
    }
    p3 = get_binding(p1);
    push(p3);
    if (p1 !== p3) {
      push(p2);
      n = rewrite_args();
      if (n === 0) {
        pop();
        push(p1);
      }
    }
    restore();
    return n;
  };

  rewrite_args_tensor = function() {
    var i, n, _j, _ref;
    n = 0;
    i = 0;
    push(p1);
    copy_tensor();
    p1 = pop();
    for (i = _j = 0, _ref = p1.tensor.nelem; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      push(p1.tensor.elem[i]);
      push(p2);
      n += rewrite_args();
      p1.tensor.elem[i] = pop();
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p1);
    return n;
  };

  Eval_zero = function() {
    var i, k, m, n, _j, _k;
    i = 0;
    k = [];
    m = 0;
    n = 0;
    for (i = _j = 0; 0 <= MAXDIM ? _j < MAXDIM : _j > MAXDIM; i = 0 <= MAXDIM ? ++_j : --_j) {
      k[i] = 0;
    }
    m = 1;
    n = 0;
    p2 = cdr(p1);
    while (iscons(p2)) {
      push(car(p2));
      Eval();
      i = pop_integer();
      if (i < 2) {
        push(zero);
        return;
      }
      m *= i;
      k[n++] = i;
      p2 = cdr(p2);
    }
    if (n === 0) {
      push(zero);
      return;
    }
    p1 = alloc_tensor(m);
    p1.tensor.ndim = n;
    for (i = _k = 0; 0 <= n ? _k < n : _k > n; i = 0 <= n ? ++_k : --_k) {
      p1.tensor.dim[i] = k[i];
    }
    return push(p1);
  };


  /*
  // up to 100 blocks of 100,000 atoms
  
  #define M 100
  #define N 100000
  
  U *mem[M]
  int mcount
  
  U *free_list
  int free_count
  
  U *
  alloc(void)
  {
  	U *p
  	if (free_count == 0) {
  		if (mcount == 0)
  			alloc_mem()
  		else {
  			gc()
  			if (free_count < N * mcount / 2)
  				alloc_mem()
  		}
  		if (free_count == 0)
  			stop("atom space exhausted")
  	}
  	p = free_list
  	free_list = free_list->u.cons.cdr
  	free_count--
  	return p
  }
   */

  allocatedId = 0;

  alloc_tensor = function(nelem) {
    var i, p, _j;
    i = 0;
    p = new U();
    p.k = TENSOR;
    p.tensor = new tensor();
    p.tensor.nelem = nelem;
    for (i = _j = 0; 0 <= nelem ? _j < nelem : _j > nelem; i = 0 <= nelem ? ++_j : --_j) {
      p.tensor.elem[i] = zero;
    }
    p.tensor.allocatedId = allocatedId;
    allocatedId++;
    if (p.tensor.nelem !== p.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    return p;
  };


  /*
  // garbage collector
  
  void
  gc(void)
  {
  	int i, j
  	U *p
  
  	// tag everything
  
  	for (i = 0; i < mcount; i++) {
  		p = mem[i]
  		for (j = 0; j < N; j++)
  			p[j].tag = 1
  	}
  
  	// untag what's used
  
  	untag(p0)
  	untag(p1)
  	untag(p2)
  	untag(p3)
  	untag(p4)
  	untag(p5)
  	untag(p6)
  	untag(p7)
  	untag(p8)
  	untag(p9)
  
  	untag(one)
  	untag(zero)
  	untag(imaginaryunit)
  
  	for (i = 0; i < NSYM; i++) {
  		untag(binding[i])
  		untag(arglist[i])
  	}
  
  	for (i = 0; i < tos; i++)
  		untag(stack[i])
  
  	for (i = (int) (frame - stack); i < TOS; i++)
  		untag(stack[i])
  
  	// collect everything that's still tagged
  
  	free_count = 0
  
  	for (i = 0; i < mcount; i++) {
  		p = mem[i]
  		for (j = 0; j < N; j++) {
  			if (p[j].tag == 0)
  				continue
  			// still tagged so it's unused, put on free list
  			switch (p[j].k) {
  			case TENSOR:
  				free(p[j].u.tensor)
  				break
  			case STR:
  				free(p[j].u.str)
  				break
  			case NUM:
  				mfree(p[j].u.q.a)
  				mfree(p[j].u.q.b)
  				break
  			}
  			p[j].k = CONS; // so no double free occurs above
  			p[j].u.cons.cdr = free_list
  			free_list = p + j
  			free_count++
  		}
  	}
  }
  
  void
  untag(U *p)
  {
  	int i
  
  	if (iscons(p)) {
  		do {
  			if (p->tag == 0)
  				return
  			p->tag = 0
  			untag(p->u.cons.car)
  			p = p->u.cons.cdr
  		} while (iscons(p))
  		untag(p)
  		return
  	}
  
  	if (p->tag) {
  		p->tag = 0
   		if (istensor(p)) {
  			for (i = 0; i < p->u.tensor->nelem; i++)
  				untag(p->u.tensor->elem[i])
  		}
  	}
  }
  
  // get memory for 100,000 atoms
  
  void
  alloc_mem(void)
  {
  	int i
  	U *p
  	if (mcount == M)
  		return
  	p = (U *) malloc(N * sizeof (struct U))
  	if (p == NULL)
  		return
  	mem[mcount++] = p
  	for (i = 0; i < N; i++) {
  		p[i].k = CONS; // so no free in gc
  		p[i].u.cons.cdr = p + i + 1
  	}
  	p[N - 1].u.cons.cdr = free_list
  	free_list = p
  	free_count += N
  }
  
  void
  print_mem_info(void)
  {
  	char buf[100]
  
  	sprintf(buf, "%d blocks (%d bytes/block)\n", N * mcount, (int) sizeof (U))
  	printstr(buf)
  
  	sprintf(buf, "%d free\n", free_count)
  	printstr(buf)
  
  	sprintf(buf, "%d used\n", N * mcount - free_count)
  	printstr(buf)
  }
   */

  YMAX = 10000;

  glyph = (function() {
    function glyph() {}

    glyph.prototype.c = 0;

    glyph.prototype.x = 0;

    glyph.prototype.y = 0;

    return glyph;

  })();

  chartab = [];

  for (charTabIndex = _j = 0; 0 <= YMAX ? _j < YMAX : _j > YMAX; charTabIndex = 0 <= YMAX ? ++_j : --_j) {
    chartab[charTabIndex] = new glyph();
  }

  yindex = 0;

  level = 0;

  emit_x = 0;

  expr_level = 0;

  display_flag = 0;

  printchar_nowrap = function(character, accumulator) {
    var topLevelCall;
    if (accumulator == null) {
      topLevelCall = true;
      accumulator = "";
    }
    accumulator += character;
    return accumulator;
  };

  printchar = function(character, accumulator) {
    return printchar_nowrap(character, accumulator);
  };

  display = function(p) {
    var h, w, y, _ref;
    h = 0;
    w = 0;
    y = 0;
    save();
    yindex = 0;
    level = 0;
    emit_x = 0;
    emit_top_expr(p);
    _ref = get_size(0, yindex), h = _ref[0], w = _ref[1], y = _ref[2];
    if (w > 100) {
      printline(p);
      restore();
      return;
    }
    print_it();
    return restore();
  };

  emit_top_expr = function(p) {
    if (car(p) === symbol(SETQ)) {
      emit_expr(cadr(p));
      __emit_str(" = ");
      emit_expr(caddr(p));
      return;
    }
    if (istensor(p)) {
      return emit_tensor(p);
    } else {
      return emit_expr(p);
    }
  };

  will_be_displayed_as_fraction = function(p) {
    if (level > 0) {
      return 0;
    }
    if (isfraction(p)) {
      return 1;
    }
    if (car(p) !== symbol(MULTIPLY)) {
      return 0;
    }
    if (isfraction(cadr(p))) {
      return 1;
    }
    while (iscons(p)) {
      if (isdenominator(car(p))) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  };

  emit_expr = function(p) {
    expr_level++;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      if (__is_negative(car(p))) {
        __emit_char('-');
        if (will_be_displayed_as_fraction(car(p))) {
          __emit_char(' ');
        }
      }
      emit_term(car(p));
      p = cdr(p);
      while (iscons(p)) {
        if (__is_negative(car(p))) {
          __emit_char(' ');
          __emit_char('-');
          __emit_char(' ');
        } else {
          __emit_char(' ');
          __emit_char('+');
          __emit_char(' ');
        }
        emit_term(car(p));
        p = cdr(p);
      }
    } else {
      if (__is_negative(p)) {
        __emit_char('-');
        if (will_be_displayed_as_fraction(p)) {
          __emit_char(' ');
        }
      }
      emit_term(p);
    }
    return expr_level--;
  };

  emit_unsigned_expr = function(p) {
    var _results;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      emit_term(car(p));
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        if (__is_negative(car(p))) {
          __emit_char(' ');
          __emit_char('-');
          __emit_char(' ');
        } else {
          __emit_char(' ');
          __emit_char('+');
          __emit_char(' ');
        }
        emit_term(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    } else {
      return emit_term(p);
    }
  };

  __is_negative = function(p) {
    if (isnegativenumber(p)) {
      return 1;
    }
    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
      return 1;
    }
    return 0;
  };

  emit_term = function(p) {
    var n;
    if (car(p) === symbol(MULTIPLY)) {
      n = count_denominators(p);
      if (n && level === 0) {
        return emit_fraction(p, n);
      } else {
        return emit_multiply(p, n);
      }
    } else {
      return emit_factor(p);
    }
  };

  isdenominator = function(p) {
    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  count_denominators = function(p) {
    var q;
    count = 0;
    p = cdr(p);
    while (iscons(p)) {
      q = car(p);
      if (isdenominator(q)) {
        count++;
      }
      p = cdr(p);
    }
    return count;
  };

  emit_multiply = function(p, n) {
    var _results;
    if (n === 0) {
      p = cdr(p);
      if (isplusone(car(p)) || isminusone(car(p))) {
        p = cdr(p);
      }
      emit_factor(car(p));
      p = cdr(p);
      _results = [];
      while (iscons(p)) {
        __emit_char(' ');
        emit_factor(car(p));
        _results.push(p = cdr(p));
      }
      return _results;
    } else {
      emit_numerators(p);
      __emit_char('/');
      if (n > 1 || isfraction(cadr(p))) {
        __emit_char('(');
        emit_denominators(p);
        return __emit_char(')');
      } else {
        return emit_denominators(p);
      }
    }
  };

  emit_fraction = function(p, d) {
    var doNothing, k1, k2, n, x;
    count = 0;
    k1 = 0;
    k2 = 0;
    n = 0;
    x = 0;
    save();
    p3 = one;
    p4 = one;
    if (isrational(cadr(p))) {
      push(cadr(p));
      mp_numerator();
      absval();
      p3 = pop();
      push(cadr(p));
      mp_denominator();
      p4 = pop();
    }
    if (isdouble(cadr(p))) {
      push(cadr(p));
      absval();
      p3 = pop();
    }
    if (isplusone(p3)) {
      n = 0;
    } else {
      n = 1;
    }
    p1 = cdr(p);
    if (isnum(car(p1))) {
      p1 = cdr(p1);
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (isdenominator(p2)) {
        doNothing = 1;
      } else {
        n++;
      }
      p1 = cdr(p1);
    }
    x = emit_x;
    k1 = yindex;
    count = 0;
    if (!isplusone(p3)) {
      emit_number(p3, 0);
      count++;
    }
    p1 = cdr(p);
    if (isnum(car(p1))) {
      p1 = cdr(p1);
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (isdenominator(p2)) {
        doNothing = 1;
      } else {
        if (count > 0) {
          __emit_char(' ');
        }
        if (n === 1) {
          emit_expr(p2);
        } else {
          emit_factor(p2);
        }
        count++;
      }
      p1 = cdr(p1);
    }
    if (count === 0) {
      __emit_char('1');
    }
    k2 = yindex;
    count = 0;
    if (!isplusone(p4)) {
      emit_number(p4, 0);
      count++;
      d++;
    }
    p1 = cdr(p);
    if (isrational(car(p1))) {
      p1 = cdr(p1);
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (isdenominator(p2)) {
        if (count > 0) {
          __emit_char(' ');
        }
        emit_denominator(p2, d);
        count++;
      }
      p1 = cdr(p1);
    }
    fixup_fraction(x, k1, k2);
    return restore();
  };

  emit_numerators = function(p) {
    var doNothing, n;
    int(n);
    save();
    p1 = one;
    p = cdr(p);
    if (isrational(car(p))) {
      push(car(p));
      mp_numerator();
      absval();
      p1 = pop();
      p = cdr(p);
    } else if (isdouble(car(p))) {
      push(car(p));
      absval();
      p1 = pop();
      p = cdr(p);
    }
    n = 0;
    if (!isplusone(p1)) {
      emit_number(p1, 0);
      n++;
    }
    while (iscons(p)) {
      if (isdenominator(car(p))) {
        doNothing = 1;
      } else {
        if (n > 0) {
          __emit_char(' ');
        }
        emit_factor(car(p));
        n++;
      }
      p = cdr(p);
    }
    if (n === 0) {
      __emit_char('1');
    }
    return restore();
  };

  emit_denominators = function(p) {
    var n;
    int(n);
    save();
    n = 0;
    p = cdr(p);
    if (isfraction(car(p))) {
      push(car(p));
      mp_denominator();
      p1 = pop();
      emit_number(p1, 0);
      n++;
      p = cdr(p);
    }
    while (iscons(p)) {
      if (isdenominator(car(p))) {
        if (n > 0) {
          __emit_char(' ');
        }
        emit_denominator(car(p), 0);
        n++;
      }
      p = cdr(p);
    }
    return restore();
  };

  emit_factor = function(p) {
    if (istensor(p)) {
      if (level === 0) {
        emit_flat_tensor(p);
      } else {
        emit_flat_tensor(p);
      }
      return;
    }
    if (isdouble(p)) {
      emit_number(p, 0);
      return;
    }
    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {
      emit_subexpr(p);
      return;
    }
    if (car(p) === symbol(POWER)) {
      emit_power(p);
      return;
    }
    if (iscons(p)) {
      emit_function(p);
      return;
    }
    if (isnum(p)) {
      if (level === 0) {
        emit_numerical_fraction(p);
      } else {
        emit_number(p, 0);
      }
      return;
    }
    if (issymbol(p)) {
      emit_symbol(p);
      return;
    }
    if (isstr(p)) {
      emit_string(p);
    }
  };

  emit_numerical_fraction = function(p) {
    var k1, k2, x;
    k1 = 0;
    k2 = 0;
    x = 0;
    save();
    push(p);
    mp_numerator();
    absval();
    p3 = pop();
    push(p);
    mp_denominator();
    p4 = pop();
    if (isplusone(p4)) {
      emit_number(p3, 0);
      restore();
      return;
    }
    x = emit_x;
    k1 = yindex;
    emit_number(p3, 0);
    k2 = yindex;
    emit_number(p4, 0);
    fixup_fraction(x, k1, k2);
    return restore();
  };

  isfactor = function(p) {
    if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {
      return 1;
    }
    if (issymbol(p)) {
      return 1;
    }
    if (isfraction(p)) {
      return 0;
    }
    if (isnegativenumber(p)) {
      return 0;
    }
    if (isnum(p)) {
      return 1;
    }
    return 0;
  };

  emit_power = function(p) {
    var k1, k2, x;
    k1 = 0;
    k2 = 0;
    x = 0;
    if (cadr(p) === symbol(E)) {
      __emit_str("exp(");
      emit_expr(caddr(p));
      __emit_char(')');
      return;
    }
    if (level > 0) {
      if (isminusone(caddr(p))) {
        __emit_char('1');
        __emit_char('/');
        if (isfactor(cadr(p))) {
          emit_factor(cadr(p));
        } else {
          emit_subexpr(cadr(p));
        }
      } else {
        if (isfactor(cadr(p))) {
          emit_factor(cadr(p));
        } else {
          emit_subexpr(cadr(p));
        }
        __emit_char('^');
        if (isfactor(caddr(p))) {
          emit_factor(caddr(p));
        } else {
          emit_subexpr(caddr(p));
        }
      }
      return;
    }
    if (__is_negative(caddr(p))) {
      x = emit_x;
      k1 = yindex;
      __emit_char('1');
      k2 = yindex;
      emit_denominator(p, 1);
      fixup_fraction(x, k1, k2);
      return;
    }
    k1 = yindex;
    if (isfactor(cadr(p))) {
      emit_factor(cadr(p));
    } else {
      emit_subexpr(cadr(p));
    }
    k2 = yindex;
    level++;
    emit_expr(caddr(p));
    level--;
    return fixup_power(k1, k2);
  };

  emit_denominator = function(p, n) {
    var k1, k2;
    k1 = 0;
    k2 = 0;
    if (isminusone(caddr(p))) {
      if (n === 1) {
        emit_expr(cadr(p));
      } else {
        emit_factor(cadr(p));
      }
      return;
    }
    k1 = yindex;
    if (isfactor(cadr(p))) {
      emit_factor(cadr(p));
    } else {
      emit_subexpr(cadr(p));
    }
    k2 = yindex;
    level++;
    emit_unsigned_expr(caddr(p));
    level--;
    return fixup_power(k1, k2);
  };

  emit_function = function(p) {
    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {
      emit_index_function(p);
      return;
    }
    if (car(p) === symbol(FACTORIAL)) {
      emit_factorial_function(p);
      return;
    }
    if (car(p) === symbol(DERIVATIVE)) {
      __emit_char('d');
    } else {
      emit_symbol(car(p));
    }
    __emit_char('(');
    p = cdr(p);
    if (iscons(p)) {
      emit_expr(car(p));
      p = cdr(p);
      while (iscons(p)) {
        __emit_char(',');
        emit_expr(car(p));
        p = cdr(p);
      }
    }
    return __emit_char(')');
  };

  emit_index_function = function(p) {
    p = cdr(p);
    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {
      emit_subexpr(car(p));
    } else {
      emit_expr(car(p));
    }
    __emit_char('[');
    p = cdr(p);
    if (iscons(p)) {
      emit_expr(car(p));
      p = cdr(p);
      while (iscons(p)) {
        __emit_char(',');
        emit_expr(car(p));
        p = cdr(p);
      }
    }
    return __emit_char(']');
  };

  emit_factorial_function = function(p) {
    p = cadr(p);
    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {
      emit_subexpr(p);
    } else {
      emit_expr(p);
    }
    return __emit_char('!');
  };

  emit_subexpr = function(p) {
    __emit_char('(');
    emit_expr(p);
    return __emit_char(')');
  };

  emit_symbol = function(p) {
    var i, pPrintName, _k, _ref, _results;
    i = 0;
    if (p === symbol(E)) {
      __emit_str("exp(1)");
      return;
    }
    pPrintName = get_printname(p);
    _results = [];
    for (i = _k = 0, _ref = pPrintName.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
      _results.push(__emit_char(pPrintName[i]));
    }
    return _results;
  };

  emit_string = function(p) {
    var i, pString, _k, _ref, _results;
    i = 0;
    pString = p.str;
    _results = [];
    for (i = _k = 0, _ref = pString.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
      _results.push(__emit_char(pString[i]));
    }
    return _results;
  };

  fixup_fraction = function(x, k1, k2) {
    var dx, dy, h1, h2, i, w, w1, w2, y, y1, y2, _k, _ref, _ref1, _results;
    dx = 0;
    dy = 0;
    i = 0;
    w = 0;
    y = 0;
    h1 = 0;
    w1 = 0;
    y1 = 0;
    h2 = 0;
    w2 = 0;
    y2 = 0;
    _ref = get_size(k1, k2), h1 = _ref[0], w1 = _ref[1], y1 = _ref[2];
    _ref1 = get_size(k2, yindex), h2 = _ref1[0], w2 = _ref1[1], y2 = _ref1[2];
    if (w2 > w1) {
      dx = (w2 - w1) / 2;
    } else {
      dx = 0;
    }
    dx++;
    y = y1 + h1 - 1;
    dy = -y - 1;
    move(k1, k2, dx, dy);
    if (w2 > w1) {
      dx = -w1;
    } else {
      dx = -w1 + (w1 - w2) / 2;
    }
    dx++;
    dy = -y2 + 1;
    move(k2, yindex, dx, dy);
    if (w2 > w1) {
      w = w2;
    } else {
      w = w1;
    }
    w += 2;
    emit_x = x;
    _results = [];
    for (i = _k = 0; 0 <= w ? _k < w : _k > w; i = 0 <= w ? ++_k : --_k) {
      _results.push(__emit_char('-'));
    }
    return _results;
  };

  fixup_power = function(k1, k2) {
    var dy, h1, h2, w1, w2, y1, y2, _ref, _ref1;
    dy = 0;
    h1 = 0;
    w1 = 0;
    y1 = 0;
    h2 = 0;
    w2 = 0;
    y2 = 0;
    _ref = get_size(k1, k2), h1 = _ref[0], w1 = _ref[1], y1 = _ref[2];
    _ref1 = get_size(k2, yindex), h2 = _ref1[0], w2 = _ref1[1], y2 = _ref1[2];
    dy = -y2 - h2 + 1;
    dy += y1 - 1;
    return move(k2, yindex, 0, dy);
  };

  move = function(j, k, dx, dy) {
    var i, _k, _results;
    i = 0;
    _results = [];
    for (i = _k = j; j <= k ? _k < k : _k > k; i = j <= k ? ++_k : --_k) {
      chartab[i].x += dx;
      _results.push(chartab[i].y += dy);
    }
    return _results;
  };

  get_size = function(j, k) {
    var h, i, max_x, max_y, min_x, min_y, w, y, _k, _ref;
    i = 0;
    min_x = chartab[j].x;
    max_x = chartab[j].x;
    min_y = chartab[j].y;
    max_y = chartab[j].y;
    for (i = _k = _ref = j + 1; _ref <= k ? _k < k : _k > k; i = _ref <= k ? ++_k : --_k) {
      if (chartab[i].x < min_x) {
        min_x = chartab[i].x;
      }
      if (chartab[i].x > max_x) {
        max_x = chartab[i].x;
      }
      if (chartab[i].y < min_y) {
        min_y = chartab[i].y;
      }
      if (chartab[i].y > max_y) {
        max_y = chartab[i].y;
      }
    }
    h = max_y - min_y + 1;
    w = max_x - min_x + 1;
    y = min_y;
    return [h, w, y];
  };

  displaychar = function(c) {
    return __emit_char(c);
  };

  __emit_char = function(c) {
    if (yindex === YMAX) {
      return;
    }
    if (chartab[yindex] == null) {
      debugger;
    }
    chartab[yindex].c = c;
    chartab[yindex].x = emit_x;
    chartab[yindex].y = 0;
    yindex++;
    return emit_x++;
  };

  __emit_str = function(s) {
    var i, _k, _ref, _results;
    i = 0;
    _results = [];
    for (i = _k = 0, _ref = s.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
      _results.push(__emit_char(s[i]));
    }
    return _results;
  };

  emit_number = function(p, emit_sign) {
    var i, tmpString, _k, _l, _m, _ref, _ref1, _ref2, _results, _results1;
    tmpString = "";
    i = 0;
    switch (p.k) {
      case NUM:
        tmpString = p.q.a.toString();
        if (tmpString[0] === '-' && emit_sign === 0) {
          tmpString = tmpString.substring(1);
        }
        for (i = _k = 0, _ref = tmpString.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
          __emit_char(tmpString[i]);
        }
        tmpString = p.q.b.toString();
        if (tmpString === "1") {
          break;
        }
        __emit_char('/');
        _results = [];
        for (i = _l = 0, _ref1 = tmpString.length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
          _results.push(__emit_char(tmpString[i]));
        }
        return _results;
        break;
      case DOUBLE:
        tmpString = doubleToReasonableString(p.d);
        if (tmpString[0] === '-' && emit_sign === 0) {
          tmpString = tmpString.substring(1);
        }
        _results1 = [];
        for (i = _m = 0, _ref2 = tmpString.length; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; i = 0 <= _ref2 ? ++_m : --_m) {
          _results1.push(__emit_char(tmpString[i]));
        }
        return _results1;
    }
  };

  cmpGlyphs = function(a, b) {
    if (a.y < b.y) {
      return -1;
    }
    if (a.y > b.y) {
      return 1;
    }
    if (a.x < b.x) {
      return -1;
    }
    if (a.x > b.x) {
      return 1;
    }
    return 0;
  };

  print_it = function() {
    var accumulatedPrint, i, subsetOfStack, x, y, _k;
    i = 0;
    accumulatedPrint = "";
    subsetOfStack = chartab.slice(0, yindex);
    subsetOfStack.sort(cmpGlyphs);
    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
    x = 0;
    y = chartab[0].y;
    for (i = _k = 0; 0 <= yindex ? _k < yindex : _k > yindex; i = 0 <= yindex ? ++_k : --_k) {
      while (chartab[i].y > y) {
        accumulatedPrint = printchar('\n', accumulatedPrint);
        x = 0;
        y++;
      }
      while (chartab[i].x > x) {
        accumulatedPrint = printchar_nowrap(' ', accumulatedPrint);
        x++;
      }
      accumulatedPrint = printchar_nowrap(chartab[i].c, accumulatedPrint);
      x++;
    }
    if (PRINTOUTRESULT) {
      return console.log(accumulatedPrint);
    }
  };

  buffer = "";

  getdisplaystr = function() {
    yindex = 0;
    level = 0;
    emit_x = 0;
    emit_expr(pop());
    fill_buf();
    return buffer;
  };

  fill_buf = function() {
    var i, sIndex, subsetOfStack, tmpBuffer, x, y, _k;
    tmpBuffer = buffer;
    sIndex = 0;
    i = 0;
    subsetOfStack = chartab.slice(0, yindex);
    subsetOfStack.sort(cmpGlyphs);
    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
    x = 0;
    y = chartab[0].y;
    for (i = _k = 0; 0 <= yindex ? _k < yindex : _k > yindex; i = 0 <= yindex ? ++_k : --_k) {
      while (chartab[i].y > y) {
        tmpBuffer[sIndex++] = '\n';
        x = 0;
        y++;
      }
      while (chartab[i].x > x) {
        tmpBuffer[sIndex++] = ' ';
        x++;
      }
      tmpBuffer[sIndex++] = chartab[i].c;
      x++;
    }
    return tmpBuffer[sIndex++] = '\n';
  };

  N = 100;

  oneElement = (function() {
    function oneElement() {}

    oneElement.prototype.x = 0;

    oneElement.prototype.y = 0;

    oneElement.prototype.h = 0;

    oneElement.prototype.w = 0;

    oneElement.prototype.index = 0;

    oneElement.prototype.count = 0;

    return oneElement;

  })();

  elem = [];

  for (elelmIndex = _k = 0; _k < 10000; elelmIndex = ++_k) {
    elem[elelmIndex] = new oneElement;
  }

  SPACE_BETWEEN_COLUMNS = 3;

  SPACE_BETWEEN_ROWS = 1;

  emit_tensor = function(p) {
    var col, dx, dy, eh, ew, h, i, n, ncol, nrow, row, w, x, y, _l, _m, _n, _o, _ref;
    i = 0;
    n = 0;
    nrow = 0;
    ncol = 0;
    x = 0;
    y = 0;
    h = 0;
    w = 0;
    dx = 0;
    dy = 0;
    eh = 0;
    ew = 0;
    row = 0;
    col = 0;
    if (p.tensor.ndim > 2) {
      emit_flat_tensor(p);
      return;
    }
    nrow = p.tensor.dim[0];
    if (p.tensor.ndim === 2) {
      ncol = p.tensor.dim[1];
    } else {
      ncol = 1;
    }
    n = nrow * ncol;
    if (n > N) {
      emit_flat_tensor(p);
      return;
    }
    x = emit_x;
    for (i = _l = 0; 0 <= n ? _l < n : _l > n; i = 0 <= n ? ++_l : --_l) {
      elem[i].index = yindex;
      elem[i].x = emit_x;
      emit_expr(p.tensor.elem[i]);
      elem[i].count = yindex - elem[i].index;
      _ref = get_size(elem[i].index, yindex), elem[i].h = _ref[0], elem[i].w = _ref[1], elem[i].y = _ref[2];
    }
    eh = 0;
    ew = 0;
    for (i = _m = 0; 0 <= n ? _m < n : _m > n; i = 0 <= n ? ++_m : --_m) {
      if (elem[i].h > eh) {
        eh = elem[i].h;
      }
      if (elem[i].w > ew) {
        ew = elem[i].w;
      }
    }
    h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;
    w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;
    y = -(h / 2);
    for (row = _n = 0; 0 <= nrow ? _n < nrow : _n > nrow; row = 0 <= nrow ? ++_n : --_n) {
      for (col = _o = 0; 0 <= ncol ? _o < ncol : _o > ncol; col = 0 <= ncol ? ++_o : --_o) {
        i = row * ncol + col;
        dx = x - elem[i].x;
        dy = y - elem[i].y;
        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
        dx = 0;
        if (col > 0) {
          dx = col * (ew + SPACE_BETWEEN_COLUMNS);
        }
        dy = 0;
        if (row > 0) {
          dy = row * (eh + SPACE_BETWEEN_ROWS);
        }
        dx += (ew - elem[i].w) / 2;
        dy += (eh - elem[i].h) / 2;
        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
      }
    }
    return emit_x = x + w;

    /*
    	if 0
    
    		 * left brace
    
    		for (i = 0; i < h; i++) {
    			if (yindex == YMAX)
    				break
    			chartab[yindex].c = '|'
    			chartab[yindex].x = x - 2
    			chartab[yindex].y = y + i
    			yindex++
    		}
    
    		 * right brace
    
    		emit_x++
    
    		for (i = 0; i < h; i++) {
    			if (yindex == YMAX)
    				break
    			chartab[yindex].c = '|'
    			chartab[yindex].x = emit_x
    			chartab[yindex].y = y + i
    			yindex++
    		}
    
    		emit_x++
    
    	endif
     */
  };

  emit_flat_tensor = function(p) {
    return emit_tensor_inner(p, 0, 0);
  };

  emit_tensor_inner = function(p, j, k) {
    var i, _l, _ref;
    i = 0;
    __emit_char('(');
    for (i = _l = 0, _ref = p.tensor.dim[j]; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
      if (j + 1 === p.tensor.ndim) {
        emit_expr(p.tensor.elem[k]);
        k = k + 1;
      } else {
        k = emit_tensor_inner(p, j + 1, k);
      }
      if (i + 1 < p.tensor.dim[j]) {
        __emit_char(',');
      }
    }
    __emit_char(')');
    return k;
  };


  /*
  void
  test_display(void)
  {
  	test(__FILE__, s, sizeof s / sizeof (char *))
  }
  
  #endif
   */

  Find = function(p, q) {
    var i, _l, _ref;
    i = 0;
    if (equal(p, q)) {
      return 1;
    }
    if (istensor(p)) {
      for (i = _l = 0, _ref = p.tensor.nelem; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
        if (Find(p.tensor.elem[i], q)) {
          return 1;
        }
      }
      return 0;
    }
    while (iscons(p)) {
      if (Find(car(p), q)) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  };

  $.Find = Find;

  init = function() {
    var i, _l, _m;
    i = 0;
    flag = 0;
    tos = 0;
    esc_flag = 0;
    draw_flag = 0;
    frame = TOS;
    if (flag) {
      return;
    }
    flag = 1;
    for (i = _l = 0; 0 <= NSYM ? _l < NSYM : _l > NSYM; i = 0 <= NSYM ? ++_l : --_l) {
      symtab[i] = new U();
    }
    for (i = _m = 0; 0 <= NSYM ? _m < NSYM : _m > NSYM; i = 0 <= NSYM ? ++_m : --_m) {
      symtab[i].k = SYM;
      binding[i] = symtab[i];
      arglist[i] = symbol(NIL);
    }
    p0 = symbol(NIL);
    p1 = symbol(NIL);
    p2 = symbol(NIL);
    p3 = symbol(NIL);
    p4 = symbol(NIL);
    p5 = symbol(NIL);
    p6 = symbol(NIL);
    p7 = symbol(NIL);
    p8 = symbol(NIL);
    p9 = symbol(NIL);
    std_symbol("abs", ABS);
    std_symbol("add", ADD);
    std_symbol("adj", ADJ);
    std_symbol("and", AND);
    std_symbol("arccos", ARCCOS);
    std_symbol("arccosh", ARCCOSH);
    std_symbol("arcsin", ARCSIN);
    std_symbol("arcsinh", ARCSINH);
    std_symbol("arctan", ARCTAN);
    std_symbol("arctanh", ARCTANH);
    std_symbol("arg", ARG);
    std_symbol("atomize", ATOMIZE);
    std_symbol("besselj", BESSELJ);
    std_symbol("bessely", BESSELY);
    std_symbol("binding", BINDING);
    std_symbol("binomial", BINOMIAL);
    std_symbol("ceiling", CEILING);
    std_symbol("check", CHECK);
    std_symbol("choose", CHOOSE);
    std_symbol("circexp", CIRCEXP);
    std_symbol("clear", CLEAR);
    std_symbol("clock", CLOCK);
    std_symbol("coeff", COEFF);
    std_symbol("cofactor", COFACTOR);
    std_symbol("condense", CONDENSE);
    std_symbol("conj", CONJ);
    std_symbol("contract", CONTRACT);
    std_symbol("cos", COS);
    std_symbol("cosh", COSH);
    std_symbol("decomp", DECOMP);
    std_symbol("defint", DEFINT);
    std_symbol("deg", DEGREE);
    std_symbol("denominator", DENOMINATOR);
    std_symbol("det", DET);
    std_symbol("derivative", DERIVATIVE);
    std_symbol("dim", DIM);
    std_symbol("dirac", DIRAC);
    std_symbol("display", DISPLAY);
    std_symbol("divisors", DIVISORS);
    std_symbol("do", DO);
    std_symbol("dot", DOT);
    std_symbol("draw", DRAW);
    std_symbol("dsolve", DSOLVE);
    std_symbol("erf", ERF);
    std_symbol("erfc", ERFC);
    std_symbol("eigen", EIGEN);
    std_symbol("eigenval", EIGENVAL);
    std_symbol("eigenvec", EIGENVEC);
    std_symbol("eval", EVAL);
    std_symbol("exp", EXP);
    std_symbol("expand", EXPAND);
    std_symbol("expcos", EXPCOS);
    std_symbol("expsin", EXPSIN);
    std_symbol("factor", FACTOR);
    std_symbol("factorial", FACTORIAL);
    std_symbol("factorpoly", FACTORPOLY);
    std_symbol("filter", FILTER);
    std_symbol("float", FLOATF);
    std_symbol("floor", FLOOR);
    std_symbol("for", FOR);
    std_symbol("Gamma", GAMMA);
    std_symbol("gcd", GCD);
    std_symbol("hermite", HERMITE);
    std_symbol("hilbert", HILBERT);
    std_symbol("imag", IMAG);
    std_symbol("component", INDEX);
    std_symbol("inner", INNER);
    std_symbol("integral", INTEGRAL);
    std_symbol("inv", INV);
    std_symbol("invg", INVG);
    std_symbol("isinteger", ISINTEGER);
    std_symbol("isprime", ISPRIME);
    std_symbol("laguerre", LAGUERRE);
    std_symbol("lcm", LCM);
    std_symbol("leading", LEADING);
    std_symbol("legendre", LEGENDRE);
    std_symbol("log", LOG);
    std_symbol("mag", MAG);
    std_symbol("mod", MOD);
    std_symbol("multiply", MULTIPLY);
    std_symbol("not", NOT);
    std_symbol("nroots", NROOTS);
    std_symbol("number", NUMBER);
    std_symbol("numerator", NUMERATOR);
    std_symbol("operator", OPERATOR);
    std_symbol("or", OR);
    std_symbol("outer", OUTER);
    std_symbol("polar", POLAR);
    std_symbol("power", POWER);
    std_symbol("prime", PRIME);
    std_symbol("print", PRINT);
    std_symbol("product", PRODUCT);
    std_symbol("quote", QUOTE);
    std_symbol("quotient", QUOTIENT);
    std_symbol("rank", RANK);
    std_symbol("rationalize", RATIONALIZE);
    std_symbol("real", REAL);
    std_symbol("rect", YYRECT);
    std_symbol("roots", ROOTS);
    std_symbol("equals", SETQ);
    std_symbol("sgn", SGN);
    std_symbol("simplify", SIMPLIFY);
    std_symbol("sin", SIN);
    std_symbol("sinh", SINH);
    std_symbol("sqrt", SQRT);
    std_symbol("stop", STOP);
    std_symbol("subst", SUBST);
    std_symbol("sum", SUM);
    std_symbol("tan", TAN);
    std_symbol("tanh", TANH);
    std_symbol("taylor", TAYLOR);
    std_symbol("test", TEST);
    std_symbol("testeq", TESTEQ);
    std_symbol("testge", TESTGE);
    std_symbol("testgt", TESTGT);
    std_symbol("testle", TESTLE);
    std_symbol("testlt", TESTLT);
    std_symbol("transpose", TRANSPOSE);
    std_symbol("unit", UNIT);
    std_symbol("zero", ZERO);
    std_symbol("nil", NIL);
    std_symbol("autoexpand", AUTOEXPAND);
    std_symbol("bake", BAKE);
    std_symbol("last", LAST);
    std_symbol("trace", TRACE);
    std_symbol("tty", TTY);
    std_symbol("~", YYE);
    std_symbol("$DRAWX", DRAWX);
    std_symbol("$METAA", METAA);
    std_symbol("$METAB", METAB);
    std_symbol("$METAX", METAX);
    std_symbol("$SECRETX", SECRETX);
    std_symbol("pi", PI);
    std_symbol("a", SYMBOL_A);
    std_symbol("b", SYMBOL_B);
    std_symbol("c", SYMBOL_C);
    std_symbol("d", SYMBOL_D);
    std_symbol("i", SYMBOL_I);
    std_symbol("j", SYMBOL_J);
    std_symbol("n", SYMBOL_N);
    std_symbol("r", SYMBOL_R);
    std_symbol("s", SYMBOL_S);
    std_symbol("t", SYMBOL_T);
    std_symbol("x", SYMBOL_X);
    std_symbol("y", SYMBOL_Y);
    std_symbol("z", SYMBOL_Z);
    std_symbol("$C1", C1);
    std_symbol("$C2", C2);
    std_symbol("$C3", C3);
    std_symbol("$C4", C4);
    std_symbol("$C5", C5);
    std_symbol("$C6", C6);
    push_integer(0);
    zero = pop();
    push_integer(1);
    one = pop();
    push_symbol(POWER);
    if (DEBUG) {
      print1(stack[tos - 1]);
    }
    push_integer(-1);
    if (DEBUG) {
      print1(stack[tos - 1]);
    }
    push_rational(1, 2);
    if (DEBUG) {
      print1(stack[tos - 1]);
    }
    list(3);
    if (DEBUG) {
      print1(stack[tos - 1]);
    }
    imaginaryunit = pop();
    return defn();
  };

  defn_str = ["e=exp(1)", "i=sqrt(-1)", "autoexpand=1", "trange=(-pi,pi)", "xrange=(-10,10)", "yrange=(-10,10)", "last=0", "trace=0", "tty=0", "cross(u,v)=(u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1])", "curl(v)=(d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y))", "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)", "ln(x)=log(x)"];

  defn = function() {
    var definitionOfInterest, defn_i, _l, _ref, _results;
    _results = [];
    for (defn_i = _l = 0, _ref = defn_str.length; 0 <= _ref ? _l < _ref : _l > _ref; defn_i = 0 <= _ref ? ++_l : --_l) {
      definitionOfInterest = defn_str[defn_i];
      scan(definitionOfInterest);
      if (DEBUG) {
        console.log("... evaling " + definitionOfInterest);
        console.log("top of stack:");
        print1(stack[tos - 1]);
      }
      Eval();
      _results.push(pop());
    }
    return _results;
  };

  mcmp = function(a, b) {
    return a.compare(b);
  };

  mcmpint = function(a, n) {
    var b, t;
    b = bigInt(n);
    t = mcmp(a, b);
    return t;
  };


  /*
  #if SELFTEST
  
  void
  test_mcmp(void)
  {
  	int i, j, k
  	unsigned int *x, *y
  	logout("testing mcmp\n")
  	for (i = -1000; i < 1000; i++) {
  		x = mint(i)
  		for (j = -1000; j < 1000; j++) {
  			y = mint(j)
  			k = mcmp(x, y)
  			if (i == j && k != 0) {
  				logout("failed\n")
  				errout()
  			}
  			if (i < j && k != -1) {
  				logout("failed\n")
  				errout()
  			}
  			if (i > j && k != 1) {
  				logout("failed\n")
  				errout()
  			}
  			mfree(y)
  		}
  		mfree(x)
  	}
  	logout("ok\n")
  }
  
  #endif
   */

  strcmp = function(str1, str2) {
    if (str1 === str2) {
      return 0;
    } else if (str1 > str2) {
      return 1;
    } else {
      return -1;
    }
  };

  doubleToReasonableString = function(d) {
    return parseFloat(d.toPrecision(6));
  };

  clear_term = function() {};

  isspace = function(s) {
    if (s == null) {
      return false;
    }
    return s === ' ' || s === '\t' || s === '\n' || s === '\v' || s === '\f' || s === '\r';
  };

  isdigit = function(str) {
    if (str == null) {
      return false;
    }
    return /^\d+$/.test(str);
  };

  isalpha = function(str) {
    if (str == null) {
      return false;
    }
    if (str == null) {
      debugger;
    }
    return str.search(/[^A-Za-z]/) === -1;
  };

  isalnum = function(str) {
    if (str == null) {
      return false;
    }
    return isalpha(str) || isdigit(str);
  };

  stop = function(s) {
    var message;
    errorMessage += "Stop: ";
    errorMessage += s;
    message = errorMessage;
    errorMessage = '';
    tos = 0;
    throw new Error(message);
  };

  inited = false;

  run = function(stringToBeRun) {
    var allReturnedStrings, collectedResult, error, i, indexOfPartRemainingToBeParsed, n;
    stringToBeRun = stringToBeRun;
    if (stringToBeRun === "selftest") {
      selftest();
      return;
    }
    if (!inited) {
      inited = true;
      init();
    }
    i = 0;
    n = 0;
    indexOfPartRemainingToBeParsed = 0;
    allReturnedStrings = "";
    while (1.) {
      try {
        errorMessage = "";
        check_stack();
        n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));
        p1 = pop();
        check_stack();
      } catch (_error) {
        error = _error;
        if (PRINTOUTRESULT) {
          console.log(error);
        }
        allReturnedStrings += error.message;
        init();
        break;
      }
      if (n === 0) {
        break;
      }
      indexOfPartRemainingToBeParsed += n;
      push(p1);
      try {
        top_level_eval();
        p2 = pop();
        check_stack();
        if (p2 === symbol(NIL)) {
          continue;
        }
        if (isstr(p2)) {
          console.log(p2.str);
          console.log("\n");
          continue;
        }
        collectedResult = collectResultLine(p2);
        allReturnedStrings += collectedResult;
        if (PRINTOUTRESULT) {
          console.log("printline");
          console.log(collectedResult);
        }
        if (PRINTOUTRESULT) {
          console.log("display:");
          display(p2);
        }
        allReturnedStrings += "\n";
      } catch (_error) {
        error = _error;
        collectedResult = error.message;
        if (PRINTOUTRESULT) {
          console.log(collectedResult);
        }
        allReturnedStrings += collectedResult;
        allReturnedStrings += "\n";
        init();
      }
    }
    if (allReturnedStrings[allReturnedStrings.length - 1] === "\n") {
      allReturnedStrings = allReturnedStrings.substring(0, allReturnedStrings.length - 1);
    }
    return allReturnedStrings;
  };

  check_stack = function() {
    if (tos !== 0) {
      debugger;
      stop("stack error");
    }
    if (frame !== TOS) {
      debugger;
      return stop("frame error");
    }
  };

  echo_input = function(s) {
    console.log(s);
    return console.log("\n");
  };

  top_level_eval = function() {
    var doNothing;
    if (DEBUG) {
      console.log("#### top level eval");
    }
    save();
    trigmode = 0;
    p1 = symbol(AUTOEXPAND);
    if (iszero(get_binding(p1))) {
      expanding = 0;
    } else {
      expanding = 1;
    }
    p1 = pop();
    push(p1);
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push(p2);
      restore();
      return;
    }
    set_binding(symbol(LAST), p2);
    if (!iszero(get_binding(symbol(BAKE)))) {
      push(p2);
      bake();
      p2 = pop();
    }
    if ((p1 === symbol(SYMBOL_I) || p1 === symbol(SYMBOL_J)) && isimaginaryunit(p2)) {
      doNothing = 0;
    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {
      push(p2);
      push(imaginaryunit);
      push_symbol(SYMBOL_J);
      subst();
      p2 = pop();
    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {
      push(p2);
      push(imaginaryunit);
      push_symbol(SYMBOL_I);
      subst();
      p2 = pop();
    }
    push(p2);
    return restore();
  };

  check_esc_flag = function() {
    if (esc_flag) {
      return stop("esc key");
    }
  };

  (typeof exports !== "undefined" && exports !== null ? exports : this).run = run;

  tos = 0;

  nil_symbols = 0;

  push = function(p) {
    if (p == null) {
      debugger;
    }
    if (p.isZero != null) {
      debugger;
    }
    if (p === symbol(NIL)) {
      nil_symbols++;
      if (DEBUG) {
        console.log("pushing symbol(NIL) #" + nil_symbols);
      }
    }
    if (tos >= frame) {
      stop("stack overflow");
    }
    return stack[tos++] = p;
  };

  pop = function() {
    var elementToBeReturned;
    if (tos === 0) {
      debugger;
      stop("stack underflow");
    }
    if (stack[tos - 1] == null) {
      debugger;
    }
    elementToBeReturned = stack[--tos];
    return elementToBeReturned;
  };

  push_frame = function(n) {
    var i, _l, _results;
    i = 0;
    frame -= n;
    if (frame < tos) {
      debugger;
      stop("frame overflow, circular reference?");
    }
    _results = [];
    for (i = _l = 0; 0 <= n ? _l < n : _l > n; i = 0 <= n ? ++_l : --_l) {
      _results.push(stack[frame + i] = symbol(NIL));
    }
    return _results;
  };

  pop_frame = function(n) {
    frame += n;
    if (frame > TOS) {
      return stop("frame underflow");
    }
  };

  save = function() {
    frame -= 10;
    if (frame < tos) {
      debugger;
      stop("frame overflow, circular reference?");
    }
    stack[frame + 0] = p0;
    stack[frame + 1] = p1;
    stack[frame + 2] = p2;
    stack[frame + 3] = p3;
    stack[frame + 4] = p4;
    stack[frame + 5] = p5;
    stack[frame + 6] = p6;
    stack[frame + 7] = p7;
    stack[frame + 8] = p8;
    return stack[frame + 9] = p9;
  };

  restore = function() {
    if (frame > TOS - 10) {
      stop("frame underflow");
    }
    p0 = stack[frame + 0];
    p1 = stack[frame + 1];
    p2 = stack[frame + 2];
    p3 = stack[frame + 3];
    p4 = stack[frame + 4];
    p5 = stack[frame + 5];
    p6 = stack[frame + 6];
    p7 = stack[frame + 7];
    p8 = stack[frame + 8];
    p9 = stack[frame + 9];
    return frame += 10;
  };

  swap = function() {
    var p, q;
    p = pop();
    q = pop();
    push(p);
    return push(q);
  };

  dupl = function() {
    var p;
    p = pop();
    push(p);
    return push(p);
  };

  $.dupl = dupl;

  $.swap = swap;

  $.restore = restore;

  $.save = save;

  $.push = push;

  $.pop = pop;

  std_symbol = function(s, n) {
    var p;
    p = symtab[n];
    if (p == null) {
      debugger;
    }
    return p.printname = s;
  };

  usr_symbol = function(s) {
    var i, p, _l;
    i = 0;
    for (i = _l = 0; 0 <= NSYM ? _l < NSYM : _l > NSYM; i = 0 <= NSYM ? ++_l : --_l) {
      if (symtab[i].printname === "") {
        break;
      }
      if (s === symtab[i].printname) {
        return symtab[i];
      }
    }
    if (i === NSYM) {
      stop("symbol table overflow");
    }
    p = symtab[i];
    p.printname = s;
    return p;
  };

  get_printname = function(p) {
    if (p.k !== SYM) {
      stop("symbol error");
    }
    return p.printname;
  };

  set_binding = function(p, q) {
    var indexFound;
    if (p.k !== SYM) {
      stop("symbol error");
    }
    indexFound = symtab.indexOf(p);
    if (symtab.indexOf(p, indexFound + 1) !== -1) {
      console.log("ops, more than one element!");
      debugger;
    }
    if (DEBUG) {
      console.log("lookup >> set_binding lookup " + indexFound);
    }
    binding[indexFound] = q;
    return arglist[indexFound] = symbol(NIL);
  };

  get_binding = function(p) {
    var indexFound;
    if (p.k !== SYM) {
      stop("symbol error");
    }
    indexFound = symtab.indexOf(p);
    if (symtab.indexOf(p, indexFound + 1) !== -1) {
      console.log("ops, more than one element!");
      debugger;
    }
    if (DEBUG) {
      console.log("lookup >> get_binding lookup " + indexFound);
    }
    return binding[indexFound];
  };

  set_binding_and_arglist = function(p, q, r) {
    var indexFound;
    if (p.k !== SYM) {
      stop("symbol error");
    }
    indexFound = symtab.indexOf(p);
    if (symtab.indexOf(p, indexFound + 1) !== -1) {
      console.log("ops, more than one element!");
      debugger;
    }
    if (DEBUG) {
      console.log("lookup >> set_binding_and_arglist lookup " + indexFound);
    }
    binding[indexFound] = q;
    return arglist[indexFound] = r;
  };

  get_arglist = function(p) {
    var indexFound;
    if (p.k !== SYM) {
      stop("symbol error");
    }
    indexFound = symtab.indexOf(p);
    if (symtab.indexOf(p, indexFound + 1) !== -1) {
      console.log("ops, more than one element!");
      debugger;
    }
    if (DEBUG) {
      console.log("lookup >> get_arglist lookup " + indexFound);
    }
    return arglist[indexFound];
  };

  lookupsTotal = 0;

  symnum = function(p) {
    var indexFound;
    lookupsTotal++;
    if (p.k !== SYM) {
      stop("symbol error");
    }
    indexFound = symtab.indexOf(p);
    if (symtab.indexOf(p, indexFound + 1) !== -1) {
      console.log("ops, more than one element!");
      debugger;
    }
    if (DEBUG) {
      console.log("lookup >> symnum lookup " + indexFound + " lookup # " + lookupsTotal);
    }
    return indexFound;
  };

  push_symbol = function(k) {
    return push(symtab[k]);
  };

  clear_symbols = function() {
    var i, _l, _results;
    i = 0;
    _results = [];
    for (i = _l = 0; 0 <= NSYM ? _l < NSYM : _l > NSYM; i = 0 <= NSYM ? ++_l : --_l) {
      binding[i] = symtab[i];
      _results.push(arglist[i] = symbol(NIL));
    }
    return _results;
  };

  $.get_binding = get_binding;

  $.set_binding = set_binding;

  $.usr_symbol = usr_symbol;

  if (!inited) {
    inited = true;
    init();
  }

  $.init = init;

  parse_internal = function(argu) {
    if (typeof argu === 'string') {
      return scan(argu);
    } else if (typeof argu === 'number') {
      if (argu % 1 === 0) {
        return push_integer(argu);
      } else {
        return push_double(argu);
      }
    } else if (argu instanceof U) {
      return push(argu);
    } else {
      console.warn('unknown argument type', argu);
      return push(symbol(NIL));
    }
  };

  parse = function(argu) {
    parse_internal(argu);
    return pop();
  };

  exec = function() {
    var argu, argus, error, fn, name, result, _l, _len;
    name = arguments[0], argus = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    fn = get_binding(usr_symbol(name));
    check_stack();
    push(fn);
    for (_l = 0, _len = argus.length; _l < _len; _l++) {
      argu = argus[_l];
      parse_internal(argu);
    }
    list(1 + argus.length);
    p1 = pop();
    push(p1);
    try {
      fixed_top_level_eval();
      result = pop();
      check_stack();
    } catch (_error) {
      error = _error;
      reset_after_error();
      throw error;
    }
    return result;
  };

  reset_after_error = function() {
    tos = 0;
    esc_flag = 0;
    draw_flag = 0;
    return frame = TOS;
  };

  fixed_top_level_eval = function() {
    save();
    trigmode = 0;
    p1 = symbol(AUTOEXPAND);
    if (iszero(get_binding(p1))) {
      expanding = 0;
    } else {
      expanding = 1;
    }
    p1 = pop();
    push(p1);
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push(p2);
      restore();
      return;
    }
    if (!iszero(get_binding(symbol(BAKE)))) {
      push(p2);
      bake();
      p2 = pop();
    }
    push(p2);
    return restore();
  };

  $.exec = exec;

  $.parse = parse;

  (function() {
    var builtin_fns, fn, _l, _len, _results;
    builtin_fns = ["abs", "add", "adj", "and", "arccos", "arccosh", "arcsin", "arcsinh", "arctan", "arctanh", "arg", "atomize", "besselj", "bessely", "binding", "binomial", "ceiling", "check", "choose", "circexp", "clear", "clock", "coeff", "cofactor", "condense", "conj", "contract", "cos", "cosh", "decomp", "defint", "deg", "denominator", "det", "derivative", "dim", "dirac", "display", "divisors", "do", "dot", "draw", "dsolve", "erf", "erfc", "eigen", "eigenval", "eigenvec", "eval", "exp", "expand", "expcos", "expsin", "factor", "factorial", "factorpoly", "filter", "float", "floor", "for", "Gamma", "gcd", "hermite", "hilbert", "imag", "component", "inner", "integral", "inv", "invg", "isinteger", "isprime", "laguerre", "lcm", "leading", "legendre", "log", "mag", "mod", "multiply", "not", "nroots", "number", "numerator", "operator", "or", "outer", "polar", "power", "prime", "print", "product", "quote", "quotient", "rank", "rationalize", "real", "rect", "roots", "equals", "sgn", "simplify", "sin", "sinh", "sqrt", "stop", "subst", "sum", "tan", "tanh", "taylor", "test", "testeq", "testge", "testgt", "testle", "testlt", "transpose", "unit", "zero"];
    _results = [];
    for (_l = 0, _len = builtin_fns.length; _l < _len; _l++) {
      fn = builtin_fns[_l];
      _results.push($[fn] = exec.bind(this, fn));
    }
    return _results;
  })();

}).call(this);
