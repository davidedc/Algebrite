// Generated by CoffeeScript 1.10.0
var ABS, ADD, ADJ, AND, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BINOM_check_args, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, Condense, DEBUG, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DIM, DIRAC, DISPLAY, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_adj, Eval_and, Eval_arccos, Eval_arccosh, Eval_arcsin, Eval_arcsinh, Eval_arctan, Eval_arctanh, Eval_arg, Eval_besselj, Eval_bessely, Eval_binding, Eval_binomial, Eval_ceiling, Eval_check, Eval_choose, Eval_circexp, Eval_clear, Eval_clock, Eval_coeff, Eval_cofactor, Eval_condense, Eval_conj, Eval_cons, Eval_contract, Eval_cos, Eval_cosh, Eval_decomp, Eval_defint, Eval_degree, Eval_denominator, Eval_derivative, Eval_det, Eval_dim, Eval_dirac, Eval_divisors, Eval_do, Eval_dsolve, Eval_erf, Eval_erfc, Eval_exp, Eval_expand, Eval_expcos, Eval_expsin, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_filter, Eval_float, Eval_floor, Eval_gamma, Eval_gcd, Eval_hermite, Eval_hilbert, Eval_imag, Eval_index, Eval_inner, Eval_integral, Eval_inv, Eval_invg, Eval_isinteger, Eval_laguerre, Eval_lcm, Eval_legendre, Eval_log, Eval_mag, Eval_mod, Eval_multiply, Eval_noexpand, Eval_not, Eval_nroots, Eval_number, Eval_numerator, Eval_operator, Eval_or, Eval_outer, Eval_polar, Eval_power, Eval_predicate, Eval_print, Eval_quote, Eval_quotient, Eval_rank, Eval_rationalize, Eval_real, Eval_rect, Eval_setq, Eval_sgn, Eval_simplify, Eval_sin, Eval_sinh, Eval_sqrt, Eval_stop, Eval_subst, Eval_sym, Eval_tan, Eval_tanh, Eval_taylor, Eval_tensor, Eval_test, Eval_testeq, Eval_testge, Eval_testgt, Eval_testle, Eval_testlt, Eval_transpose, Eval_unit, Eval_user_function, Eval_zero, Evalpoly, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, ISINTEGER, ISPRIME, LAGUERRE, LAST, LCM, LEADING, LEGENDRE, LOG, M, MAG, MAXDIM, MAXPRIMETAB, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MP_MAX_FREE, MP_MIN_SIZE, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NROOTS_ABS, NROOTS_DELTA, NROOTS_EPSILON, NROOTS_RANDOM, NROOTS_YMAX, NROOTS_divpoly, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PI, POLAR, POWER, PRIME, PRINT, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, SECRETX, SELFTEST, SETQ, SGN, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOL_A, SYMBOL_B, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TOS, TRACE, TRANSPOSE, TTY, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEWLINE, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, YMAX, YYE, YYRECT, ZERO, __emit_char, __emit_str, __factor_add, __factorial, __is_negative, __is_radical_number, __lcm, __legendre, __legendre2, __legendre3, __normalize_radical_factors, __rationalize_tensor, absval, absval_tensor, ac, ad, add, add_all, add_numbers, add_terms, addf, adj, alloc_tensor, allocatedId, any_denominators, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, arg, arglist, bake, bake_poly, bake_poly_term, besselj, bessely, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, binomial, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, ceiling, charTabIndex, chartab, check_arg, check_esc_flag, check_stack, choose, choose_check_args, circexp, clear, clear_symbols, clear_term, clockform, cmpGlyphs, cmp_args, cmp_expr, cmp_terms, cmp_terms_count, coeff, cofactor, collectResultLine, combine_factors, combine_gammas, combine_terms, compare_numbers, compare_rationals, compare_tensors, compatible, compute_fa, conjugate, cons, consCount, contract, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, count_denominators, counter, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, decomp, decomp_product, decomp_sum, define_user_function, defn, defn_str, degree, denominator, derf, derfc, derivative, derivative_of_integral, det, determinant, detg, dfunction, dhermite, dirac, display, display_flag, displaychar, divide, divide_numbers, divisors, divisors_onstack, divpoly, dlog, doubleToReasonableString, dpow, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, echo_input, egcd, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, endian, equal, equaln, equalq, erfc, error, errorMessage, esc_flag, expand, expand_get_A, expand_get_AF, expand_get_B, expand_get_C, expand_get_CF, expand_tensor, expanding, expcos, exponential, expr_level, expsin, f1, f2, f3, f4, f5, f9, f_equals_a, factor, factor_a, factor_again, factor_b, factor_number, factor_small_number, factor_term, factorial, factorpoly, factors, factpoly_expo, fill_buf, filter, filter_main, filter_sum, filter_tensor, findroot, fixup_fraction, fixup_power, flag, fmt_index, fmt_level, fmt_x, frame, free_stack, gamma, gamma_of_sum, gammaf, gcd, gcd_expr, gcd_expr_expr, gcd_factor_term, gcd_main, gcd_numbers, gcd_term_factor, gcd_term_term, ge, gen, get_arglist, get_binding, get_factor, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, hermite, hilbert, imag, imaginaryunit, index_function, init, initNRoots, inited, inner, inner_f, input_str, integral, integral_of_form, integral_of_product, integral_of_sum, inv, inverse, invert_number, invg, is_denominator, is_factor, is_small_integer, is_square_matrix, isadd, isalnum, isalpha, iscomplexnumber, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isimaginarynumber, isimaginaryunit, isinteger, isintegerfactor, iskeyword, isminusone, isminusoneoversqrttwo, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isnum, isoneover, isoneoversqrttwo, isplusone, ispoly, ispoly_expr, ispoly_factor, ispoly_term, isposint, ispower, isquarterturn, isrational, isspace, isstr, issymbol, issymbolic, istensor, iszero, ko_tests, laguerre, laguerre2, lcm, legendre, length, lessp, level, list, logarithm, logbuf, logout, lookupsTotal, lu_decomp, madd, mag, makePositive, makeSignSameAs, mask, mcmp, mcmpint, mdiv, mdivrem, meta_mode, mgcd, mint, mmod, mmul, mod, monic, move, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, n_factor_number, negate, negate_expand, negate_noexpand, negate_number, new_string, newline_flag, nil_symbols, normalize_angle, nroots_a, nroots_b, nroots_c, nroots_df, nroots_dx, nroots_fa, nroots_fb, nroots_x, nroots_y, nterms, numerator, numericRootOfPolynomial, o, ok_tests, one, oneElement, out_buf, out_count, out_of_memory, outer, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse_p1, parse_p2, partition, peek, peek2, polar, polycoeff, polyform, pop, pop_double, pop_frame, pop_integer, power, power_str, power_sum, power_tensor, primetab, print1, print_a_over_b, print_char, print_denom, print_double, print_expr, print_factor, print_factorial_function, print_it, print_multiply_sign, print_number, print_str, print_subexpr, print_tensor, print_tensor_inner, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, push_cars, push_double, push_factor, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_term_factors, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, rationalize_coefficients, real, reciprocate, rect, ref, ref1, remove_negative_exponents, restore, rewrite_args, rewrite_args_tensor, run, run_test, s, save, scalar_times_tensor, scan, scan_expression, scan_factor, scan_function_call, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_term, scanned, selftest, setM, setSignTo, set_binding, set_binding_and_arglist, set_component, setq_indexed, sfac_product, sfac_product_f, sgn, sign, sign_of_term, simplify, simplify_main, simplify_polar, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, stop, strcmp, stringToBePrinted, subf, subst, subtract, subtract_numbers, swap, symbol, symnum, symtab, tangent, taylor, tensor, tensor_plus_tensor, tensor_times_scalar, test_abs, test_adj, test_arccos, test_arccosh, test_arcsin, test_arcsinh, test_arctanh, test_arg, test_bake, test_besselj, test_bessely, test_binomial, test_ceiling, test_choose, test_circexp, test_clock, test_coeff, test_cofactor, test_condense, test_contract, test_cos, test_cosh, test_defint, test_denominator, test_derivative, test_dirac, test_divisors, test_erf, test_erfc, test_expand, test_expcos, test_expsin, test_factor_number, test_factorpoly, test_flag, test_float, test_floor, test_gamma, test_gcd, test_hermite, test_imag, test_inner, test_laguerre, test_lcm, test_legendre, test_log, test_low_level, test_madd, test_maddf, test_mag, test_mdiv, test_mdivf, test_mgcd, test_mmod, test_mmodf, test_mmul, test_mmulf, test_mod, test_mpow, test_mprime, test_mroot, test_msub, test_msubf, test_multiply, test_nroots, test_numerator, test_outer, test_polar, test_power, test_quickfactor, test_quotient, test_rationalize, test_real, test_rect, test_scan, test_sgn, test_signs_in_rationals, test_sin, test_sinh, test_tan, test_tanh, test_taylor, test_tensor, test_test, test_transpose, test_zero, text_metric, theRandom, token, token_buf, token_str, top_level_eval, tos, transform, transpose, trigmode, trivial_divide, try_kth_prime, ucmp, unique, unique_f, update_token_buf, usr_symbol, verbosing, will_be_displayed_as_fraction, ybinomial, ycosh, ydirac, yerf, yerfc, yfloor, yindex, ysinh, yyarg, yybesselj, yybessely, yyceiling, yycondense, yycontract, yycosh, yydegree, yydetg, yydivpoly, yyerf, yyerfc, yyexpand, yyfactorpoly, yyfloat, yyfloor, yyhermite, yyhermite2, yyinvg, yylcm, yylog, yymag, yymultiply, yyouter, yypower, yyrationalize, yysgn, yysinh, yytangent, zero;

SELFTEST = 1;

NSYM = 1000;

primetab = [];

rational = (function() {
  function rational() {}

  rational.prototype.a = null;

  rational.prototype.b = null;

  return rational;

})();

U = (function() {
  U.prototype.cons = null;

  U.prototype.printname = "";

  U.prototype.str = "";

  U.prototype.tensor = null;

  U.prototype.q = null;

  U.prototype.d = 0.0;

  U.prototype.k = 0;

  U.prototype.tag = 0;

  function U() {
    this.cons = {};
    this.cons.car = null;
    this.cons.cdr = null;
    this.q = new rational();
  }

  return U;

})();

errorMessage = "";

CONS = 0;

NUM = 1;

DOUBLE = 2;

STR = 3;

TENSOR = 4;

SYM = 5;

counter = 0;

ABS = counter++;

ADD = counter++;

ADJ = counter++;

AND = counter++;

ARCCOS = counter++;

ARCCOSH = counter++;

ARCSIN = counter++;

ARCSINH = counter++;

ARCTAN = counter++;

ARCTANH = counter++;

ARG = counter++;

ATOMIZE = counter++;

BESSELJ = counter++;

BESSELY = counter++;

BINDING = counter++;

BINOMIAL = counter++;

CEILING = counter++;

CHECK = counter++;

CHOOSE = counter++;

CIRCEXP = counter++;

CLEAR = counter++;

CLOCK = counter++;

COEFF = counter++;

COFACTOR = counter++;

CONDENSE = counter++;

CONJ = counter++;

CONTRACT = counter++;

COS = counter++;

COSH = counter++;

DECOMP = counter++;

DEFINT = counter++;

DEGREE = counter++;

DENOMINATOR = counter++;

DERIVATIVE = counter++;

DET = counter++;

DIM = counter++;

DIRAC = counter++;

DISPLAY = counter++;

DIVISORS = counter++;

DO = counter++;

DOT = counter++;

DRAW = counter++;

DSOLVE = counter++;

EIGEN = counter++;

EIGENVAL = counter++;

EIGENVEC = counter++;

ERF = counter++;

ERFC = counter++;

EVAL = counter++;

EXP = counter++;

EXPAND = counter++;

EXPCOS = counter++;

EXPSIN = counter++;

FACTOR = counter++;

FACTORIAL = counter++;

FACTORPOLY = counter++;

FILTER = counter++;

FLOATF = counter++;

FLOOR = counter++;

FOR = counter++;

GAMMA = counter++;

GCD = counter++;

HERMITE = counter++;

HILBERT = counter++;

IMAG = counter++;

INDEX = counter++;

INNER = counter++;

INTEGRAL = counter++;

INV = counter++;

INVG = counter++;

ISINTEGER = counter++;

ISPRIME = counter++;

LAGUERRE = counter++;

LCM = counter++;

LEADING = counter++;

LEGENDRE = counter++;

LOG = counter++;

MAG = counter++;

MOD = counter++;

MULTIPLY = counter++;

NOT = counter++;

NROOTS = counter++;

NUMBER = counter++;

NUMERATOR = counter++;

OPERATOR = counter++;

OR = counter++;

OUTER = counter++;

POLAR = counter++;

POWER = counter++;

PRIME = counter++;

PRINT = counter++;

PRODUCT = counter++;

QUOTE = counter++;

QUOTIENT = counter++;

RANK = counter++;

RATIONALIZE = counter++;

REAL = counter++;

YYRECT = counter++;

ROOTS = counter++;

SETQ = counter++;

SGN = counter++;

SIMPLIFY = counter++;

SIN = counter++;

SINH = counter++;

SQRT = counter++;

STOP = counter++;

SUBST = counter++;

SUM = counter++;

TAN = counter++;

TANH = counter++;

TAYLOR = counter++;

TEST = counter++;

TESTEQ = counter++;

TESTGE = counter++;

TESTGT = counter++;

TESTLE = counter++;

TESTLT = counter++;

TRANSPOSE = counter++;

UNIT = counter++;

ZERO = counter++;

NIL = counter++;

AUTOEXPAND = counter++;

BAKE = counter++;

LAST = counter++;

TRACE = counter++;

TTY = counter++;

YYE = counter++;

DRAWX = counter++;

METAA = counter++;

METAB = counter++;

METAX = counter++;

SECRETX = counter++;

PI = counter++;

SYMBOL_A = counter++;

SYMBOL_B = counter++;

SYMBOL_C = counter++;

SYMBOL_D = counter++;

SYMBOL_I = counter++;

SYMBOL_J = counter++;

SYMBOL_N = counter++;

SYMBOL_R = counter++;

SYMBOL_S = counter++;

SYMBOL_T = counter++;

SYMBOL_X = counter++;

SYMBOL_Y = counter++;

SYMBOL_Z = counter++;

C1 = counter++;

C2 = counter++;

C3 = counter++;

C4 = counter++;

C5 = counter++;

C6 = counter++;

USR_SYMBOLS = counter++;

E = YYE;

TOS = 100000;

BUF = 10000;

MAX_PROGRAM_SIZE = 100001;

MAXPRIMETAB = 10000;

MAXDIM = 24;

tensor = (function() {
  tensor.prototype.ndim = 0;

  tensor.prototype.dim = null;

  tensor.prototype.nelem = 0;

  tensor.prototype.elem = null;

  function tensor() {
    this.dim = (function() {
      var o, ref, results;
      results = [];
      for (o = 0, ref = MAXDIM; 0 <= ref ? o <= ref : o >= ref; 0 <= ref ? o++ : o--) {
        results.push(0);
      }
      return results;
    })();
    this.elem = [];
  }

  return tensor;

})();

display = (function() {
  function display() {}

  display.prototype.h = 0;

  display.prototype.w = 0;

  display.prototype.n = 0;

  display.prototype.a = [];

  return display;

})();

text_metric = (function() {
  function text_metric() {}

  text_metric.prototype.ascent = 0;

  text_metric.prototype.descent = 0;

  text_metric.prototype.width = 0;

  return text_metric;

})();

tos = 0;

expanding = 0;

fmt_x = 0;

fmt_index = 0;

fmt_level = 0;

verbosing = 0;

primetab = [];

primetab[MAXPRIMETAB] = 0;

esc_flag = 0;

draw_flag = 0;

mtotal = 0;

trigmode = 0;

logbuf = "";

program_buf = "";

symtab = [];

binding = [];

arglist = [];

stack = [];

frame = 0;

p0 = null;

p1 = null;

p2 = null;

p3 = null;

p4 = null;

p5 = null;

p6 = null;

p7 = null;

p8 = null;

p9 = null;

zero = null;

one = null;

imaginaryunit = null;

symtab = [];

out_buf = "";

out_count = 0;

test_flag = 0;

draw_stop_return = null;

endian = 0;

symbol = function(x) {
  return symtab[x];
};

iscons = function(p) {
  return p.k === CONS;
};

isrational = function(p) {
  return p.k === NUM;
};

isdouble = function(p) {
  return p.k === DOUBLE;
};

isnum = function(p) {
  return isrational(p) || isdouble(p);
};

isstr = function(p) {
  return p.k === STR;
};

istensor = function(p) {
  if (p == null) {
    debugger;
  } else {
    return p.k === TENSOR;
  }
};

issymbol = function(p) {
  return p.k === SYM;
};

iskeyword = function(p) {
  return issymbol(p) && symnum(p) < NIL;
};

car = function(p) {
  if (iscons(p)) {
    return p.cons.car;
  } else {
    return symbol(NIL);
  }
};

cdr = function(p) {
  if (iscons(p)) {
    return p.cons.cdr;
  } else {
    return symbol(NIL);
  }
};

caar = function(p) {
  return car(car(p));
};

cadr = function(p) {
  return car(cdr(p));
};

cdar = function(p) {
  return cdr(car(p));
};

cddr = function(p) {
  return cdr(cdr(p));
};

caadr = function(p) {
  return car(car(cdr(p)));
};

caddr = function(p) {
  return car(cdr(cdr(p)));
};

cadar = function(p) {
  return car(cdr(car(p)));
};

cdadr = function(p) {
  return cdr(car(cdr(p)));
};

cddar = function(p) {
  return cdr(cdr(car(p)));
};

cdddr = function(p) {
  return cdr(cdr(cdr(p)));
};

caaddr = function(p) {
  return car(car(cdr(cdr(p))));
};

cadadr = function(p) {
  return car(cdr(car(cdr(p))));
};

caddar = function(p) {
  return car(cdr(cdr(car(p))));
};

cdaddr = function(p) {
  return cdr(car(cdr(cdr(p))));
};

cadddr = function(p) {
  return car(cdr(cdr(cdr(p))));
};

cddddr = function(p) {
  return cdr(cdr(cdr(cdr(p))));
};

caddddr = function(p) {
  return car(cdr(cdr(cdr(cdr(p)))));
};

cadaddr = function(p) {
  return car(cdr(car(cdr(cdr(p)))));
};

cddaddr = function(p) {
  return cdr(cdr(car(cdr(cdr(p)))));
};

caddadr = function(p) {
  return car(cdr(cdr(car(cdr(p)))));
};

cdddaddr = function(p) {
  return cdr(cdr(cdr(car(cdr(cdr(p))))));
};

caddaddr = function(p) {
  return car(cdr(cdr(car(cdr(cdr(p))))));
};

isadd = function(p) {
  return car(p) === symbol(ADD);
};

ispower = function(p) {
  return car(p) === symbol(POWER);
};

isfactorial = function(p) {
  return car(p) === symbol(FACTORIAL);
};

MSIGN = function(p) {
  if (p.isPositive()) {
    return 1;
  } else if (p.isZero()) {
    return 0;
  } else {
    return -1;
  }
};

MLENGTH = function(p) {
  return p.toString.length;
};

MZERO = function(p) {
  return p.isZero();
};

MEQUAL = function(p, n) {
  if (p == null) {
    debugger;
  }
  return p.equals(n);
};

Eval_abs = function() {
  push(cadr(p1));
  Eval();
  return absval();
};

absval = function() {
  var h;
  h = 0;
  save();
  p1 = pop();
  if (istensor(p1)) {
    absval_tensor();
    restore();
    return;
  }
  if (isnum(p1)) {
    push(p1);
    if (isnegativenumber(p1)) {
      negate();
    }
    restore();
    return;
  }
  if (iscomplexnumber(p1)) {
    push(p1);
    push(p1);
    conjugate();
    multiply();
    push_rational(1, 2);
    power();
    restore();
    return;
  }
  if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
    push(p1);
    reciprocate();
    absval();
    reciprocate();
    restore();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      absval();
      p1 = cdr(p1);
    }
    multiply_all(tos - h);
    restore();
    return;
  }
  if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {
    push(p1);
    negate();
    p1 = pop();
  }
  push_symbol(ABS);
  push(p1);
  list(2);
  return restore();
};

absval_tensor = function() {
  if (p1.tensor.ndim !== 1) {
    stop("abs(tensor) with tensor rank > 1");
  }
  push(p1);
  push(p1);
  conjugate();
  inner();
  push_rational(1, 2);
  power();
  simplify();
  return Eval();
};

test_abs = function() {
  return run_test(["abs(2)", "2", "abs(2.0)", "2", "abs(-2)", "2", "abs(-2.0)", "2", "abs(a)", "abs(a)", "abs(-a)", "abs(a)", "abs(2*a)", "2*abs(a)", "abs(-2*a)", "2*abs(a)", "abs(2.0*a)", "2*abs(a)", "abs(-2.0*a)", "2*abs(a)", "abs(a-b)+abs(b-a)", "2*abs(a-b)", "abs(3 + 4 i)", "5", "abs((2,3,4))", "29^(1/2)", "abs(a*b)", "abs(a)*abs(b)", "abs(a/b)", "abs(a)/abs(b)", "abs(1/a^b)", "1/(abs(a^b))", "P=(u*cos(v),u*sin(v),v)", "", "abs(cross(d(P,u),d(P,v)))", "(1+u^2)^(1/2)"]);
};


/*
 Symbolic addition

	Terms in a sum are combined if they are identical modulo rational
	coefficients.

	For example, A + 2A becomes 3A.

	However, the sum A + sqrt(2) A is not modified.

	Combining terms can lead to second-order effects.

	For example, consider the case of

		1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A

	The first two terms are combined to yield 2 sqrt(2) A.

	This result can now be combined with the third term to yield

		3 sqrt(2) A
 */

flag = 0;

Eval_add = function() {
  var h;
  h = tos;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    p2 = pop();
    push_terms(p2);
    p1 = cdr(p1);
  }
  return add_terms(tos - h);
};

stackAddsCount = 0;

add_terms = function(n) {
  var ac, ad, h, i, o, ref, ref1, results, s, subsetOfStack;
  stackAddsCount++;
  i = 0;
  h = tos - n;
  s = h;
  console.log("stack before adding terms #" + stackAddsCount);
  if (stackAddsCount === 137) {
    debugger;
  }
  for (i = o = 0, ref = tos; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    print1(stack[i]);
  }
  for (i = ac = 0; ac < 10; i = ++ac) {
    if (n < 2) {
      break;
    }
    flag = 0;
    subsetOfStack = stack.slice(h, h + n);
    subsetOfStack.sort(cmp_terms);
    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
    if (flag === 0) {
      break;
    }
    n = combine_terms(h, n);
  }
  tos = h + n;
  switch (n) {
    case 0:
      push_integer(0);
      break;
    case 1:
      break;
    default:
      list(n);
      p1 = pop();
      push_symbol(ADD);
      push(p1);
      cons();
  }
  console.log("stack after adding terms #" + stackAddsCount);
  if (stackAddsCount === 21) {
    debugger;
  }
  results = [];
  for (i = ad = 0, ref1 = tos; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    results.push(print1(stack[i]));
  }
  return results;
};

cmp_terms_count = 0;

cmp_terms = function(p1, p2) {
  var i, o, ref, t;
  cmp_terms_count++;
  if (cmp_terms_count === 52) {
    debugger;
  }
  i = 0;
  if (isnum(p1) && isnum(p2)) {
    flag = 1;
    return 0;
  }
  if (istensor(p1) && istensor(p2)) {
    if (p1.tensor.ndim < p2.tensor.ndim) {
      return -1;
    }
    if (p1.tensor.ndim > p2.tensor.ndim) {
      return 1;
    }
    for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {
        return -1;
      }
      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {
        return 1;
      }
    }
    flag = 1;
    return 0;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    if (isnum(car(p1))) {
      p1 = cdr(p1);
      if (cdr(p1) === symbol(NIL)) {
        p1 = car(p1);
      }
    }
  }
  if (car(p2) === symbol(MULTIPLY)) {
    p2 = cdr(p2);
    if (isnum(car(p2))) {
      p2 = cdr(p2);
      if (cdr(p2) === symbol(NIL)) {
        p2 = car(p2);
      }
    }
  }
  t = cmp_expr(p1, p2);
  if (t === 0) {
    flag = 1;
  }
  return t;
};


/*
 Compare adjacent terms in s[] and combine if possible.

	Returns the number of terms remaining in s[].

	n	number of terms in s[] initially
 */

combine_terms = function(s, n) {
  var ac, ad, ae, af, i, j, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;
  i = 0;
  while (i < (n - 1)) {
    check_esc_flag();
    p3 = stack[s + i];
    p4 = stack[s + i + 1];
    if (istensor(p3) && istensor(p4)) {
      push(p3);
      push(p4);
      tensor_plus_tensor();
      p1 = pop();
      if (p1 !== symbol(NIL)) {
        stack[s + i] = p1;
        for (j = o = ref = i + 1, ref1 = n - 1; ref <= ref1 ? o < ref1 : o > ref1; j = ref <= ref1 ? ++o : --o) {
          stack[s + j] = stack[s + j + 1];
        }
        n--;
        i--;
      }
      i++;
      continue;
    }
    if (istensor(p3) || istensor(p4)) {
      i++;
      continue;
    }
    if (isnum(p3) && isnum(p4)) {
      push(p3);
      push(p4);
      add_numbers();
      p1 = pop();
      if (iszero(p1)) {
        for (j = ac = ref2 = i, ref3 = n - 2; ref2 <= ref3 ? ac < ref3 : ac > ref3; j = ref2 <= ref3 ? ++ac : --ac) {
          stack[s + j] = stack[s + j + 2];
        }
        n -= 2;
      } else {
        stack[s + i] = p1;
        for (j = ad = ref4 = i + 1, ref5 = n - 1; ref4 <= ref5 ? ad < ref5 : ad > ref5; j = ref4 <= ref5 ? ++ad : --ad) {
          stack[s + j] = stack[s + j + 1];
        }
        n--;
      }
      i--;
      i++;
      continue;
    }
    if (isnum(p3) || isnum(p4)) {
      i++;
      continue;
    }
    p1 = one;
    p2 = one;
    t = 0;
    if (car(p3) === symbol(MULTIPLY)) {
      p3 = cdr(p3);
      t = 1;
      if (isnum(car(p3))) {
        p1 = car(p3);
        p3 = cdr(p3);
        if (cdr(p3) === symbol(NIL)) {
          p3 = car(p3);
          t = 0;
        }
      }
    }
    if (car(p4) === symbol(MULTIPLY)) {
      p4 = cdr(p4);
      if (isnum(car(p4))) {
        p2 = car(p4);
        p4 = cdr(p4);
        if (cdr(p4) === symbol(NIL)) {
          p4 = car(p4);
        }
      }
    }
    if (!equal(p3, p4)) {
      i++;
      continue;
    }
    push(p1);
    push(p2);
    add_numbers();
    p1 = pop();
    if (iszero(p1)) {
      for (j = ae = ref6 = i, ref7 = n - 2; ref6 <= ref7 ? ae < ref7 : ae > ref7; j = ref6 <= ref7 ? ++ae : --ae) {
        stack[s + j] = stack[s + j + 2];
      }
      n -= 2;
      i--;
      i++;
      continue;
    }
    push(p1);
    if (t) {
      push(symbol(MULTIPLY));
      push(p3);
      cons();
    } else {
      push(p3);
    }
    multiply();
    stack[s + i] = pop();
    for (j = af = ref8 = i + 1, ref9 = n - 1; ref8 <= ref9 ? af < ref9 : af > ref9; j = ref8 <= ref9 ? ++af : --af) {
      stack[s + j] = stack[s + j + 1];
    }
    n--;
    i--;
    i++;
  }
  return n;
};

push_terms = function(p) {
  var results;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      push(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else if (!iszero(p)) {
    return push(p);
  }
};

add = function() {
  var h;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  push_terms(p1);
  push_terms(p2);
  add_terms(tos - h);
  return restore();
};

add_all = function(k) {
  var h, i, o, ref, s;
  i = 0;
  save();
  s = tos - k;
  h = tos;
  for (i = o = 0, ref = k; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    push_terms(stack[s + i]);
  }
  add_terms(tos - h);
  p1 = pop();
  tos -= k;
  push(p1);
  return restore();
};

subtract = function() {
  negate();
  return add();
};

Eval_adj = function() {
  push(cadr(p1));
  Eval();
  return adj();
};

adj = function() {
  var ac, doNothing, i, j, n, o, ref, ref1;
  i = 0;
  j = 0;
  n = 0;
  save();
  p1 = pop();
  if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {
    doNothing = 1;
  } else {
    stop("adj: square matrix expected");
  }
  n = p1.tensor.dim[0];
  p2 = alloc_tensor(n * n);
  p2.tensor.ndim = 2;
  p2.tensor.dim[0] = n;
  p2.tensor.dim[1] = n;
  for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
      cofactor(p1, n, i, j);
      p2.tensor.elem[n * j + i] = pop();
    }
  }
  push(p2);
  return restore();
};

test_adj = function() {
  return run_test(["adj(((a,b),(c,d)))", "((d,-b),(-c,a))", "adj(((1,2),(3,4)))", "((4,-2),(-3,1))", "adj(((2,3,-2,5),(6,-2,1,4),(5,10,3,-2),(-1,2,2,3)))", "((-4,-177,-73,194),(-117,117,-99,-27),(310,-129,-44,-374),(-130,-51,71,-211))"]);
};


/*
// up to 100 blocks of 100,000 atoms

#define M 100
#define N 100000

U *mem[M];
int mcount;

U *free_list;
int free_count;

U *
alloc(void)
{
	U *p;
	if (free_count == 0) {
		if (mcount == 0)
			alloc_mem();
		else {
			gc();
			if (free_count < N * mcount / 2)
				alloc_mem();
		}
		if (free_count == 0)
			stop("atom space exhausted");
	}
	p = free_list;
	free_list = free_list->u.cons.cdr;
	free_count--;
	return p;
}
 */

allocatedId = 0;

alloc_tensor = function(nelem) {
  var i, o, p, ref;
  i = 0;
  p = new U();
  p.k = TENSOR;
  p.tensor = new tensor();
  p.tensor.nelem = nelem;
  for (i = o = 0, ref = nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    p.tensor.elem[i] = zero;
  }
  p.tensor.allocatedId = allocatedId;
  if (allocatedId === 9) {
    debugger;
  }
  allocatedId++;
  if (p.tensor.nelem !== p.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  return p;
};


/*
// garbage collector

void
gc(void)
{
	int i, j;
	U *p;

	// tag everything

	for (i = 0; i < mcount; i++) {
		p = mem[i];
		for (j = 0; j < N; j++)
			p[j].tag = 1;
	}

	// untag what's used

	untag(p0);
	untag(p1);
	untag(p2);
	untag(p3);
	untag(p4);
	untag(p5);
	untag(p6);
	untag(p7);
	untag(p8);
	untag(p9);

	untag(one);
	untag(zero);
	untag(imaginaryunit);

	for (i = 0; i < NSYM; i++) {
		untag(binding[i]);
		untag(arglist[i]);
	}

	for (i = 0; i < tos; i++)
		untag(stack[i]);

	for (i = (int) (frame - stack); i < TOS; i++)
		untag(stack[i]);

	// collect everything that's still tagged

	free_count = 0;

	for (i = 0; i < mcount; i++) {
		p = mem[i];
		for (j = 0; j < N; j++) {
			if (p[j].tag == 0)
				continue;
			// still tagged so it's unused, put on free list
			switch (p[j].k) {
			case TENSOR:
				free(p[j].u.tensor);
				break;
			case STR:
				free(p[j].u.str);
				break;
			case NUM:
				mfree(p[j].u.q.a);
				mfree(p[j].u.q.b);
				break;
			}
			p[j].k = CONS; // so no double free occurs above
			p[j].u.cons.cdr = free_list;
			free_list = p + j;
			free_count++;
		}
	}
}

void
untag(U *p)
{
	int i;

	if (iscons(p)) {
		do {
			if (p->tag == 0)
				return;
			p->tag = 0;
			untag(p->u.cons.car);
			p = p->u.cons.cdr;
		} while (iscons(p));
		untag(p);
		return;
	}

	if (p->tag) {
		p->tag = 0;
 		if (istensor(p)) {
			for (i = 0; i < p->u.tensor->nelem; i++)
				untag(p->u.tensor->elem[i]);
		}
	}
}

// get memory for 100,000 atoms

void
alloc_mem(void)
{
	int i;
	U *p;
	if (mcount == M)
		return;
	p = (U *) malloc(N * sizeof (struct U));
	if (p == NULL)
		return;
	mem[mcount++] = p;
	for (i = 0; i < N; i++) {
		p[i].k = CONS; // so no free in gc
		p[i].u.cons.cdr = p + i + 1;
	}
	p[N - 1].u.cons.cdr = free_list;
	free_list = p;
	free_count += N;
}

void
print_mem_info(void)
{
	char buf[100];

	sprintf(buf, "%d blocks (%d bytes/block)\n", N * mcount, (int) sizeof (U));
	printstr(buf);

	sprintf(buf, "%d free\n", free_count);
	printstr(buf);

	sprintf(buf, "%d used\n", N * mcount - free_count);
	printstr(buf);
}
 */

Eval_arccos = function() {
  push(cadr(p1));
  Eval();
  return arccos();
};

arccos = function() {
  var d, errno, n;
  n = 0;
  d = 0.0;
  save();
  p1 = pop();
  if (car(p1) === symbol(COS)) {
    push(cadr(p1));
    restore();
    return;
  }
  if (isdouble(p1)) {
    errno = 0;
    d = acos(p1.d);
    if (errno) {
      stop("arccos function argument is not in the interval [-1,1]");
    }
    push_double(d);
    restore();
    return;
  }
  if (isoneoversqrttwo(p1)) {
    push_rational(1, 4);
    push_symbol(PI);
    multiply();
    restore();
    return;
  }
  if (isminusoneoversqrttwo(p1)) {
    push_rational(3, 4);
    push_symbol(PI);
    multiply();
    restore();
    return;
  }
  if (!isrational(p1)) {
    push_symbol(ARCCOS);
    push(p1);
    list(2);
    restore();
    return;
  }
  push(p1);
  push_integer(2);
  multiply();
  n = pop_integer();
  switch (n) {
    case -2:
      push_symbol(PI);
      break;
    case -1:
      push_rational(2, 3);
      push_symbol(PI);
      multiply();
      break;
    case 0:
      push_rational(1, 2);
      push_symbol(PI);
      multiply();
      break;
    case 1:
      push_rational(1, 3);
      push_symbol(PI);
      multiply();
      break;
    case 2:
      push(zero);
      break;
    default:
      push_symbol(ARCCOS);
      push(p1);
      list(2);
  }
  return restore();
};

test_arccos = function() {
  return run_test(["arccos(1)", "0", "arccos(1/2)", "1/3*pi", "arccos(0)", "1/2*pi", "arccos(-1/2)", "2/3*pi", "arccos(-1)", "pi", "arccos(cos(0))", "0", "arccos(cos(1/3*pi))", "1/3*pi", "arccos(cos(1/2*pi))", "1/2*pi", "arccos(cos(2/3*pi))", "2/3*pi", "arccos(cos(pi))", "pi", "arccos(cos(x))", "x", "arccos(1/sqrt(2))", "1/4*pi", "arccos(-1/sqrt(2))", "3/4*pi", "arccos(cos(1/4*pi))", "1/4*pi", "arccos(cos(3/4*pi))", "3/4*pi"]);
};

Eval_arccosh = function() {
  push(cadr(p1));
  Eval();
  return arccosh();
};

arccosh = function() {
  var d;
  d = 0.0;
  save();
  p1 = pop();
  if (car(p1) === symbol(COSH)) {
    push(cadr(p1));
    restore();
    return;
  }
  if (isdouble(p1)) {
    d = p1.d;
    if (d < 1.0) {
      stop("arccosh function argument is less than 1.0");
    }
    d = log(d + sqrt(d * d - 1.0));
    push_double(d);
    restore();
    return;
  }
  if (isplusone(p1)) {
    push(zero);
    restore();
    return;
  }
  push_symbol(ARCCOSH);
  push(p1);
  list(2);
  return restore();
};

test_arccosh = function() {
  return run_test(["arccosh(1.0)", "0", "arccosh(1)", "0", "arccosh(cosh(x))", "x"]);
};

Eval_arcsin = function() {
  push(cadr(p1));
  Eval();
  return arcsin();
};

arcsin = function() {
  var d, errno, n;
  n = 0;
  d = 0;
  save();
  p1 = pop();
  if (car(p1) === symbol(SIN)) {
    push(cadr(p1));
    restore();
    return;
  }
  if (isdouble(p1)) {
    errno = 0;
    d = asin(p1.d);
    if (errno) {
      stop("arcsin function argument is not in the interval [-1,1]");
    }
    push_double(d);
    restore();
    return;
  }
  if (isoneoversqrttwo(p1)) {
    push_rational(1, 4);
    push_symbol(PI);
    multiply();
    restore();
    return;
  }
  if (isminusoneoversqrttwo(p1)) {
    push_rational(-1, 4);
    push_symbol(PI);
    multiply();
    restore();
    return;
  }
  if (!isrational(p1)) {
    push_symbol(ARCSIN);
    push(p1);
    list(2);
    restore();
    return;
  }
  push(p1);
  push_integer(2);
  multiply();
  n = pop_integer();
  switch (n) {
    case -2:
      push_rational(-1, 2);
      push_symbol(PI);
      multiply();
      break;
    case -1:
      push_rational(-1, 6);
      push_symbol(PI);
      multiply();
      break;
    case 0:
      push(zero);
      break;
    case 1:
      push_rational(1, 6);
      push_symbol(PI);
      multiply();
      break;
    case 2:
      push_rational(1, 2);
      push_symbol(PI);
      multiply();
      break;
    default:
      push_symbol(ARCSIN);
      push(p1);
      list(2);
  }
  return restore();
};

test_arcsin = function() {
  return run_test(["arcsin(-1)", "-1/2*pi", "arcsin(-1/2)", "-1/6*pi", "arcsin(0)", "0", "arcsin(1/2)", "1/6*pi", "arcsin(1)", "1/2*pi", "arcsin(sin(-1/2*pi))", "-1/2*pi", "arcsin(sin(-1/6*pi))", "-1/6*pi", "arcsin(sin(0))", "0", "arcsin(sin(1/6*pi))", "1/6*pi", "arcsin(sin(1/2*pi))", "1/2*pi", "arcsin(sin(x))", "x", "arcsin(1/sqrt(2))", "1/4*pi", "arcsin(-1/sqrt(2))", "-1/4*pi", "arcsin(sin(1/4*pi))", "1/4*pi", "arcsin(sin(-1/4*pi))", "-1/4*pi"]);
};

Eval_arcsinh = function() {
  push(cadr(p1));
  Eval();
  return arcsinh();
};

arcsinh = function() {
  var d;
  d = 0.0;
  save();
  p1 = pop();
  if (car(p1) === symbol(SINH)) {
    push(cadr(p1));
    restore();
    return;
  }
  if (isdouble(p1)) {
    d = p1.d;
    d = log(d + sqrt(d * d + 1.0));
    push_double(d);
    restore();
    return;
  }
  if (iszero(p1)) {
    push(zero);
    restore();
    return;
  }
  push_symbol(ARCSINH);
  push(p1);
  list(2);
  return restore();
};

test_arcsinh = function() {
  return run_test(["arcsinh(0.0)", "0", "arcsinh(0)", "0", "arcsinh(sinh(x))", "x"]);
};

Eval_arctan = function() {
  push(cadr(p1));
  Eval();
  return arctan();
};

arctan = function() {
  var d, errno;
  d = 0;
  save();
  p1 = pop();
  if (car(p1) === symbol(TAN)) {
    push(cadr(p1));
    restore();
    return;
  }
  if (isdouble(p1)) {
    errno = 0;
    d = Math.atan(p1.d);
    if (errno) {
      stop("arctan function error");
    }
    push_double(d);
    restore();
    return;
  }
  if (iszero(p1)) {
    push(zero);
    restore();
    return;
  }
  if (isnegative(p1)) {
    push(p1);
    negate();
    arctan();
    negate();
    restore();
    return;
  }
  if (Find(p1, symbol(SIN)) && Find(p1, symbol(COS))) {
    push(p1);
    numerator();
    p2 = pop();
    push(p1);
    denominator();
    p3 = pop();
    if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {
      push(cadr(p2));
      restore();
      return;
    }
  }
  if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2)) {
    push_rational(1, 6);
    push(symbol(PI));
    multiply();
    restore();
    return;
  }
  if (equaln(p1, 1)) {
    push_rational(1, 4);
    push(symbol(PI));
    multiply();
    restore();
    return;
  }
  if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {
    push_rational(1, 3);
    push(symbol(PI));
    multiply();
    restore();
    return;
  }
  push_symbol(ARCTAN);
  push(p1);
  list(2);
  return restore();
};

s = ["arctan(x)", "arctan(x)", "arctan(-x)", "-arctan(x)", "arctan(0)", "0", "arctan(tan(x))", "x", "arctan(1/sqrt(3))-pi/6", "0", "arctan(1)-pi/4", "0", "arctan(sqrt(3))-pi/3", "0", "arctan(a-b)", "arctan(a-b)", "arctan(b-a)", "-arctan(a-b)", "arctan(tan(x))", "x"];


/*
void
test_arctan(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

Eval_arctanh = function() {
  push(cadr(p1));
  Eval();
  return arctanh();
};

arctanh = function() {
  var d;
  d = 0.0;
  save();
  p1 = pop();
  if (car(p1) === symbol(TANH)) {
    push(cadr(p1));
    restore();
    return;
  }
  if (isdouble(p1)) {
    d = p1.d;
    if (d < -1.0 || d > 1.0) {
      stop("arctanh function argument is not in the interval [-1,1]");
    }
    d = log((1.0 + d) / (1.0 - d)) / 2.0;
    push_double(d);
    restore();
    return;
  }
  if (iszero(p1)) {
    push(zero);
    restore();
    return;
  }
  push_symbol(ARCTANH);
  push(p1);
  list(2);
  return restore();
};

test_arctanh = function() {
  return run_test(["arctanh(0.0)", "0", "arctanh(0)", "0", "arctanh(tanh(x))", "x"]);
};


/*
 Argument (angle) of complex z

	z		arg(z)
	-		------

	a		0

	-a		-pi			See note 3 below

	(-1)^a		a pi

	exp(a + i b)	b

	a b		arg(a) + arg(b)

	a + i b		arctan(b/a)

Result by quadrant

	z		arg(z)
	-		------

	1 + i		1/4 pi

	1 - i		-1/4 pi

	-1 + i		3/4 pi

	-1 - i		-3/4 pi

Notes

	1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)

	2. Symbols in z are assumed to be positive and real.

	3. Negative direction adds -pi to angle.

	   Example: z = (-1)^(1/3), mag(z) = 1/3 pi, mag(-z) = -2/3 pi

	4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then

		arg(numerator(z)) - arg(denominator(z))

	   must be used to get the correct answer. Now the operation is
	   automatic.
 */

Eval_arg = function() {
  push(cadr(p1));
  Eval();
  return arg();
};

arg = function() {
  save();
  p1 = pop();
  push(p1);
  numerator();
  yyarg();
  push(p1);
  denominator();
  yyarg();
  subtract();
  return restore();
};

yyarg = function() {
  save();
  p1 = pop();
  if (isnegativenumber(p1)) {
    push(symbol(PI));
    negate();
  } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {
    push(symbol(PI));
    push(caddr(p1));
    multiply();
  } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {
    push(caddr(p1));
    imag();
  } else if (car(p1) === symbol(MULTIPLY)) {
    push_integer(0);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      arg();
      add();
      p1 = cdr(p1);
    }
  } else if (car(p1) === symbol(ADD)) {
    push(p1);
    rect();
    p1 = pop();
    push(p1);
    real();
    p2 = pop();
    push(p1);
    imag();
    p3 = pop();
    if (iszero(p2)) {
      push(symbol(PI));
      if (isnegative(p3)) {
        negate();
      }
    } else {
      push(p3);
      push(p2);
      divide();
      arctan();
      if (isnegative(p2)) {
        push_symbol(PI);
        if (isnegative(p3)) {
          subtract();
        } else {
          add();
        }
      }
    }
  } else {
    push_integer(0);
  }
  return restore();
};

test_arg = function() {
  return run_test(["arg(1+i)", "1/4*pi", "arg(1-i)", "-1/4*pi", "arg(-1+i)", "3/4*pi", "arg(-1-i)", "-3/4*pi", "arg((-1)^(1/3))", "1/3*pi", "arg(1+exp(i*pi/3))", "1/6*pi", "arg((-1)^(1/6)*exp(i*pi/6))", "1/3*pi", "arg(a)", "0", "arg(a*exp(b+i*pi/5))", "1/5*pi", "arg(-1)", "-pi", "arg(a)", "0", "arg(-a)", "-pi", "arg(-(-1)^(1/3))", "-2/3*pi", "arg(-exp(i*pi/3))", "-2/3*pi", "arg(-i)", "-1/2*pi", "arg((a+b*i)/(c+d*i))", "arctan(b/a)-arctan(d/c)"]);
};

bake = function() {
  var h, t, x, y, z;
  h = 0;
  s = 0;
  t = 0;
  x = 0;
  y = 0;
  z = 0;
  expanding++;
  save();
  p1 = pop();
  s = ispoly(p1, symbol(SYMBOL_S));
  t = ispoly(p1, symbol(SYMBOL_T));
  x = ispoly(p1, symbol(SYMBOL_X));
  y = ispoly(p1, symbol(SYMBOL_Y));
  z = ispoly(p1, symbol(SYMBOL_Z));
  if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {
    p2 = symbol(SYMBOL_S);
    bake_poly();
  } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {
    p2 = symbol(SYMBOL_T);
    bake_poly();
  } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {
    p2 = symbol(SYMBOL_X);
    bake_poly();
  } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {
    p2 = symbol(SYMBOL_Y);
    bake_poly();
  } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {
    p2 = symbol(SYMBOL_Z);
    bake_poly();
  } else if (iscons(p1)) {
    h = tos;
    push(car(p1));
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      bake();
      p1 = cdr(p1);
    }
    list(tos - h);
  } else {
    push(p1);
  }
  restore();
  return expanding--;
};

polyform = function() {
  var h;
  h = 0;
  save();
  p2 = pop();
  p1 = pop();
  if (ispoly(p1, p2)) {
    bake_poly();
  } else if (iscons(p1)) {
    h = tos;
    push(car(p1));
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      polyform();
      p1 = cdr(p1);
    }
    list(tos - h);
  } else {
    push(p1);
  }
  return restore();
};

bake_poly = function() {
  var a, h, i, k, n, o, ref;
  h = 0;
  i = 0;
  k = 0;
  n = 0;
  a = tos;
  push(p1);
  push(p2);
  k = coeff();
  h = tos;
  for (i = o = ref = k - 1; o >= 0; i = o += -1) {
    p1 = stack[a + i];
    bake_poly_term(i);
  }
  n = tos - h;
  if (n > 1) {
    list(n);
    push(symbol(ADD));
    swap();
    cons();
  }
  p1 = pop();
  tos -= k;
  return push(p1);
};

bake_poly_term = function(k) {
  var h, n;
  h = 0;
  n = 0;
  if (iszero(p1)) {
    return;
  }
  if (k === 0) {
    if (car(p1) === symbol(ADD)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        p1 = cdr(p1);
      }
    } else {
      push(p1);
    }
    return;
  }
  h = tos;
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
    }
  } else if (!equaln(p1, 1)) {
    push(p1);
  }
  if (k === 1) {
    push(p2);
  } else {
    push(symbol(POWER));
    push(p2);
    push_integer(k);
    list(3);
  }
  n = tos - h;
  if (n > 1) {
    list(n);
    push(symbol(MULTIPLY));
    swap();
    return cons();
  }
};

test_bake = function() {
  return run_test(["(x+3)^3", "x^3+9*x^2+27*x+27", "factor", "(x+3)^3"]);
};


/*
 Bessel J function

	1st arg		x

	2nd arg		n

Recurrence relation

	besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)

	besselj(x,1/2) = sqrt(2/pi/x) sin(x)

	besselj(x,-1/2) = sqrt(2/pi/x) cos(x)

For negative n, reorder the recurrence relation as

	besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)

Substitute n+2 for n to obtain

	besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)

Examples

	besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)

	besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)
 */

Eval_besselj = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return besselj();
};

besselj = function() {
  save();
  yybesselj();
  return restore();
};

yybesselj = function() {
  var d, n;
  d = 0.0;
  n = 0;
  p2 = pop();
  p1 = pop();
  push(p2);
  n = pop_integer();
  if (isdouble(p1) && n !== 0x80000000) {
    d = jn(n, p1.d);
    push_double(d);
    return;
  }
  if (iszero(p1) && iszero(p2)) {
    push_integer(1);
    return;
  }
  if (iszero(p1) && n !== 0x80000000) {
    push_integer(0);
    return;
  }
  if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {
    if (MEQUAL(p2.q.a, 1)) {
      push_integer(2);
      push_symbol(PI);
      divide();
      push(p1);
      divide();
      push_rational(1, 2);
      power();
      push(p1);
      sine();
      multiply();
      return;
    }
    if (MEQUAL(p2.q.a, -1)) {
      push_integer(2);
      push_symbol(PI);
      divide();
      push(p1);
      divide();
      push_rational(1, 2);
      power();
      push(p1);
      cosine();
      multiply();
      return;
    }
    push_integer(MSIGN(p2.q.a));
    p3 = pop();
    push_integer(2);
    push(p1);
    divide();
    push(p2);
    push(p3);
    subtract();
    multiply();
    push(p1);
    push(p2);
    push(p3);
    subtract();
    besselj();
    multiply();
    push(p1);
    push(p2);
    push_integer(2);
    push(p3);
    multiply();
    subtract();
    besselj();
    subtract();
    return;
  }
  if (isnegativeterm(p1)) {
    push(p1);
    negate();
    push(p2);
    power();
    push(p1);
    push(p2);
    negate();
    power();
    multiply();
    push_symbol(BESSELJ);
    push(p1);
    negate();
    push(p2);
    list(3);
    multiply();
    return;
  }
  if (isnegativeterm(p2)) {
    push_integer(-1);
    push(p2);
    power();
    push_symbol(BESSELJ);
    push(p1);
    push(p2);
    negate();
    list(3);
    multiply();
    return;
  }
  push(symbol(BESSELJ));
  push(p1);
  push(p2);
  return list(3);
};

test_besselj = function() {
  return run_test(["besselj(x,n)", "besselj(x,n)", "besselj(0,0)", "1", "besselj(0,1)", "0", "besselj(0,-1)", "0", "besselj(x,1/2)-sqrt(2/pi/x)*sin(x)", "0", "besselj(x,-1/2)-sqrt(2/pi/x)*cos(x)", "0", "besselj(x,3/2)-sqrt(2/pi/x)*(sin(x)/x-cos(x))", "0", "besselj(x,-3/2)-sqrt(2/pi/x)*(-cos(x)/x-sin(x))", "0", "besselj(x,5/2)-sqrt(2/pi/x)*((3/x^2-1)*sin(x)-3/x*cos(x))", "0", "besselj(x,-5/2)-sqrt(2/pi/x)*((3/x^2-1)*cos(x)+3/x*sin(x))", "0", "besselj(x,3/2)-(1/x)*besselj(x,1/2)+besselj(x,-1/2)", "0", "besselj(x,-3/2)+(1/x)*besselj(x,-1/2)+besselj(x,1/2)", "0", "y=besselj(x,5/2)", "", "x^2*d(y,x,x)+x*d(y,x)+(x^2-(5/2)^2)*y", "0", "y=quote(y)", ""]);
};

Eval_bessely = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return bessely();
};

bessely = function() {
  save();
  yybessely();
  return restore();
};

yybessely = function() {
  var d, n;
  d = 0.0;
  n = 0;
  p2 = pop();
  p1 = pop();
  push(p2);
  n = pop_integer();
  if (isdouble(p1) && n !== 0x80000000) {
    d = yn(n, p1.d);
    push_double(d);
    return;
  }
  if (isnegativeterm(p2)) {
    push_integer(-1);
    push(p2);
    power();
    push_symbol(BESSELY);
    push(p1);
    push(p2);
    negate();
    list(3);
    multiply();
    return;
  }
  push_symbol(BESSELY);
  push(p1);
  push(p2);
  list(3);
};

test_bessely = function() {
  return run_test(["bessely(x,n)", "bessely(x,n)"]);
};

MP_MIN_SIZE = 2;

MP_MAX_FREE = 1000;

mtotal = 0;

free_stack = [];

mint = function(a) {
  return bigInt(a);
};

setSignTo = function(a, b) {
  if (a.isPositive()) {
    if (b < 0) {
      return a.multiply(bigInt(-1));
    }
  } else {
    if (b > 0) {
      return a.multiply(bigInt(-1));
    }
  }
  return a;
};

makeSignSameAs = function(a, b) {
  if (a.isPositive()) {
    if (b.isNegative()) {
      return a.multiply(bigInt(-1));
    }
  } else {
    if (b.isPositive()) {
      return a.multiply(bigInt(-1));
    }
  }
  return a;
};

makePositive = function(a) {
  if (a.isNegative()) {
    return a.multiply(bigInt(-1));
  }
  return a;
};


/*
mnew = (n) ->
	if (n < MP_MIN_SIZE)
		n = MP_MIN_SIZE
	if (n == MP_MIN_SIZE && mfreecount)
		p = free_stack[--mfreecount]
	else
		p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))
		#if (p == 0)
		 *	stop("malloc failure")
	p[0] = n
	mtotal += n
	return p[3]
 */


/*
mfree = (array, p) ->
	p -= 3
	mtotal -= array[p]
	if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)
		free_stack[mfreecount++] = p
	else
		free(p)
 */


/*
mint = (n) ->
	p = mnew(1)
	if (n < 0)
		 * !!! this is FU
		 * MSIGN(p) = -1
		fu = true
	else
		 * !!! this is FU
		#MSIGN(p) = 1
		fu = true
	 * !!! this is FU
	#MLENGTH(p) = 1
	p[0] = Math.abs(n)
	return p
 */


/*
mcopy = (a) ->
	#unsigned int *b

	b = mnew(MLENGTH(a))

	 * !!! fu
	#MSIGN(b) = MSIGN(a)
	#MLENGTH(b) = MLENGTH(a)

	for i in [0...MLENGTH(a)]
		b[i] = a[i]

	return b
 */

ge = function(a, b, len) {
  var i, o, ref;
  i = 0;
  for (i = o = 0, ref = len; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    if (a[i] === b[i]) {
      continue;
    } else {
      break;
    }
  }
  if (a[i] >= b[i]) {
    return 1;
  } else {
    return 0;
  }
};

add_numbers = function() {
  var a, b, theResult;
  a = 1.0;
  b = 1.0;
  console.log("add_numbers adding numbers: " + print1(stack[tos - 1], "") + " and " + print1(stack[tos - 2], ""));
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qadd();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  theResult = a + b;
  push_double(theResult);
  return restore();
};

subtract_numbers = function() {
  var a, b;
  a = 0.0;
  b = 0.0;
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qsub();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a - b);
  return restore();
};

multiply_numbers = function() {
  var a, b;
  a = 0.0;
  b = 0.0;
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qmul();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a * b);
  return restore();
};

divide_numbers = function() {
  var a, b;
  a = 0.0;
  b = 0.0;
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qdiv();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (iszero(p2)) {
    stop("divide by zero");
  }
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a / b);
  return restore();
};

invert_number = function() {
  var a, b;
  save();
  p1 = pop();
  if (iszero(p1)) {
    stop("divide by zero");
  }
  if (isdouble(p1)) {
    push_double(1 / p1.d);
    restore();
    return;
  }
  a = bigInt(p1.q.a);
  b = bigInt(p1.q.b);
  b = makeSignSameAs(b, a);
  a = setSignTo(a, 1);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = b;
  p1.q.b = a;
  push(p1);
  return restore();
};

compare_rationals = function(a, b) {
  var ab, ba, t;
  t = 0;
  ab = mmul(a.q.a, b.q.b);
  ba = mmul(a.q.b, b.q.a);
  t = mcmp(ab, ba);
  return t;
};

compare_numbers = function(a, b) {
  var x, y;
  x = 0.0;
  y = 0.0;
  if (isrational(a) && isrational(b)) {
    return compare_rationals(a, b);
  }
  if (isdouble(a)) {
    x = a.d;
  } else {
    x = convert_rational_to_double(a);
  }
  if (isdouble(b)) {
    y = b.d;
  } else {
    y = convert_rational_to_double(b);
  }
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
};

negate_number = function() {
  save();
  p1 = pop();
  if (iszero(p1)) {
    push(p1);
    restore();
    return;
  }
  switch (p1.k) {
    case NUM:
      p2 = new U();
      p2.k = NUM;
      p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));
      p2.q.b = bigInt(p1.q.b);
      push(p2);
      break;
    case DOUBLE:
      push_double(-p1.d);
      break;
    default:
      stop("bug caught in mp_negate_number");
  }
  return restore();
};

bignum_truncate = function() {
  var a;
  save();
  p1 = pop();
  a = mdiv(p1.q.a, p1.q.b);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

mp_numerator = function() {
  save();
  p1 = pop();
  if (p1.k !== NUM) {
    push(one);
    restore();
    return;
  }
  p2 = new U();
  p2.k = NUM;
  p2.q.a = bigInt(p1.q.a);
  p2.q.b = bigInt(1);
  push(p2);
  return restore();
};

mp_denominator = function() {
  save();
  p1 = pop();
  if (p1.k !== NUM) {
    push(one);
    restore();
    return;
  }
  p2 = new U();
  p2.k = NUM;
  p2.q.a = bigInt(p1.q.b);
  p2.q.b = bigInt(1);
  push(p2);
  return restore();
};

bignum_power_number = function(expo) {
  var a, b, t;
  save();
  p1 = pop();
  a = mpow(p1.q.a, Math.abs(expo));
  b = mpow(p1.q.b, Math.abs(expo));
  if (expo < 0) {
    t = a;
    a = b;
    b = t;
    a = makeSignSameAs(a, b);
    b = setSignTo(b, 1);
  }
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = b;
  push(p1);
  return restore();
};

convert_bignum_to_double = function(p) {
  return p.toJSNumber();
};

convert_rational_to_double = function(p) {
  var quotientAndRemainder, result;
  if (p.q == null) {
    debugger;
  }
  quotientAndRemainder = p.q.a.divmod(p.q.b);
  result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();
  return result;
};

push_integer = function(n) {
  console.log("pushing integer " + n);
  save();
  p1 = new U();
  p1.k = NUM;
  p1.q.a = bigInt(n);
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

push_double = function(d) {
  save();
  p1 = new U();
  p1.k = DOUBLE;
  p1.d = d;
  push(p1);
  return restore();
};

push_rational = function(a, b) {

  /*
  	save()
  	p1 = new U()
  	p1.k = NUM
  	p1.q.a = bigInt(a)
  	p1.q.b = bigInt(b)
  	## FIXME -- normalize ##
  	push(p1)
  	restore()
   */
  var p;
  p = new U();
  p.k = NUM;
  p.q.a = bigInt(a);
  p.q.b = bigInt(b);
  return push(p);
};

pop_integer = function() {
  var n;
  n = 0;
  save();
  p1 = pop();
  switch (p1.k) {
    case NUM:
      if (isinteger(p1) && p1.q.a.isSmall) {
        n = p1.q.a.toJSNumber();
      } else {
        n = 0x80000000;
      }
      break;
    case DOUBLE:
      n = Math.floor(p1.q.a);
      break;
    default:
      n = 0x80000000;
  }
  restore();
  return n;
};

print_double = function(p, flag) {
  var buf;
  buf = "";
  buf = "" + doubleToReasonableString(p.d);
  if (flag === 1 && buf === '-') {
    return print_str(buf + 1);
  } else {
    return print_str(buf);
  }
};

bignum_scan_integer = function(s) {
  var a, scounter, sign;
  save();
  scounter = 0;
  sign = s[scounter];
  if (sign === '+' || sign === '-') {
    scounter++;
  }
  a = bigInt(s.substring(scounter));
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = bigInt(1);
  push(p1);
  if (sign === '-') {
    negate();
  }
  return restore();
};

bignum_scan_float = function(s) {
  return push_double(parseFloat(s));
};

print_number = function(p, accumulator) {
  var aAsString, buf, denominatorString, topLevelCall;
  topLevelCall = false;
  if (accumulator == null) {
    topLevelCall = true;
    accumulator = "";
  }
  denominatorString = "";
  buf = "";
  switch (p.k) {
    case NUM:
      aAsString = p.q.a.toString();
      if (aAsString[0] === "-") {
        aAsString = aAsString.substring(1);
      }
      accumulator += aAsString;
      stringToBePrinted += aAsString;
      if (isfraction(p)) {
        accumulator += "/";
        stringToBePrinted += "/";
        denominatorString = p.q.b.toString();
        accumulator += denominatorString;
        stringToBePrinted += denominatorString;
      }
      break;
    case DOUBLE:
      aAsString = "" + doubleToReasonableString(p.d);
      if (aAsString[0] === "-") {
        aAsString = aAsString.substring(1);
      }
      accumulator += aAsString;
      stringToBePrinted += aAsString;
  }
  return accumulator;
};

gcd_numbers = function() {
  save();
  p2 = pop();
  p1 = pop();
  p3 = new U();
  p3.k = NUM;
  p3.q.a = mgcd(p1.q.a, p2.q.a);
  p3.q.b = mgcd(p1.q.b, p2.q.b);
  p3.q.a = setSignTo(p3.q.a, 1);
  push(p3);
  return restore();
};

pop_double = function() {
  var d;
  d = 0.0;
  save();
  p1 = pop();
  switch (p1.k) {
    case NUM:
      d = convert_rational_to_double(p1);
      break;
    case DOUBLE:
      d = p1.d;
      break;
    default:
      d = 0.0;
  }
  restore();
  return d;
};

bignum_float = function() {
  var d;
  d = 0.0;
  d = convert_rational_to_double(pop());
  return push_double(d);
};

bignum_factorial = function(n) {
  save();
  p1 = new U();
  p1.k = NUM;
  p1.q.a = __factorial(n);
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

__factorial = function(n) {
  var a, b, i, o, ref, t;
  i = 0;
  if (n === 0 || n === 1) {
    a = bigInt(1);
    return a;
  }
  a = bigInt(2);
  b = bigInt(0);
  if (3 <= n) {
    for (i = o = 3, ref = n; 3 <= ref ? o <= ref : o >= ref; i = 3 <= ref ? ++o : --o) {
      b = bigInt(i);
      t = mmul(a, b);
      a = t;
    }
  }
  return a;
};

mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];

mp_set_bit = function(x, k) {
  console.log("not implemented yet");
  debugger;
  return x[k / 32] |= mask[k % 32];
};

mp_clr_bit = function(x, k) {
  console.log("not implemented yet");
  debugger;
  return x[k / 32] &= ~mask[k % 32];
};

mshiftright = function(a) {
  return a = a.shiftRight();
};

test_signs_in_rationals = function() {
  return run_test(["1/1", "1", "-1/1", "-1", "1/(-1)", "-1", "(-1)/(-1)", "1"]);
};

Eval_binomial = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return binomial();
};

binomial = function() {
  save();
  ybinomial();
  return restore();
};

ybinomial = function() {
  p2 = pop();
  p1 = pop();
  if (BINOM_check_args() === 0) {
    push(zero);
    return;
  }
  push(p1);
  factorial();
  push(p2);
  factorial();
  divide();
  push(p1);
  push(p2);
  subtract();
  factorial();
  return divide();
};

BINOM_check_args = function() {
  if (isnum(p1) && lessp(p1, zero)) {
    return 0;
  } else if (isnum(p2) && lessp(p2, zero)) {
    return 0;
  } else if (isnum(p1) && isnum(p2) && lessp(p1, p2)) {
    return 0;
  } else {
    return 1;
  }
};

test_binomial = function() {
  return run_test(["binomial(12,6)", "924", "binomial(n,k)", "n!/(k!*(-k+n)!)", "binomial(0,k)", "1/(k!*(-k)!)", "binomial(n,0)", "1", "binomial(-1,k)", "0", "binomial(n,-1)", "0"]);
};

Eval_ceiling = function() {
  push(cadr(p1));
  Eval();
  return ceiling();
};

ceiling = function() {
  save();
  yyceiling();
  return restore();
};

yyceiling = function() {
  var d, doNothing;
  d = 0.0;
  p1 = pop();
  if (!isnum(p1)) {
    push_symbol(CEILING);
    push(p1);
    list(2);
    return;
  }
  if (isdouble(p1)) {
    d = Math.ceil(p1.d);
    push_double(d);
    return;
  }
  if (isinteger(p1)) {
    push(p1);
    return;
  }
  p3 = new U();
  p3.k = NUM;
  p3.q.a = mdiv(p1.q.a, p1.q.b);
  p3.q.b = mint(1);
  push(p3);
  if (isnegativenumber(p1)) {
    return doNothing = 1;
  } else {
    push_integer(1);
    return add();
  }
};

test_ceiling = function() {
  return run_test(["ceiling(a)", "ceiling(a)", "ceiling(a+b)", "ceiling(a+b)", "ceiling(5/2)", "3", "ceiling(4/2)", "2", "ceiling(3/2)", "2", "ceiling(2/2)", "1", "ceiling(1/2)", "1", "ceiling(0/2)", "0", "ceiling(-1/2)", "0", "ceiling(-2/2)", "-1", "ceiling(-3/2)", "-1", "ceiling(-4/2)", "-2", "ceiling(-5/2)", "-2", "ceiling(5/2.0)", "3", "ceiling(4/2.0)", "2", "ceiling(3/2.0)", "2", "ceiling(2/2.0)", "1", "ceiling(1/2.0)", "1", "ceiling(0.0)", "0", "ceiling(-1/2.0)", "0", "ceiling(-2/2.0)", "-1", "ceiling(-3/2.0)", "-1", "ceiling(-4/2.0)", "-2", "ceiling(-5/2.0)", "-2"]);
};

Eval_choose = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return choose();
};

choose = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (choose_check_args() === 0) {
    push_integer(0);
    restore();
    return;
  }
  push(p1);
  factorial();
  push(p2);
  factorial();
  divide();
  push(p1);
  push(p2);
  subtract();
  factorial();
  divide();
  return restore();
};

choose_check_args = function() {
  if (isnum(p1) && lessp(p1, zero)) {
    return 0;
  } else if (isnum(p2) && lessp(p2, zero)) {
    return 0;
  } else if (isnum(p1) && isnum(p2) && lessp(p1, p2)) {
    return 0;
  } else {
    return 1;
  }
};

test_choose = function() {
  return run_test(["choose(52,5)", "2598960", "choose(n,k)", "n!/(k!*(-k+n)!)", "choose(0,k)", "1/(k!*(-k)!)", "choose(n,0)", "1", "choose(-1,k)", "0", "choose(n,-1)", "0"]);
};

Eval_circexp = function() {
  push(cadr(p1));
  Eval();
  circexp();
  return Eval();
};

circexp = function() {
  var h, i, o, ref;
  i = 0;
  h = 0;
  save();
  p1 = pop();
  if (car(p1) === symbol(COS)) {
    push(cadr(p1));
    expcos();
    restore();
    return;
  }
  if (car(p1) === symbol(SIN)) {
    push(cadr(p1));
    expsin();
    restore();
    return;
  }
  if (car(p1) === symbol(TAN)) {
    p1 = cadr(p1);
    push(imaginaryunit);
    push(p1);
    multiply();
    exponential();
    p2 = pop();
    push(imaginaryunit);
    push(p1);
    multiply();
    negate();
    exponential();
    p3 = pop();
    push(p3);
    push(p2);
    subtract();
    push(imaginaryunit);
    multiply();
    push(p2);
    push(p3);
    add();
    divide();
    restore();
    return;
  }
  if (car(p1) === symbol(COSH)) {
    p1 = cadr(p1);
    push(p1);
    exponential();
    push(p1);
    negate();
    exponential();
    add();
    push_rational(1, 2);
    multiply();
    restore();
    return;
  }
  if (car(p1) === symbol(SINH)) {
    p1 = cadr(p1);
    push(p1);
    exponential();
    push(p1);
    negate();
    exponential();
    subtract();
    push_rational(1, 2);
    multiply();
    restore();
    return;
  }
  if (car(p1) === symbol(TANH)) {
    p1 = cadr(p1);
    push(p1);
    push_integer(2);
    multiply();
    exponential();
    p1 = pop();
    push(p1);
    push_integer(1);
    subtract();
    push(p1);
    push_integer(1);
    add();
    divide();
    restore();
    return;
  }
  if (iscons(p1)) {
    h = tos;
    while (iscons(p1)) {
      push(car(p1));
      circexp();
      p1 = cdr(p1);
    }
    list(tos - h);
    restore();
    return;
  }
  if (p1.k === TENSOR) {
    push(p1);
    copy_tensor();
    p1 = pop();
    for (i = o = 0, ref = p1.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      push(p1.tensor.elem[i]);
      circexp();
      p1.tensor.elem[i] = pop();
    }
    push(p1);
    restore();
    return;
  }
  push(p1);
  return restore();
};

test_circexp = function() {
  return run_test(["circexp(cos(x))", "1/2*exp(-i*x)+1/2*exp(i*x)", "circexp(sin(x))", "1/2*i*exp(-i*x)-1/2*i*exp(i*x)", "circexp(tan(x))", "i*exp(-i*x)/(exp(-i*x)+exp(i*x))-i*exp(i*x)/(exp(-i*x)+exp(i*x))", "circexp(cosh(x))", "1/2*exp(x)+1/2*exp(-x)", "circexp(sinh(x))", "1/2*exp(x)-1/2*exp(-x)", "circexp(tanh(x))", "-1/(1+exp(2*x))+exp(2*x)/(1+exp(2*x))", "circexp((cos(x),sin(x)))", "(1/2*exp(-i*x)+1/2*exp(i*x),1/2*i*exp(-i*x)-1/2*i*exp(i*x))", "circexp(cos(x)*sin(x))-expcos(x)*expsin(x)", "0"]);
};

Eval_clear = function() {
  if (test_flag === 0) {
    clear_term();
  }
  clear_symbols();
  defn();
  return push(symbol(NIL));
};

clear = function() {
  return run("clear");
};


/*
 Convert complex z to clock form

	Input:		push	z

	Output:		Result on stack

	clock(z) = mag(z) * (-1) ^ (arg(z) / pi)

	For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)
 */

Eval_clock = function() {
  push(cadr(p1));
  Eval();
  return clockform();
};

clockform = function() {
  save();
  p1 = pop();
  push(p1);
  mag();
  push_integer(-1);
  push(p1);
  arg();
  push(symbol(PI));
  divide();
  power();
  multiply();

  /*
  	p1 = pop();
  	push(p1);
  	mag();
  	push(symbol(E));
  	push(p1);
  	arg();
  	push(imaginaryunit);
  	multiply();
  	power();
  	multiply();
   */
  return restore();
};

test_clock = function() {
  return run_test(["clock(exp(i pi/3))", "(-1)^(1/3)", "clock(exp(-i pi/3))", "-(-1)^(2/3)", "rect(clock(3+4*i))", "3+4*i"]);
};

Eval_coeff = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadddr(p1));
  Eval();
  p3 = pop();
  p2 = pop();
  p1 = pop();
  if (p3 === symbol(NIL)) {
    p3 = p2;
    p2 = symbol(SYMBOL_X);
  }
  push(p1);
  push(p2);
  push(p3);
  power();
  divide();
  push(p2);
  return filter();
};

coeff = function() {
  var h, n;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  while (1) {
    push(p1);
    push(p2);
    push(zero);
    subst();
    Eval();
    p3 = pop();
    push(p3);
    push(p1);
    push(p3);
    subtract();
    p1 = pop();
    if (equal(p1, zero)) {
      n = tos - h;
      restore();
      return n;
    }
    push(p1);
    push(p2);
    divide();
    p1 = pop();
  }
};

test_coeff = function() {
  return run_test(["coeff(40*x^3+30*x^2+20*x+10,3)", "40", "coeff(40*x^3+30*x^2+20*x+10,2)", "30", "coeff(40*x^3+30*x^2+20*x+10,1)", "20", "coeff(40*x^3+30*x^2+20*x+10,0)", "10", "coeff(a*t^3+b*t^2+c*t+d,t,3)", "a", "coeff(a*t^3+b*t^2+c*t+d,t,2)", "b", "coeff(a*t^3+b*t^2+c*t+d,t,1)", "c", "coeff(a*t^3+b*t^2+c*t+d,t,0)", "d"]);
};

Eval_cofactor = function() {
  var doNothing, i, j, n;
  i = 0;
  j = 0;
  n = 0;
  push(cadr(p1));
  Eval();
  p2 = pop();
  if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {
    doNothing = 1;
  } else {
    stop("cofactor: 1st arg: square matrix expected");
  }
  n = p2.tensor.dim[0];
  push(caddr(p1));
  Eval();
  i = pop_integer();
  if (i < 1 || i > n) {
    stop("cofactor: 2nd arg: row index expected");
  }
  push(cadddr(p1));
  Eval();
  j = pop_integer();
  if (j < 1 || j > n) {
    stop("cofactor: 3rd arg: column index expected");
  }
  return cofactor(p2, n, i - 1, j - 1);
};

cofactor = function(p, n, row, col) {
  var ac, i, j, o, ref, ref1;
  i = 0;
  j = 0;
  for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
      if (i !== row && j !== col) {
        push(p.tensor.elem[n * i + j]);
      }
    }
  }
  determinant(n - 1);
  if ((row + col) % 2) {
    return negate();
  }
};

test_cofactor = function() {
  return run_test(["cofactor(((1,2),(3,4)),1,1)", "4", "cofactor(((1,2),(3,4)),1,2)", "-3", "cofactor(((1,2),(3,4)),2,1)", "-2", "cofactor(((1,2),(3,4)),2,2)", "1", "cofactor(((1,2,3),(4,5,6),(7,8,9)),1,2)", "6"]);
};

Eval_condense = function() {
  push(cadr(p1));
  Eval();
  return Condense();
};

Condense = function() {
  var tmp;
  tmp = 0;
  tmp = expanding;
  save();
  yycondense();
  restore();
  return expanding = tmp;
};

yycondense = function() {
  expanding = 0;
  p1 = pop();
  if (car(p1) !== symbol(ADD)) {
    push(p1);
    return;
  }
  p3 = cdr(p1);
  push(car(p3));
  p3 = cdr(p3);
  while (iscons(p3)) {
    push(car(p3));
    gcd();
    p3 = cdr(p3);
  }
  inverse();
  p2 = pop();
  push(zero);
  p3 = cdr(p1);
  while (iscons(p3)) {
    push(p2);
    push(car(p3));
    multiply();
    add();
    p3 = cdr(p3);
  }
  yyexpand();
  push(p2);
  return divide();
};

test_condense = function() {
  return run_test(["condense(a/(a+b)+b/(a+b))", "1", "psi(n) = exp(-r/n) laguerre(2r/n,n-1,1)", "", "psi(3)", "3*exp(-1/3*r)-2*r*exp(-1/3*r)+2/9*r^2*exp(-1/3*r)", "condense(last)", "exp(-1/3*r)*(3-2*r+2/9*r^2)", "psi()=psi", "", "condense(-3 exp(-1/3 r + i phi) cos(theta) - 6 exp(-1/3 r + i phi) cos(theta) sin(theta)^2 + 12 exp(-1/3 r + i phi) cos(theta)^3)", "3*exp(-1/3*r+i*phi)*(-1+4*cos(theta)^2-2*sin(theta)^2)*cos(theta)"]);
};

Eval_conj = function() {
  push(cadr(p1));
  Eval();
  p1 = pop();
  push(p1);
  if (!Find(p1, imaginaryunit)) {
    polar();
    conjugate();
    return clockform();
  } else {
    return conjugate();
  }
};

conjugate = function() {
  push(imaginaryunit);
  push(imaginaryunit);
  negate();
  subst();
  return Eval();
};

consCount = 0;

cons = function() {
  var p;
  consCount++;
  console.log("cons tos: " + tos + " # " + consCount);
  if (consCount === 444) {
    debugger;
  }
  p = new U();
  p.k = CONS;
  p.cons.cdr = pop();
  if (p === p.cons.cdr) {
    debugger;
    console.log("something wrong p == its cdr");
  }
  p.cons.car = pop();

  /*
  	console.log "cons new cdr.k = " + p.cons.cdr.k + "\nor more in detail:"
  	print1 p.cons.cdr
  	console.log "cons new car.k = " + p.cons.car.k + "\nor more in detail:"
  	print1 p.cons.car
   */
  return push(p);
};

Eval_contract = function() {
  push(cadr(p1));
  Eval();
  if (cddr(p1) === symbol(NIL)) {
    push_integer(1);
    push_integer(2);
  } else {
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
  }
  return contract();
};

contract = function() {
  save();
  yycontract();
  return restore();
};

yycontract = function() {
  var a, ac, ad, ae, af, ag, ah, ai, an, b, h, i, j, k, l, m, n, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6;
  h = 0;
  i = 0;
  j = 0;
  k = 0;
  l = 0;
  m = 0;
  n = 0;
  ndim = 0;
  nelem = 0;
  ai = [];
  an = [];
  p3 = pop();
  p2 = pop();
  p1 = pop();
  if (!istensor(p1)) {
    if (!iszero(p1)) {
      stop("contract: tensor expected, 1st arg is not a tensor");
    }
    push(zero);
    return;
  }
  push(p2);
  l = pop_integer();
  push(p3);
  m = pop_integer();
  ndim = p1.tensor.ndim;
  if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {
    stop("contract: index out of range");
  }
  l--;
  m--;
  n = p1.tensor.dim[l];
  nelem = 1;
  for (i = o = 0, ref = ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    if (i !== l && i !== m) {
      nelem *= p1.tensor.dim[i];
    }
  }
  p2 = alloc_tensor(nelem);
  p2.tensor.ndim = ndim - 2;
  j = 0;
  for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    if (i !== l && i !== m) {
      p2.tensor.dim[j++] = p1.tensor.dim[i];
    }
  }
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  for (i = ad = 0, ref2 = ndim; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    ai[i] = 0;
    an[i] = p1.tensor.dim[i];
  }
  for (i = ae = 0, ref3 = nelem; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
    push(zero);
    for (j = af = 0, ref4 = n; 0 <= ref4 ? af < ref4 : af > ref4; j = 0 <= ref4 ? ++af : --af) {
      ai[l] = j;
      ai[m] = j;
      h = 0;
      for (k = ag = 0, ref5 = ndim; 0 <= ref5 ? ag < ref5 : ag > ref5; k = 0 <= ref5 ? ++ag : --ag) {
        h = (h * an[k]) + ai[k];
      }
      push(a[h]);
      add();
    }
    b[i] = pop();
    for (j = ah = ref6 = ndim - 1; ref6 <= 0 ? ah <= 0 : ah >= 0; j = ref6 <= 0 ? ++ah : --ah) {
      if (j === l || j === m) {
        continue;
      }
      if (++ai[j] < an[j]) {
        break;
      }
      ai[j] = 0;
    }
  }
  if (nelem === 1) {
    return push(b[0]);
  } else {
    return push(p2);
  }
};

test_contract = function() {
  return run_test(["contract(0)", "0", "contract(0.0)", "0", "contract(((a,b),(c,d)))", "a+d", "contract(((1,2),(3,4)),1,2)", "5", "A=((a11,a12),(a21,a22))", "", "B=((b11,b12),(b21,b22))", "", "contract(outer(A,B),2,3)", "((a11*b11+a12*b21,a11*b12+a12*b22),(a21*b11+a22*b21,a21*b12+a22*b22))", "A=quote(A)", "", "B=quote(B)", ""]);
};

Eval_cos = function() {
  push(cadr(p1));
  Eval();
  return cosine();
};

cosine = function() {
  save();
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    cosine_of_angle_sum();
  } else {
    cosine_of_angle();
  }
  return restore();
};

cosine_of_angle_sum = function() {
  p2 = cdr(p1);
  while (iscons(p2)) {
    p4 = car(p2);
    if (isnpi(p4)) {
      push(p1);
      push(p4);
      subtract();
      p3 = pop();
      push(p3);
      cosine();
      push(p4);
      cosine();
      multiply();
      push(p3);
      sine();
      push(p4);
      sine();
      multiply();
      subtract();
      return;
    }
    p2 = cdr(p2);
  }
  return cosine_of_angle();
};

cosine_of_angle = function() {
  var d, n;
  if (car(p1) === symbol(ARCCOS)) {
    push(cadr(p1));
    return;
  }
  if (isdouble(p1)) {
    d = Math.cos(p1.d);
    if (Math.abs(d) < 1e-10) {
      d = 0.0;
    }
    push_double(d);
    return;
  }
  if (isnegative(p1)) {
    push(p1);
    negate();
    p1 = pop();
  }
  if (car(p1) === symbol(ARCTAN)) {
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    add();
    push_rational(-1, 2);
    power();
    return;
  }
  push(p1);
  push_integer(180);
  multiply();
  push_symbol(PI);
  divide();
  n = pop_integer();
  if (n < 0 || n === 0x80000000) {
    push(symbol(COS));
    push(p1);
    list(2);
    return;
  }
  switch (n % 360) {
    case 90:
    case 270:
      return push_integer(0);
    case 60:
    case 300:
      return push_rational(1, 2);
    case 120:
    case 240:
      return push_rational(-1, 2);
    case 45:
    case 315:
      push_rational(1, 2);
      push_integer(2);
      push_rational(1, 2);
      power();
      return multiply();
    case 135:
    case 225:
      push_rational(-1, 2);
      push_integer(2);
      push_rational(1, 2);
      power();
      return multiply();
    case 30:
    case 330:
      push_rational(1, 2);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 150:
    case 210:
      push_rational(-1, 2);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 0:
      return push_integer(1);
    case 180:
      return push_integer(-1);
    default:
      push(symbol(COS));
      push(p1);
      return list(2);
  }
};

test_cos = function() {
  return run_test(["cos(x)", "cos(x)", "cos(-x)", "cos(x)", "cos(b-a)", "cos(a-b)", "f(a,x)=1+cos(float(a/360*2*pi))-float(x)+cos(a/360*2*pi)-x", "", "f(0,1)", "1", "f(90,0)", "1", "f(180,-1)", "1", "f(270,0)", "1", "f(360,1)", "1", "f(-90,0)", "1", "f(-180,-1)", "1", "f(-270,0)", "1", "f(-360,1)", "1", "f(45,sqrt(2)/2)", "1", "f(135,-sqrt(2)/2)", "1", "f(225,-sqrt(2)/2)", "1", "f(315,sqrt(2)/2)", "1", "f(-45,sqrt(2)/2)", "1", "f(-135,-sqrt(2)/2)", "1", "f(-225,-sqrt(2)/2)", "1", "f(-315,sqrt(2)/2)", "1", "f(30,sqrt(3)/2)", "1", "f(150,-sqrt(3)/2)", "1", "f(210,-sqrt(3)/2)", "1", "f(330,sqrt(3)/2)", "1", "f(-30,sqrt(3)/2)", "1", "f(-150,-sqrt(3)/2)", "1", "f(-210,-sqrt(3)/2)", "1", "f(-330,sqrt(3)/2)", "1", "f(60,1/2)", "1", "f(120,-1/2)", "1", "f(240,-1/2)", "1", "f(300,1/2)", "1", "f(-60,1/2)", "1", "f(-120,-1/2)", "1", "f(-240,-1/2)", "1", "f(-300,1/2)", "1", "f=quote(f)", "", "cos(arccos(x))", "x", "cos(1/12*pi)", "cos(1/12*pi)", "cos(arctan(4/3))", "3/5", "cos(-arctan(4/3))", "3/5", "cos(x-8/2*pi)", "cos(x)", "cos(x-7/2*pi)", "-sin(x)", "cos(x-6/2*pi)", "-cos(x)", "cos(x-5/2*pi)", "sin(x)", "cos(x-4/2*pi)", "cos(x)", "cos(x-3/2*pi)", "-sin(x)", "cos(x-2/2*pi)", "-cos(x)", "cos(x-1/2*pi)", "sin(x)", "cos(x+0/2*pi)", "cos(x)", "cos(x+1/2*pi)", "-sin(x)", "cos(x+2/2*pi)", "-cos(x)", "cos(x+3/2*pi)", "sin(x)", "cos(x+4/2*pi)", "cos(x)", "cos(x+5/2*pi)", "-sin(x)", "cos(x+6/2*pi)", "-cos(x)", "cos(x+7/2*pi)", "sin(x)", "cos(x+8/2*pi)", "cos(x)"]);
};

Eval_cosh = function() {
  push(cadr(p1));
  Eval();
  return ycosh();
};

ycosh = function() {
  save();
  yycosh();
  return restore();
};

yycosh = function() {
  var d;
  d = 0.0;
  p1 = pop();
  if (car(p1) === symbol(ARCCOSH)) {
    push(cadr(p1));
    return;
  }
  if (isdouble(p1)) {
    d = Math.cosh(p1.d);
    if (Math.abs(d) < 1e-10) {
      d = 0.0;
    }
    push_double(d);
    return;
  }
  if (iszero(p1)) {
    push(one);
    return;
  }
  push_symbol(COSH);
  push(p1);
  return list(2);
};

test_cosh = function() {
  return run_test(["cosh(x)", "cosh(x)", "cosh(0)", "1", "cosh(arccosh(x))", "x"]);
};

init = function() {
  var i, o, ref;
  i = 0;
  flag = 0;
  tos = 0;
  esc_flag = 0;
  draw_flag = 0;
  frame = stack + TOS;
  p0 = symbol(NIL);
  p1 = symbol(NIL);
  p2 = symbol(NIL);
  p3 = symbol(NIL);
  p4 = symbol(NIL);
  p5 = symbol(NIL);
  p6 = symbol(NIL);
  p7 = symbol(NIL);
  p8 = symbol(NIL);
  p9 = symbol(NIL);
  if (flag) {
    return;
  }
  flag = 1;
  for (i = o = 0, ref = NSYM; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    symtab[i].k = SYM;
    binding[i] = symtab + i;
    arglist[i] = symbol(NIL);
  }
  std_symbol("abs", ABS);
  std_symbol("add", ADD);
  std_symbol("adj", ADJ);
  std_symbol("and", AND);
  std_symbol("arccos", ARCCOS);
  std_symbol("arccosh", ARCCOSH);
  std_symbol("arcsin", ARCSIN);
  std_symbol("arcsinh", ARCSINH);
  std_symbol("arctan", ARCTAN);
  std_symbol("arctanh", ARCTANH);
  std_symbol("arg", ARG);
  std_symbol("atomize", ATOMIZE);
  std_symbol("besselj", BESSELJ);
  std_symbol("bessely", BESSELY);
  std_symbol("binding", BINDING);
  std_symbol("binomial", BINOMIAL);
  std_symbol("ceiling", CEILING);
  std_symbol("check", CHECK);
  std_symbol("choose", CHOOSE);
  std_symbol("circexp", CIRCEXP);
  std_symbol("clear", CLEAR);
  std_symbol("clock", CLOCK);
  std_symbol("coeff", COEFF);
  std_symbol("cofactor", COFACTOR);
  std_symbol("condense", CONDENSE);
  std_symbol("conj", CONJ);
  std_symbol("contract", CONTRACT);
  std_symbol("cos", COS);
  std_symbol("cosh", COSH);
  std_symbol("decomp", DECOMP);
  std_symbol("defint", DEFINT);
  std_symbol("deg", DEGREE);
  std_symbol("denominator", DENOMINATOR);
  std_symbol("det", DET);
  std_symbol("derivative", DERIVATIVE);
  std_symbol("dim", DIM);
  std_symbol("dirac", DIRAC);
  std_symbol("display", DISPLAY);
  std_symbol("divisors", DIVISORS);
  std_symbol("do", DO);
  std_symbol("dot", DOT);
  std_symbol("draw", DRAW);
  std_symbol("dsolve", DSOLVE);
  std_symbol("erf", ERF);
  std_symbol("erfc", ERFC);
  std_symbol("eigen", EIGEN);
  std_symbol("eigenval", EIGENVAL);
  std_symbol("eigenvec", EIGENVEC);
  std_symbol("eval", EVAL);
  std_symbol("exp", EXP);
  std_symbol("expand", EXPAND);
  std_symbol("expcos", EXPCOS);
  std_symbol("expsin", EXPSIN);
  std_symbol("factor", FACTOR);
  std_symbol("factorial", FACTORIAL);
  std_symbol("factorpoly", FACTORPOLY);
  std_symbol("filter", FILTER);
  std_symbol("float", FLOATF);
  std_symbol("floor", FLOOR);
  std_symbol("for", FOR);
  std_symbol("Gamma", GAMMA);
  std_symbol("gcd", GCD);
  std_symbol("hermite", HERMITE);
  std_symbol("hilbert", HILBERT);
  std_symbol("imag", IMAG);
  std_symbol("component", INDEX);
  std_symbol("inner", INNER);
  std_symbol("integral", INTEGRAL);
  std_symbol("inv", INV);
  std_symbol("invg", INVG);
  std_symbol("isinteger", ISINTEGER);
  std_symbol("isprime", ISPRIME);
  std_symbol("laguerre", LAGUERRE);
  std_symbol("lcm", LCM);
  std_symbol("leading", LEADING);
  std_symbol("legendre", LEGENDRE);
  std_symbol("log", LOG);
  std_symbol("mag", MAG);
  std_symbol("mod", MOD);
  std_symbol("multiply", MULTIPLY);
  std_symbol("not", NOT);
  std_symbol("nroots", NROOTS);
  std_symbol("number", NUMBER);
  std_symbol("numerator", NUMERATOR);
  std_symbol("operator", OPERATOR);
  std_symbol("or", OR);
  std_symbol("outer", OUTER);
  std_symbol("polar", POLAR);
  std_symbol("power", POWER);
  std_symbol("prime", PRIME);
  std_symbol("print", PRINT);
  std_symbol("product", PRODUCT);
  std_symbol("quote", QUOTE);
  std_symbol("quotient", QUOTIENT);
  std_symbol("rank", RANK);
  std_symbol("rationalize", RATIONALIZE);
  std_symbol("real", REAL);
  std_symbol("rect", YYRECT);
  std_symbol("roots", ROOTS);
  std_symbol("equals", SETQ);
  std_symbol("sgn", SGN);
  std_symbol("simplify", SIMPLIFY);
  std_symbol("sin", SIN);
  std_symbol("sinh", SINH);
  std_symbol("sqrt", SQRT);
  std_symbol("stop", STOP);
  std_symbol("subst", SUBST);
  std_symbol("sum", SUM);
  std_symbol("tan", TAN);
  std_symbol("tanh", TANH);
  std_symbol("taylor", TAYLOR);
  std_symbol("test", TEST);
  std_symbol("testeq", TESTEQ);
  std_symbol("testge", TESTGE);
  std_symbol("testgt", TESTGT);
  std_symbol("testle", TESTLE);
  std_symbol("testlt", TESTLT);
  std_symbol("transpose", TRANSPOSE);
  std_symbol("unit", UNIT);
  std_symbol("zero", ZERO);
  std_symbol("nil", NIL);
  std_symbol("autoexpand", AUTOEXPAND);
  std_symbol("bake", BAKE);
  std_symbol("last", LAST);
  std_symbol("trace", TRACE);
  std_symbol("tty", TTY);
  std_symbol("~", YYE);
  std_symbol("$DRAWX", DRAWX);
  std_symbol("$METAA", METAA);
  std_symbol("$METAB", METAB);
  std_symbol("$METAX", METAX);
  std_symbol("$SECRETX", SECRETX);
  std_symbol("pi", PI);
  std_symbol("a", SYMBOL_A);
  std_symbol("b", SYMBOL_B);
  std_symbol("c", SYMBOL_C);
  std_symbol("d", SYMBOL_D);
  std_symbol("i", SYMBOL_I);
  std_symbol("j", SYMBOL_J);
  std_symbol("n", SYMBOL_N);
  std_symbol("r", SYMBOL_R);
  std_symbol("s", SYMBOL_S);
  std_symbol("t", SYMBOL_T);
  std_symbol("x", SYMBOL_X);
  std_symbol("y", SYMBOL_Y);
  std_symbol("z", SYMBOL_Z);
  std_symbol("$C1", C1);
  std_symbol("$C2", C2);
  std_symbol("$C3", C3);
  std_symbol("$C4", C4);
  std_symbol("$C5", C5);
  std_symbol("$C6", C6);
  push_integer(0);
  zero = pop();
  push_integer(1);
  one = pop();
  push_symbol(POWER);
  push_integer(-1);
  push_rational(1, 2);
  list(3);
  imaginaryunit = pop();
  return defn();
};

defn_str = ["e=exp(1)", "i=sqrt(-1)", "autoexpand=1", "trange=(-pi,pi)", "xrange=(-10,10)", "yrange=(-10,10)", "last=0", "trace=0", "tty=0", "cross(u,v)=(u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1])", "curl(v)=(d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y))", "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)", "ln(x)=log(x)"];

defn = function() {
  var i, n, o, ref, results;
  i = 0;
  n = 0;
  n = defn_str.length;
  results = [];
  for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    scan(defn_str[i]);
    eval();
    results.push(pop());
  }
  return results;
};

Eval_decomp = function() {
  var h;
  h = tos;
  push(symbol(NIL));
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  p1 = pop();
  if (p1 === symbol(NIL)) {
    guess();
  } else {
    push(p1);
  }
  decomp();
  return list(tos - h);
};

decomp = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (Find(p1, p2) === 0) {
    push(p1);
    restore();
    return;
  }
  if (isadd(p1)) {
    decomp_sum();
    restore();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    decomp_product();
    restore();
    return;
  }
  p3 = cdr(p1);
  while (iscons(p3)) {
    push(car(p3));
    push(p2);
    decomp();
    p3 = cdr(p3);
  }
  return restore();
};

decomp_sum = function() {
  var h;
  h = 0;
  p3 = cdr(p1);
  while (iscons(p3)) {
    if (Find(car(p3), p2)) {
      push(car(p3));
      push(p2);
      decomp();
    }
    p3 = cdr(p3);
  }
  h = tos;
  p3 = cdr(p1);
  while (iscons(p3)) {
    if (Find(car(p3), p2) === 0) {
      push(car(p3));
    }
    p3 = cdr(p3);
  }
  if (tos - h) {
    add_all(tos - h);
    p3 = pop();
    push(p3);
    push(p3);
    return negate();
  }
};

decomp_product = function() {
  var h;
  h = 0;
  p3 = cdr(p1);
  while (iscons(p3)) {
    if (Find(car(p3), p2)) {
      push(car(p3));
      push(p2);
      decomp();
    }
    p3 = cdr(p3);
  }
  h = tos;
  p3 = cdr(p1);
  while (iscons(p3)) {
    if (Find(car(p3), p2) === 0) {
      push(car(p3));
    }
    p3 = cdr(p3);
  }
  if (tos - h) {
    return multiply_all(tos - h);
  }
};

define_user_function = function() {
  p3 = caadr(p1);
  p4 = cdadr(p1);
  p5 = caddr(p1);
  if (!issymbol(p3)) {
    stop("function name?");
  }
  if (car(p5) === symbol(EVAL)) {
    push(cadr(p5));
    Eval();
    p5 = pop();
  }
  set_binding_and_arglist(p3, p5, p4);
  return push_symbol(NIL);
};

Eval_defint = function() {
  push(cadr(p1));
  Eval();
  p2 = pop();
  p1 = cddr(p1);
  while (iscons(p1)) {
    push(car(p1));
    p1 = cdr(p1);
    Eval();
    p3 = pop();
    push(car(p1));
    p1 = cdr(p1);
    Eval();
    p4 = pop();
    push(car(p1));
    p1 = cdr(p1);
    Eval();
    p5 = pop();
    push(p2);
    push(p3);
    integral();
    p2 = pop();
    push(p2);
    push(p3);
    push(p5);
    subst();
    Eval();
    push(p2);
    push(p3);
    push(p4);
    subst();
    Eval();
    subtract();
    p2 = pop();
  }
  return push(p2);
};

test_defint = function() {
  return run_test(["defint(x^2,y,0,sqrt(1-x^2),x,-1,1)", "1/8*pi", "z=2", "", "P=(x,y,z)", "", "a=abs(cross(d(P,x),d(P,y)))", "", "defint(a,y,-sqrt(1-x^2),sqrt(1-x^2),x,-1,1)", "pi", "z=x^2+2y", "", "P=(x,y,z)", "", "a=abs(cross(d(P,x),d(P,y)))", "", "defint(a,x,0,1,y,0,1)", "3/2+5/8*log(5)", "x=u*cos(v)", "", "y=u*sin(v)", "", "z=v", "", "S=(x,y,z)", "", "a=abs(cross(d(S,u),d(S,v)))", "", "defint(a,u,0,1,v,0,3pi)", "3/2*pi*log(1+2^(1/2))+3*pi/(2^(1/2))"]);
};

Eval_degree = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  p1 = pop();
  if (p1 === symbol(NIL)) {
    guess();
  } else {
    push(p1);
  }
  return degree();
};

degree = function() {
  save();
  p2 = pop();
  p1 = pop();
  p3 = zero;
  yydegree(p1);
  push(p3);
  return restore();
};

yydegree = function(p) {
  var results;
  if (equal(p, p2)) {
    if (iszero(p3)) {
      return p3 = one;
    }
  } else if (car(p) === symbol(POWER)) {
    if (equal(cadr(p), p2) && isnum(caddr(p)) && lessp(p3, caddr(p))) {
      return p3 = caddr(p);
    }
  } else if (iscons(p)) {
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      yydegree(car(p));
      results.push(p = cdr(p));
    }
    return results;
  }
};

Eval_denominator = function() {
  push(cadr(p1));
  Eval();
  return denominator();
};

denominator = function() {
  var h;
  h = 0;
  save();
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    push(p1);
    rationalize();
    p1 = pop();
  }
  if (car(p1) === symbol(MULTIPLY)) {
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      denominator();
      p1 = cdr(p1);
    }
    multiply_all(tos - h);
  } else if (isrational(p1)) {
    push(p1);
    mp_denominator();
  } else if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
    push(p1);
    reciprocate();
  } else {
    push(one);
  }
  return restore();
};

test_denominator = function() {
  return run_test(["denominator(2/3)", "3", "denominator(x)", "1", "denominator(1/x)", "x", "denominator(a+b)", "1", "denominator(1/a+1/b)", "a*b", "denominator(1/(x-1)/(x-2))", "x^2-3*x+2"]);
};

Eval_derivative = function() {
  var ac, doNothing, i, n, o, ref, ref1;
  i = 0;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    guess();
    push(symbol(NIL));
  } else if (isnum(p2)) {
    guess();
    push(p2);
  } else {
    push(p2);
    p1 = cdr(p1);
    push(car(p1));
    Eval();
  }
  p5 = pop();
  p4 = pop();
  p3 = pop();
  while (1.) {
    if (isnum(p5)) {
      push(p5);
      n = pop_integer();
      if (n === 0x80000000) {
        stop("nth derivative: check n");
      }
    } else {
      n = 1;
    }
    push(p3);
    if (n >= 0) {
      for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        push(p4);
        derivative();
      }
    } else {
      n = -n;
      for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
        push(p4);
        integral();
      }
    }
    p3 = pop();
    if (p5 === symbol(NIL)) {
      break;
    }
    if (isnum(p5)) {
      p1 = cdr(p1);
      push(car(p1));
      Eval();
      p5 = pop();
      if (p5 === symbol(NIL)) {
        break;
      }
      if (isnum(p5)) {
        doNothing = 1;
      } else {
        p4 = p5;
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
      }
    } else {
      p4 = p5;
      p1 = cdr(p1);
      push(car(p1));
      Eval();
      p5 = pop();
    }
  }
  return push(p3);
};

derivative = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (isnum(p2)) {
    stop("undefined function");
  }
  if (istensor(p1)) {
    if (istensor(p2)) {
      d_tensor_tensor();
    } else {
      d_tensor_scalar();
    }
  } else {
    if (istensor(p2)) {
      d_scalar_tensor();
    } else {
      d_scalar_scalar();
    }
  }
  return restore();
};

d_scalar_scalar = function() {
  if (issymbol(p2)) {
    return d_scalar_scalar_1();
  } else {
    push(p1);
    push(p2);
    push(symbol(SECRETX));
    subst();
    push(symbol(SECRETX));
    derivative();
    push(symbol(SECRETX));
    push(p2);
    return subst();
  }
};

d_scalar_scalar_1 = function() {
  if (equal(p1, p2)) {
    push(one);
    return;
  }
  if (!iscons(p1)) {
    push(zero);
    return;
  }
  if (isadd(p1)) {
    dsum();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    dproduct();
    return;
  }
  if (car(p1) === symbol(POWER)) {
    dpower();
    return;
  }
  if (car(p1) === symbol(DERIVATIVE)) {
    dd();
    return;
  }
  if (car(p1) === symbol(LOG)) {
    dlog();
    return;
  }
  if (car(p1) === symbol(SIN)) {
    dsin();
    return;
  }
  if (car(p1) === symbol(COS)) {
    dcos();
    return;
  }
  if (car(p1) === symbol(TAN)) {
    dtan();
    return;
  }
  if (car(p1) === symbol(ARCSIN)) {
    darcsin();
    return;
  }
  if (car(p1) === symbol(ARCCOS)) {
    darccos();
    return;
  }
  if (car(p1) === symbol(ARCTAN)) {
    darctan();
    return;
  }
  if (car(p1) === symbol(SINH)) {
    dsinh();
    return;
  }
  if (car(p1) === symbol(COSH)) {
    dcosh();
    return;
  }
  if (car(p1) === symbol(TANH)) {
    dtanh();
    return;
  }
  if (car(p1) === symbol(ARCSINH)) {
    darcsinh();
    return;
  }
  if (car(p1) === symbol(ARCCOSH)) {
    darccosh();
    return;
  }
  if (car(p1) === symbol(ARCTANH)) {
    darctanh();
    return;
  }
  if (car(p1) === symbol(ABS)) {
    dabs();
    return;
  }
  if (car(p1) === symbol(SGN)) {
    dsgn();
    return;
  }
  if (car(p1) === symbol(HERMITE)) {
    dhermite();
    return;
  }
  if (car(p1) === symbol(ERF)) {
    derf();
    return;
  }
  if (car(p1) === symbol(ERFC)) {
    derfc();
    return;
  }
  if (car(p1) === symbol(BESSELJ)) {
    if (iszero(caddr(p1))) {
      dbesselj0();
    } else {
      dbesseljn();
    }
    return;
  }
  if (car(p1) === symbol(BESSELY)) {
    if (iszero(caddr(p1))) {
      dbessely0();
    } else {
      dbesselyn();
    }
    return;
  }
  if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {
    derivative_of_integral();
    return;
  }
  return dfunction();
};

dsum = function() {
  var h;
  h = tos;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    push(p2);
    derivative();
    p1 = cdr(p1);
  }
  return add_all(tos - h);
};

dproduct = function() {
  var ac, i, j, n, o, ref, ref1;
  i = 0;
  j = 0;
  n = 0;
  n = length(p1) - 1;
  for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    p3 = cdr(p1);
    for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
      push(car(p3));
      if (i === j) {
        push(p2);
        derivative();
      }
      p3 = cdr(p3);
    }
    multiply_all(n);
  }
  return add_all(n);
};

dpower = function() {
  push(caddr(p1));
  push(cadr(p1));
  divide();
  push(cadr(p1));
  push(p2);
  derivative();
  multiply();
  push(cadr(p1));
  logarithm();
  push(caddr(p1));
  push(p2);
  derivative();
  multiply();
  add();
  push(p1);
  return multiply();
};

dlog = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  return divide();
};

dd = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  p3 = pop();
  if (car(p3) === symbol(DERIVATIVE)) {
    push_symbol(DERIVATIVE);
    push_symbol(DERIVATIVE);
    push(cadr(p3));
    if (lessp(caddr(p3), caddr(p1))) {
      push(caddr(p3));
      list(3);
      push(caddr(p1));
    } else {
      push(caddr(p1));
      list(3);
      push(caddr(p3));
    }
    return list(3);
  } else {
    push(p3);
    push(caddr(p1));
    return derivative();
  }
};

dfunction = function() {
  p3 = cdr(p1);
  if (p3 === symbol(NIL) || Find(p3, p2)) {
    push_symbol(DERIVATIVE);
    push(p1);
    push(p2);
    return list(3);
  } else {
    return push(zero);
  }
};

dsin = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  cosine();
  return multiply();
};

dcos = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  sine();
  multiply();
  return negate();
};

dtan = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  cosine();
  push_integer(-2);
  power();
  return multiply();
};

darcsin = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(1);
  push(cadr(p1));
  push_integer(2);
  power();
  subtract();
  push_rational(-1, 2);
  power();
  return multiply();
};

darccos = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(1);
  push(cadr(p1));
  push_integer(2);
  power();
  subtract();
  push_rational(-1, 2);
  power();
  multiply();
  return negate();
};

darctan = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(1);
  push(cadr(p1));
  push_integer(2);
  power();
  add();
  inverse();
  multiply();
  return simplify();
};

dsinh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  ycosh();
  return multiply();
};

dcosh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  ysinh();
  return multiply();
};

dtanh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  ycosh();
  push_integer(-2);
  power();
  return multiply();
};

darcsinh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push_integer(2);
  power();
  push_integer(1);
  add();
  push_rational(-1, 2);
  power();
  return multiply();
};

darccosh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push_integer(2);
  power();
  push_integer(-1);
  add();
  push_rational(-1, 2);
  power();
  return multiply();
};

darctanh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(1);
  push(cadr(p1));
  push_integer(2);
  power();
  subtract();
  inverse();
  return multiply();
};

dabs = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  sgn();
  return multiply();
};

dsgn = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  dirac();
  multiply();
  push_integer(2);
  return multiply();
};

dhermite = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(2);
  push(caddr(p1));
  multiply();
  multiply();
  push(cadr(p1));
  push(caddr(p1));
  push_integer(-1);
  add();
  hermite();
  return multiply();
};

derf = function() {
  push(cadr(p1));
  push_integer(2);
  power();
  push_integer(-1);
  multiply();
  exponential();
  push_symbol(PI);
  push_rational(-1, 2);
  power();
  multiply();
  push_integer(2);
  multiply();
  push(cadr(p1));
  push(p2);
  derivative();
  return multiply();
};

derfc = function() {
  push(cadr(p1));
  push_integer(2);
  power();
  push_integer(-1);
  multiply();
  exponential();
  push_symbol(PI);
  push_rational(-1, 2);
  power();
  multiply();
  push_integer(-2);
  multiply();
  push(cadr(p1));
  push(p2);
  derivative();
  return multiply();
};

dbesselj0 = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push_integer(1);
  besselj();
  multiply();
  push_integer(-1);
  return multiply();
};

dbesseljn = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push(caddr(p1));
  push_integer(-1);
  add();
  besselj();
  push(caddr(p1));
  push_integer(-1);
  multiply();
  push(cadr(p1));
  divide();
  push(cadr(p1));
  push(caddr(p1));
  besselj();
  multiply();
  add();
  return multiply();
};

dbessely0 = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push_integer(1);
  besselj();
  multiply();
  push_integer(-1);
  return multiply();
};

dbesselyn = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push(caddr(p1));
  push_integer(-1);
  add();
  bessely();
  push(caddr(p1));
  push_integer(-1);
  multiply();
  push(cadr(p1));
  divide();
  push(cadr(p1));
  push(caddr(p1));
  bessely();
  multiply();
  add();
  return multiply();
};

derivative_of_integral = function() {
  return push(cadr(p1));
};

test_derivative = function() {
  return run_test(["x=quote(x)", "", "f=quote(f)", "", "g=quote(g)", "", "d(a,x)", "0", "d(x,x)", "1", "d(x^2,x)", "2*x", "d(log(x),x)", "1/x", "d(exp(x),x)", "exp(x)", "d(a^x,x)", "a^x*log(a)", "d(x^x,x)-(x^x+x^x*log(x))", "0", "d(log(x^2+5),x)-(2*x/(5+x^2))", "0", "d(d(f(x),x),y)", "0", "d(d(f(x),y),x)", "0", "d(d(f(y),x),y)", "0", "d(d(f(y),y),x)", "0", "d((x*y*z,y,x+z),(x,y,z))", "((y*z,x*z,x*y),(0,1,0),(1,0,1))", "d(x+z,(x,y,z))", "(1,0,1)", "d(cos(theta)^2,cos(theta))", "2*cos(theta)", "d(f())", "d(f(),x)", "d(x^2)", "2*x", "d(t^2)", "2*t", "d(t^2 x^2)", "2*t^2*x", "d(sin(x),x)-cos(x)", "0", "d(cos(x),x)+sin(x)", "0", "d(tan(x),x)-cos(x)^(-2)", "0", "d(arcsin(x),x)-1/sqrt(1-x^2)", "0", "d(arccos(x),x)+1/sqrt(1-x^2)", "0", "d(arctan(x),x)-1/(1+x^2)", "0", "d(arctan(y/x),x)", "-y/(x^2+y^2)", "d(arctan(y/x),y)", "x/(x^2+y^2)", "d(sinh(x),x)-cosh(x)", "0", "d(cosh(x),x)-sinh(x)", "0", "d(tanh(x),x)-cosh(x)^(-2)", "0", "d(arcsinh(x),x)-1/sqrt(x^2+1)", "0", "d(arccosh(x),x)-1/sqrt(x^2-1)", "0", "d(arctanh(x),x)-1/(1-x^2)", "0", "d(sin(cos(x)),x)+cos(cos(x))*sin(x)", "0", "d(sin(x)^2,x)-2*sin(x)*cos(x)", "0", "d(sin(cos(x)),cos(x))-cos(cos(x))", "0", "d(abs(x),x)", "sgn(x)", "d(sgn(x),x)", "2*dirac(x)", "d(f(),x)", "d(f(),x)", "d(f(x),x)", "d(f(x),x)", "d(f(y),x)", "0", "d(g(f(x)),f(x))", "d(g(f(x)),f(x))", "d(g(f(x)),x)", "d(g(f(x)),x)", "d(erf(x))-2*exp(-x^2)/sqrt(pi)", "0", "f=x^5*y^7", "", "d(f)", "5*x^4*y^7", "d(f,x)", "5*x^4*y^7", "d(f,x,0)", "x^5*y^7", "d(f,x,1)", "5*x^4*y^7", "d(f,x,2)", "20*x^3*y^7", "d(f,2)", "20*x^3*y^7", "d(f,2,y)", "140*x^3*y^6", "d(f,x,x,y,y)", "840*x^3*y^5", "f=quote(f)", ""]);
};

check_arg = function() {
  if (!istensor(p1)) {
    return 0;
  } else if (p1.tensor.ndim !== 2) {
    return 0;
  } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {
    return 0;
  } else {
    return 1;
  }
};

det = function() {
  var a, ac, i, n, o, ref, ref1;
  i = 0;
  n = 0;
  save();
  p1 = pop();
  if (check_arg() === 0) {
    push_symbol(DET);
    push(p1);
    list(2);
    restore();
    return;
  }
  n = p1.tensor.nelem;
  a = p1.tensor.elem;
  for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    if (!isnum(a[i])) {
      break;
    }
  }
  if (i === n) {
    yydetg();
  } else {
    for (i = ac = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      push(p1.tensor.elem[i]);
    }
    determinant(p1.tensor.dim[0]);
  }
  return restore();
};

determinant = function(n) {
  var a, ac, breakFromOutherWhile, h, i, j, k, o, q, ref, ref1, sign, t;
  h = 0;
  i = 0;
  j = 0;
  k = 0;
  q = 0;
  s = 0;
  sign = 0;
  t = 0;
  a = [];
  h = tos - n * n;
  for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    a[i] = i;
    a[i + n] = 0;
    a[i + n + n] = 1;
  }
  sign = 1;
  push(zero);
  while (1) {
    if (sign === 1) {
      push_integer(1);
    } else {
      push_integer(-1);
    }
    for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      k = n * a[i] + i;
      push(stack[h + k]);
      multiply();
    }
    add();
    j = n - 1;
    s = 0;
    breakFromOutherWhile = false;
    while (1) {
      q = a[n + j] + a[n + n + j];
      if (q < 0) {
        a[n + n + j] = -a[n + n + j];
        j--;
        continue;
      }
      if (q === j + 1) {
        if (j === 0) {
          breakFromOutherWhile = true;
          break;
        }
        s++;
        a[n + n + j] = -a[n + n + j];
        j--;
        continue;
      }
      break;
    }
    if (breakFromOutherWhile) {
      break;
    }
    t = a[j - a[n + j] + s];
    a[j - a[n + j] + s] = a[j - q + s];
    a[j - q + s] = t;
    a[n + j] = q;
    sign = -sign;
  }
  stack[h] = stack[tos - 1];
  return tos = h + 1;
};

detg = function() {
  save();
  p1 = pop();
  if (check_arg() === 0) {
    push_symbol(DET);
    push(p1);
    list(2);
    restore();
    return;
  }
  yydetg();
  return restore();
};

yydetg = function() {
  var i, n, o, ref;
  i = 0;
  n = 0;
  n = p1.tensor.dim[0];
  for (i = o = 0, ref = n * n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
    push(p1.tensor.elem[i]);
  }
  lu_decomp(n);
  tos -= n * n;
  return push(p1);
};

M = function(h, n, i, j) {
  return stack[h + n * i + j];
};

setM = function(h, n, i, j, value) {
  return stack[h + n * i + j] = value;
};

lu_decomp = function(n) {
  var ac, ad, ae, af, d, h, i, j, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;
  d = 0;
  h = 0;
  i = 0;
  j = 0;
  h = tos - n * n;
  p1 = one;
  for (d = o = 0, ref = n - 1; 0 <= ref ? o < ref : o > ref; d = 0 <= ref ? ++o : --o) {
    if (equal(M(h, n, d, d), zero)) {
      for (i = ac = ref1 = d + 1, ref2 = n; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
        if (!equal(M(h, n, i, d), zero)) {
          break;
        }
      }
      if (i === n) {
        p1 = zero;
        break;
      }
      for (j = ad = ref3 = d, ref4 = n; ref3 <= ref4 ? ad < ref4 : ad > ref4; j = ref3 <= ref4 ? ++ad : --ad) {
        p2 = M(h, n, d, j);
        setM(h, n, d, j, M(h, n, i, j));
        setM(h, n, i, j, p2);
      }
      push(p1);
      negate();
      p1 = pop();
    }
    push(p1);
    push(M(h, n, d, d));
    multiply();
    p1 = pop();
    for (i = ae = ref5 = d + 1, ref6 = n; ref5 <= ref6 ? ae < ref6 : ae > ref6; i = ref5 <= ref6 ? ++ae : --ae) {
      push(M(h, n, i, d));
      push(M(h, n, d, d));
      divide();
      negate();
      p2 = pop();
      setM(h, n, i, d, zero);
      for (j = af = ref7 = d + 1, ref8 = n; ref7 <= ref8 ? af < ref8 : af > ref8; j = ref7 <= ref8 ? ++af : --af) {
        push(M(h, n, d, j));
        push(p2);
        multiply();
        push(M(h, n, i, j));
        add();
        setM(h, n, i, j, pop());
      }
    }
  }
  push(p1);
  push(M(h, n, n - 1, n - 1));
  multiply();
  return p1 = pop();
};

Eval_dirac = function() {
  push(cadr(p1));
  Eval();
  return dirac();
};

dirac = function() {
  save();
  ydirac();
  return restore();
};

ydirac = function() {
  p1 = pop();
  if (isdouble(p1)) {
    if (p1.d === 0) {
      push_integer(1);
      return;
    } else {
      push_integer(0);
      return;
    }
  }
  if (isrational(p1)) {
    if (MZERO(mmul(p1.q.a, p1.q.b))) {
      push_integer(1);
      return;
    } else {
      push_integer(0);
      return;
    }
  }
  if (car(p1) === symbol(POWER)) {
    push_symbol(DIRAC);
    push(cadr(p1));
    list(2);
    return;
  }
  if (isnegativeterm(p1)) {
    push_symbol(DIRAC);
    push(p1);
    negate();
    list(2);
    return;
  }
  if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {
    push(p1);
    negate();
    p1 = pop();
  }
  push_symbol(DIRAC);
  push(p1);
  return list(2);
};

test_dirac = function() {
  return run_test(["dirac(-x)", "dirac(x)"]);
};

YMAX = 10000;

glyph = (function() {
  function glyph() {}

  glyph.prototype.c = 0;

  glyph.prototype.x = 0;

  glyph.prototype.y = 0;

  return glyph;

})();

chartab = [];

for (charTabIndex = o = 0, ref = YMAX; 0 <= ref ? o < ref : o > ref; charTabIndex = 0 <= ref ? ++o : --o) {
  chartab[charTabIndex] = new glyph();
}

yindex = 0;

level = 0;

emit_x = 0;

expr_level = 0;

display_flag = 0;

printchar_nowrap = function(character, accumulator) {
  var topLevelCall;
  if (accumulator == null) {
    topLevelCall = true;
    accumulator = "";
  }
  accumulator += character;
  return accumulator;
};

printchar = function(character, accumulator) {
  return printchar_nowrap(character, accumulator);
};

display = function(p) {
  var h, ref1, w, y;
  h = 0;
  w = 0;
  y = 0;
  save();
  yindex = 0;
  level = 0;
  emit_x = 0;
  emit_top_expr(p);
  ref1 = get_size(0, yindex), h = ref1[0], w = ref1[1], y = ref1[2];
  if (w > 100) {
    printline(p);
    restore();
    return;
  }
  print_it();
  return restore();
};

emit_top_expr = function(p) {
  if (car(p) === symbol(SETQ)) {
    emit_expr(cadr(p));
    __emit_str(" = ");
    emit_expr(caddr(p));
    return;
  }
  if (istensor(p)) {
    return emit_tensor(p);
  } else {
    return emit_expr(p);
  }
};

will_be_displayed_as_fraction = function(p) {
  if (level > 0) {
    return 0;
  }
  if (isfraction(p)) {
    return 1;
  }
  if (car(p) !== symbol(MULTIPLY)) {
    return 0;
  }
  if (isfraction(cadr(p))) {
    return 1;
  }
  while (iscons(p)) {
    if (isdenominator(car(p))) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

emit_expr = function(p) {
  expr_level++;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    if (__is_negative(car(p))) {
      __emit_char('-');
      if (will_be_displayed_as_fraction(car(p))) {
        __emit_char(' ');
      }
    }
    emit_term(car(p));
    p = cdr(p);
    while (iscons(p)) {
      if (__is_negative(car(p))) {
        __emit_char(' ');
        __emit_char('-');
        __emit_char(' ');
      } else {
        __emit_char(' ');
        __emit_char('+');
        __emit_char(' ');
      }
      emit_term(car(p));
      p = cdr(p);
    }
  } else {
    if (__is_negative(p)) {
      __emit_char('-');
      if (will_be_displayed_as_fraction(p)) {
        __emit_char(' ');
      }
    }
    emit_term(p);
  }
  return expr_level--;
};

emit_unsigned_expr = function(p) {
  var results;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    emit_term(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      if (__is_negative(car(p))) {
        __emit_char(' ');
        __emit_char('-');
        __emit_char(' ');
      } else {
        __emit_char(' ');
        __emit_char('+');
        __emit_char(' ');
      }
      emit_term(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return emit_term(p);
  }
};

__is_negative = function(p) {
  if (isnegativenumber(p)) {
    return 1;
  }
  if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
    return 1;
  }
  return 0;
};

emit_term = function(p) {
  var n;
  if (car(p) === symbol(MULTIPLY)) {
    n = count_denominators(p);
    if (n && level === 0) {
      return emit_fraction(p, n);
    } else {
      return emit_multiply(p, n);
    }
  } else {
    return emit_factor(p);
  }
};

isdenominator = function(p) {
  if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

count_denominators = function(p) {
  var count, q;
  count = 0;
  p = cdr(p);
  while (iscons(p)) {
    q = car(p);
    if (isdenominator(q)) {
      count++;
    }
    p = cdr(p);
  }
  return count;
};

emit_multiply = function(p, n) {
  var results;
  if (n === 0) {
    p = cdr(p);
    if (isplusone(car(p)) || isminusone(car(p))) {
      p = cdr(p);
    }
    emit_factor(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      __emit_char(' ');
      emit_factor(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    emit_numerators(p);
    __emit_char('/');
    if (n > 1 || isfraction(cadr(p))) {
      __emit_char('(');
      emit_denominators(p);
      return __emit_char(')');
    } else {
      return emit_denominators(p);
    }
  }
};

emit_fraction = function(p, d) {
  var count, doNothing, k1, k2, n, x;
  count = 0;
  k1 = 0;
  k2 = 0;
  n = 0;
  x = 0;
  save();
  p3 = one;
  p4 = one;
  if (isrational(cadr(p))) {
    push(cadr(p));
    mp_numerator();
    absval();
    p3 = pop();
    push(cadr(p));
    mp_denominator();
    p4 = pop();
  }
  if (isdouble(cadr(p))) {
    push(cadr(p));
    absval();
    p3 = pop();
  }
  if (isplusone(p3)) {
    n = 0;
  } else {
    n = 1;
  }
  p1 = cdr(p);
  if (isnum(car(p1))) {
    p1 = cdr(p1);
  }
  while (iscons(p1)) {
    p2 = car(p1);
    if (isdenominator(p2)) {
      doNothing = 1;
    } else {
      n++;
    }
    p1 = cdr(p1);
  }
  x = emit_x;
  k1 = yindex;
  count = 0;
  if (!isplusone(p3)) {
    emit_number(p3, 0);
    count++;
  }
  p1 = cdr(p);
  if (isnum(car(p1))) {
    p1 = cdr(p1);
  }
  while (iscons(p1)) {
    p2 = car(p1);
    if (isdenominator(p2)) {
      doNothing = 1;
    } else {
      if (count > 0) {
        __emit_char(' ');
      }
      if (n === 1) {
        emit_expr(p2);
      } else {
        emit_factor(p2);
      }
      count++;
    }
    p1 = cdr(p1);
  }
  if (count === 0) {
    __emit_char('1');
  }
  k2 = yindex;
  count = 0;
  if (!isplusone(p4)) {
    emit_number(p4, 0);
    count++;
    d++;
  }
  p1 = cdr(p);
  if (isrational(car(p1))) {
    p1 = cdr(p1);
  }
  while (iscons(p1)) {
    p2 = car(p1);
    if (isdenominator(p2)) {
      if (count > 0) {
        __emit_char(' ');
      }
      emit_denominator(p2, d);
      count++;
    }
    p1 = cdr(p1);
  }
  fixup_fraction(x, k1, k2);
  return restore();
};

emit_numerators = function(p) {
  var doNothing, n;
  int(n);
  save();
  p1 = one;
  p = cdr(p);
  if (isrational(car(p))) {
    push(car(p));
    mp_numerator();
    absval();
    p1 = pop();
    p = cdr(p);
  } else if (isdouble(car(p))) {
    push(car(p));
    absval();
    p1 = pop();
    p = cdr(p);
  }
  n = 0;
  if (!isplusone(p1)) {
    emit_number(p1, 0);
    n++;
  }
  while (iscons(p)) {
    if (isdenominator(car(p))) {
      doNothing = 1;
    } else {
      if (n > 0) {
        __emit_char(' ');
      }
      emit_factor(car(p));
      n++;
    }
    p = cdr(p);
  }
  if (n === 0) {
    __emit_char('1');
  }
  return restore();
};

emit_denominators = function(p) {
  var n;
  int(n);
  save();
  n = 0;
  p = cdr(p);
  if (isfraction(car(p))) {
    push(car(p));
    mp_denominator();
    p1 = pop();
    emit_number(p1, 0);
    n++;
    p = cdr(p);
  }
  while (iscons(p)) {
    if (isdenominator(car(p))) {
      if (n > 0) {
        __emit_char(' ');
      }
      emit_denominator(car(p), 0);
      n++;
    }
    p = cdr(p);
  }
  return restore();
};

emit_factor = function(p) {
  if (istensor(p)) {
    if (level === 0) {
      emit_flat_tensor(p);
    } else {
      emit_flat_tensor(p);
    }
    return;
  }
  if (isdouble(p)) {
    emit_number(p, 0);
    return;
  }
  if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {
    emit_subexpr(p);
    return;
  }
  if (car(p) === symbol(POWER)) {
    emit_power(p);
    return;
  }
  if (iscons(p)) {
    emit_function(p);
    return;
  }
  if (isnum(p)) {
    if (level === 0) {
      emit_numerical_fraction(p);
    } else {
      emit_number(p, 0);
    }
    return;
  }
  if (issymbol(p)) {
    emit_symbol(p);
    return;
  }
  if (isstr(p)) {
    emit_string(p);
  }
};

emit_numerical_fraction = function(p) {
  var k1, k2, x;
  k1 = 0;
  k2 = 0;
  x = 0;
  save();
  push(p);
  mp_numerator();
  absval();
  p3 = pop();
  push(p);
  mp_denominator();
  p4 = pop();
  if (isplusone(p4)) {
    emit_number(p3, 0);
    restore();
    return;
  }
  x = emit_x;
  k1 = yindex;
  emit_number(p3, 0);
  k2 = yindex;
  emit_number(p4, 0);
  fixup_fraction(x, k1, k2);
  return restore();
};

isfactor = function(p) {
  if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {
    return 1;
  }
  if (issymbol(p)) {
    return 1;
  }
  if (isfraction(p)) {
    return 0;
  }
  if (isnegativenumber(p)) {
    return 0;
  }
  if (isnum(p)) {
    return 1;
  }
  return 0;
};

emit_power = function(p) {
  var k1, k2, x;
  k1 = 0;
  k2 = 0;
  x = 0;
  if (cadr(p) === symbol(E)) {
    __emit_str("exp(");
    emit_expr(caddr(p));
    __emit_char(')');
    return;
  }
  if (level > 0) {
    if (isminusone(caddr(p))) {
      __emit_char('1');
      __emit_char('/');
      if (isfactor(cadr(p))) {
        emit_factor(cadr(p));
      } else {
        emit_subexpr(cadr(p));
      }
    } else {
      if (isfactor(cadr(p))) {
        emit_factor(cadr(p));
      } else {
        emit_subexpr(cadr(p));
      }
      __emit_char('^');
      if (isfactor(caddr(p))) {
        emit_factor(caddr(p));
      } else {
        emit_subexpr(caddr(p));
      }
    }
    return;
  }
  if (__is_negative(caddr(p))) {
    x = emit_x;
    k1 = yindex;
    __emit_char('1');
    k2 = yindex;
    emit_denominator(p, 1);
    fixup_fraction(x, k1, k2);
    return;
  }
  k1 = yindex;
  if (isfactor(cadr(p))) {
    emit_factor(cadr(p));
  } else {
    emit_subexpr(cadr(p));
  }
  k2 = yindex;
  level++;
  emit_expr(caddr(p));
  level--;
  return fixup_power(k1, k2);
};

emit_denominator = function(p, n) {
  var k1, k2;
  k1 = 0;
  k2 = 0;
  if (isminusone(caddr(p))) {
    if (n === 1) {
      emit_expr(cadr(p));
    } else {
      emit_factor(cadr(p));
    }
    return;
  }
  k1 = yindex;
  if (isfactor(cadr(p))) {
    emit_factor(cadr(p));
  } else {
    emit_subexpr(cadr(p));
  }
  k2 = yindex;
  level++;
  emit_unsigned_expr(caddr(p));
  level--;
  return fixup_power(k1, k2);
};

emit_function = function(p) {
  if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {
    emit_index_function(p);
    return;
  }
  if (car(p) === symbol(FACTORIAL)) {
    emit_factorial_function(p);
    return;
  }
  if (car(p) === symbol(DERIVATIVE)) {
    __emit_char('d');
  } else {
    emit_symbol(car(p));
  }
  __emit_char('(');
  p = cdr(p);
  if (iscons(p)) {
    emit_expr(car(p));
    p = cdr(p);
    while (iscons(p)) {
      __emit_char(',');
      emit_expr(car(p));
      p = cdr(p);
    }
  }
  return __emit_char(')');
};

emit_index_function = function(p) {
  p = cdr(p);
  if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {
    emit_subexpr(car(p));
  } else {
    emit_expr(car(p));
  }
  __emit_char('[');
  p = cdr(p);
  if (iscons(p)) {
    emit_expr(car(p));
    p = cdr(p);
    while (iscons(p)) {
      __emit_char(',');
      emit_expr(car(p));
      p = cdr(p);
    }
  }
  return __emit_char(']');
};

emit_factorial_function = function(p) {
  p = cadr(p);
  if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {
    emit_subexpr(p);
  } else {
    emit_expr(p);
  }
  return __emit_char('!');
};

emit_subexpr = function(p) {
  __emit_char('(');
  emit_expr(p);
  return __emit_char(')');
};

emit_symbol = function(p) {
  var ac, i, pPrintName, ref1, results;
  i = 0;
  if (p === symbol(E)) {
    __emit_str("exp(1)");
    return;
  }
  pPrintName = get_printname(p);
  results = [];
  for (i = ac = 0, ref1 = pPrintName.length; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    results.push(__emit_char(pPrintName[i]));
  }
  return results;
};

emit_string = function(p) {
  var ac, i, pString, ref1, results;
  i = 0;
  pString = p.str;
  results = [];
  for (i = ac = 0, ref1 = pString.length; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    results.push(__emit_char(pString[i]));
  }
  return results;
};

fixup_fraction = function(x, k1, k2) {
  var ac, dx, dy, h1, h2, i, ref1, ref2, ref3, results, w, w1, w2, y, y1, y2;
  dx = 0;
  dy = 0;
  i = 0;
  w = 0;
  y = 0;
  h1 = 0;
  w1 = 0;
  y1 = 0;
  h2 = 0;
  w2 = 0;
  y2 = 0;
  ref1 = get_size(k1, k2), h1 = ref1[0], w1 = ref1[1], y1 = ref1[2];
  ref2 = get_size(k2, yindex), h2 = ref2[0], w2 = ref2[1], y2 = ref2[2];
  if (w2 > w1) {
    dx = (w2 - w1) / 2;
  } else {
    dx = 0;
  }
  dx++;
  y = y1 + h1 - 1;
  dy = -y - 1;
  move(k1, k2, dx, dy);
  if (w2 > w1) {
    dx = -w1;
  } else {
    dx = -w1 + (w1 - w2) / 2;
  }
  dx++;
  dy = -y2 + 1;
  move(k2, yindex, dx, dy);
  if (w2 > w1) {
    w = w2;
  } else {
    w = w1;
  }
  w += 2;
  emit_x = x;
  results = [];
  for (i = ac = 0, ref3 = w; 0 <= ref3 ? ac < ref3 : ac > ref3; i = 0 <= ref3 ? ++ac : --ac) {
    results.push(__emit_char('-'));
  }
  return results;
};

fixup_power = function(k1, k2) {
  var dy, h1, h2, ref1, ref2, w1, w2, y1, y2;
  dy = 0;
  h1 = 0;
  w1 = 0;
  y1 = 0;
  h2 = 0;
  w2 = 0;
  y2 = 0;
  ref1 = get_size(k1, k2), h1 = ref1[0], w1 = ref1[1], y1 = ref1[2];
  ref2 = get_size(k2, yindex), h2 = ref2[0], w2 = ref2[1], y2 = ref2[2];
  dy = -y2 - h2 + 1;
  dy += y1 - 1;
  return move(k2, yindex, 0, dy);
};

move = function(j, k, dx, dy) {
  var ac, i, ref1, ref2, results;
  i = 0;
  results = [];
  for (i = ac = ref1 = j, ref2 = k; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
    chartab[i].x += dx;
    results.push(chartab[i].y += dy);
  }
  return results;
};

get_size = function(j, k) {
  var ac, h, i, max_x, max_y, min_x, min_y, ref1, ref2, w, y;
  i = 0;
  min_x = chartab[j].x;
  max_x = chartab[j].x;
  min_y = chartab[j].y;
  max_y = chartab[j].y;
  for (i = ac = ref1 = j + 1, ref2 = k; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
    if (chartab[i].x < min_x) {
      min_x = chartab[i].x;
    }
    if (chartab[i].x > max_x) {
      max_x = chartab[i].x;
    }
    if (chartab[i].y < min_y) {
      min_y = chartab[i].y;
    }
    if (chartab[i].y > max_y) {
      max_y = chartab[i].y;
    }
  }
  h = max_y - min_y + 1;
  w = max_x - min_x + 1;
  y = min_y;
  return [h, w, y];
};

displaychar = function(c) {
  return __emit_char(c);
};

__emit_char = function(c) {
  if (yindex === YMAX) {
    return;
  }
  if (chartab[yindex] == null) {
    debugger;
  }
  chartab[yindex].c = c;
  chartab[yindex].x = emit_x;
  chartab[yindex].y = 0;
  yindex++;
  return emit_x++;
};

__emit_str = function(s) {
  var ac, i, ref1, results;
  i = 0;
  results = [];
  for (i = ac = 0, ref1 = s.length; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    results.push(__emit_char(s[i]));
  }
  return results;
};

emit_number = function(p, emit_sign) {
  var ac, ad, ae, i, ref1, ref2, ref3, results, results1, tmpString;
  tmpString = "";
  i = 0;
  switch (p.k) {
    case NUM:
      tmpString = p.q.a.toString();
      if (tmpString[0] === '-' && emit_sign === 0) {
        tmpString = tmpString.substring(1);
      }
      for (i = ac = 0, ref1 = tmpString.length; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
        __emit_char(tmpString[i]);
      }
      tmpString = p.q.b.toString();
      if (tmpString === "1") {
        break;
      }
      __emit_char('/');
      results = [];
      for (i = ad = 0, ref2 = tmpString.length; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
        results.push(__emit_char(tmpString[i]));
      }
      return results;
      break;
    case DOUBLE:
      tmpString = doubleToReasonableString(p.d);
      if (tmpString[0] === '-' && emit_sign === 0) {
        tmpString = tmpString.substring(1);
      }
      results1 = [];
      for (i = ae = 0, ref3 = tmpString.length; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
        results1.push(__emit_char(tmpString[i]));
      }
      return results1;
  }
};

cmpGlyphs = function(a, b) {
  if (a.y < b.y) {
    return -1;
  }
  if (a.y > b.y) {
    return 1;
  }
  if (a.x < b.x) {
    return -1;
  }
  if (a.x > b.x) {
    return 1;
  }
  return 0;
};

print_it = function() {
  var ac, accumulatedPrint, i, ref1, subsetOfStack, x, y;
  i = 0;
  accumulatedPrint = "";
  subsetOfStack = chartab.slice(0, yindex);
  subsetOfStack.sort(cmpGlyphs);
  chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
  x = 0;
  y = chartab[0].y;
  for (i = ac = 0, ref1 = yindex; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    while (chartab[i].y > y) {
      accumulatedPrint = printchar('\n', accumulatedPrint);
      x = 0;
      y++;
    }
    while (chartab[i].x > x) {
      accumulatedPrint = printchar_nowrap(' ', accumulatedPrint);
      x++;
    }
    accumulatedPrint = printchar_nowrap(chartab[i].c, accumulatedPrint);
    x++;
  }
  return console.log(accumulatedPrint);
};

buffer = "";

getdisplaystr = function() {
  yindex = 0;
  level = 0;
  emit_x = 0;
  emit_expr(pop());
  fill_buf();
  return buffer;
};

fill_buf = function() {
  var ac, i, ref1, sIndex, subsetOfStack, tmpBuffer, x, y;
  tmpBuffer = buffer;
  sIndex = 0;
  i = 0;
  subsetOfStack = chartab.slice(0, yindex);
  subsetOfStack.sort(cmpGlyphs);
  chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
  x = 0;
  y = chartab[0].y;
  for (i = ac = 0, ref1 = yindex; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    while (chartab[i].y > y) {
      tmpBuffer[sIndex++] = '\n';
      x = 0;
      y++;
    }
    while (chartab[i].x > x) {
      tmpBuffer[sIndex++] = ' ';
      x++;
    }
    tmpBuffer[sIndex++] = chartab[i].c;
    x++;
  }
  return tmpBuffer[sIndex++] = '\n';
};

N = 100;

oneElement = (function() {
  function oneElement() {}

  oneElement.prototype.x = 0;

  oneElement.prototype.y = 0;

  oneElement.prototype.h = 0;

  oneElement.prototype.w = 0;

  oneElement.prototype.index = 0;

  oneElement.prototype.count = 0;

  return oneElement;

})();

elem = [];

for (elelmIndex = ac = 0; ac < 10000; elelmIndex = ++ac) {
  elem[elelmIndex] = new oneElement;
}

SPACE_BETWEEN_COLUMNS = 3;

SPACE_BETWEEN_ROWS = 1;

emit_tensor = function(p) {
  var ad, ae, af, ag, col, dx, dy, eh, ew, h, i, n, ncol, nrow, ref1, ref2, ref3, ref4, ref5, row, w, x, y;
  i = 0;
  n = 0;
  nrow = 0;
  ncol = 0;
  x = 0;
  y = 0;
  h = 0;
  w = 0;
  dx = 0;
  dy = 0;
  eh = 0;
  ew = 0;
  row = 0;
  col = 0;
  if (p.tensor.ndim > 2) {
    emit_flat_tensor(p);
    return;
  }
  nrow = p.tensor.dim[0];
  if (p.tensor.ndim === 2) {
    ncol = p.tensor.dim[1];
  } else {
    ncol = 1;
  }
  n = nrow * ncol;
  if (n > N) {
    emit_flat_tensor(p);
    return;
  }
  x = emit_x;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    elem[i].index = yindex;
    elem[i].x = emit_x;
    emit_expr(p.tensor.elem[i]);
    elem[i].count = yindex - elem[i].index;
    ref2 = get_size(elem[i].index, yindex), elem[i].h = ref2[0], elem[i].w = ref2[1], elem[i].y = ref2[2];
  }
  eh = 0;
  ew = 0;
  for (i = ae = 0, ref3 = n; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
    if (elem[i].h > eh) {
      eh = elem[i].h;
    }
    if (elem[i].w > ew) {
      ew = elem[i].w;
    }
  }
  h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;
  w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;
  y = -(h / 2);
  for (row = af = 0, ref4 = nrow; 0 <= ref4 ? af < ref4 : af > ref4; row = 0 <= ref4 ? ++af : --af) {
    for (col = ag = 0, ref5 = ncol; 0 <= ref5 ? ag < ref5 : ag > ref5; col = 0 <= ref5 ? ++ag : --ag) {
      i = row * ncol + col;
      dx = x - elem[i].x;
      dy = y - elem[i].y;
      move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
      dx = 0;
      if (col > 0) {
        dx = col * (ew + SPACE_BETWEEN_COLUMNS);
      }
      dy = 0;
      if (row > 0) {
        dy = row * (eh + SPACE_BETWEEN_ROWS);
      }
      dx += (ew - elem[i].w) / 2;
      dy += (eh - elem[i].h) / 2;
      move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
    }
  }
  return emit_x = x + w;

  /*
  	if 0
  
  		 * left brace
  
  		for (i = 0; i < h; i++) {
  			if (yindex == YMAX)
  				break;
  			chartab[yindex].c = '|';
  			chartab[yindex].x = x - 2;
  			chartab[yindex].y = y + i;
  			yindex++;
  		}
  
  		 * right brace
  
  		emit_x++;
  
  		for (i = 0; i < h; i++) {
  			if (yindex == YMAX)
  				break;
  			chartab[yindex].c = '|';
  			chartab[yindex].x = emit_x;
  			chartab[yindex].y = y + i;
  			yindex++;
  		}
  
  		emit_x++;
  
  	endif
   */
};

emit_flat_tensor = function(p) {
  return emit_tensor_inner(p, 0, 0);
};

emit_tensor_inner = function(p, j, k) {
  var ad, i, ref1;
  i = 0;
  __emit_char('(');
  for (i = ad = 0, ref1 = p.tensor.dim[j]; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    if (j + 1 === p.tensor.ndim) {
      emit_expr(p.tensor.elem[k]);
      k = k + 1;
    } else {
      k = emit_tensor_inner(p, j + 1, k);
    }
    if (i + 1 < p.tensor.dim[j]) {
      __emit_char(',');
    }
  }
  __emit_char(')');
  return k;
};

s = ["format=1", "", "((a,b),(c,d))", "a   b\n", "\n", "c   d", "1/sqrt(-15)", "       i\n", "- -----------\n", "    1/2  1/2\n", "   3    5", "x^(1/a)", " 1/a\n", "x", "x^(a/b)", " a/b\n", "x", "x^(a/2)", " 1/2 a\n", "x", "x^(1/(a+b))", " 1/(a + b)\n", "x"];


/*
void
test_display(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

divisors = function() {
  var ad, h, i, n, ref1, subsetOfStack;
  i = 0;
  h = 0;
  n = 0;
  save();
  h = tos - 1;
  divisors_onstack();
  n = tos - h;
  subsetOfStack = stack.slice(h, h + n);
  subsetOfStack.sort(cmp_expr);
  stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
  p1 = alloc_tensor(n);
  p1.tensor.ndim = 1;
  p1.tensor.dim[0] = n;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    p1.tensor.elem[i] = stack[h + i];
  }
  tos = h;
  push(p1);
  return restore();
};

divisors_onstack = function() {
  var ad, h, i, k, n, ref1;
  h = 0;
  i = 0;
  k = 0;
  n = 0;
  save();
  p1 = pop();
  h = tos;
  if (isnum(p1)) {
    push(p1);
    factor_small_number();
  } else if (car(p1) === symbol(ADD)) {
    push(p1);
    __factor_add();
  } else if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    if (isnum(car(p1))) {
      push(car(p1));
      factor_small_number();
      p1 = cdr(p1);
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (car(p2) === symbol(POWER)) {
        push(cadr(p2));
        push(caddr(p2));
      } else {
        push(p2);
        push(one);
      }
      p1 = cdr(p1);
    }
  } else if (car(p1) === symbol(POWER)) {
    push(cadr(p1));
    push(caddr(p1));
  } else {
    push(p1);
    push(one);
  }
  k = tos;
  push(one);
  gen(h, k);
  n = tos - k;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    stack[h + i] = stack[k + i];
  }
  tos = h + n;
  return restore();
};

gen = function(h, k) {
  var ad, expo, i, ref1;
  expo = 0;
  i = 0;
  save();
  p1 = pop();
  if (h === k) {
    push(p1);
    restore();
    return;
  }
  p2 = stack[h + 0];
  p3 = stack[h + 1];
  push(p3);
  expo = pop_integer();
  for (i = ad = 0, ref1 = Math.abs(expo); 0 <= ref1 ? ad <= ref1 : ad >= ref1; i = 0 <= ref1 ? ++ad : --ad) {
    push(p1);
    push(p2);
    push_integer(sign(expo) * i);
    power();
    multiply();
    gen(h + 2, k);
  }
  return restore();
};

__factor_add = function() {
  save();
  p1 = pop();
  p3 = cdr(p1);
  push(car(p3));
  p3 = cdr(p3);
  while (iscons(p3)) {
    push(car(p3));
    gcd();
    p3 = cdr(p3);
  }
  p2 = pop();
  if (isplusone(p2)) {
    push(p1);
    push(one);
    restore();
    return;
  }
  if (isnum(p2)) {
    push(p2);
    factor_small_number();
  } else if (car(p2) === symbol(MULTIPLY)) {
    p3 = cdr(p2);
    if (isnum(car(p3))) {
      push(car(p3));
      factor_small_number();
    } else {
      push(car(p3));
      push(one);
    }
    p3 = cdr(p3);
    while (iscons(p3)) {
      push(car(p3));
      push(one);
      p3 = cdr(p3);
    }
  } else {
    push(p2);
    push(one);
  }
  push(p2);
  inverse();
  p2 = pop();
  push(zero);
  p3 = cdr(p1);
  while (iscons(p3)) {
    push(p2);
    push(car(p3));
    multiply();
    add();
    p3 = cdr(p3);
  }
  push(one);
  return restore();
};

test_divisors = function() {
  return run_test(["divisors(12)", "(1,2,3,4,6,12)", "divisors(-12)", "(1,2,3,4,6,12)", "divisors(a)", "(1,a)", "divisors(-a)", "(1,a)", "divisors(+3*x+3)", "(1,3,1+x,3+3*x)", "divisors(+3*x-3)", "(1,3,-3+3*x,-1+x)", "divisors(-3*x+3)", "(1,3,1-x,3-3*x)", "divisors(-3*x-3)", "(1,3,1+x,3+3*x)"]);
};

dpow = function() {
  var a, b, base, expo, result, theta;
  a = 0.0;
  b = 0.0;
  base = 0.0;
  expo = 0.0;
  result = 0.0;
  theta = 0.0;
  expo = pop_double();
  base = pop_double();
  if (base === 0.0 && expo < 0.0) {
    stop("divide by zero");
  }
  if (base >= 0.0 || (expo % 1.0) === 0.0) {
    result = Math.pow(base, expo);
    push_double(result);
    return;
  }
  result = Math.pow(Math.abs(base), expo);
  theta = Math.PI * expo;
  if ((expo % 0.5) === 0.0) {
    a = 0.0;
    b = Math.sin(theta);
  } else {
    a = Math.cos(theta);
    b = Math.sin(theta);
  }
  push_double(a * result);
  push_double(b * result);
  push(imaginaryunit);
  multiply();
  return add();
};

Eval_erf = function() {
  push(cadr(p1));
  Eval();
  return yerf();
};

yerf = function() {
  save();
  yyerf();
  return restore();
};

yyerf = function() {
  var d;
  d = 0.0;
  p1 = pop();
  if (isdouble(p1)) {
    d = 1.0 - erfc(p1.d);
    push_double(d);
    return;
  }
  if (isnegativeterm(p1)) {
    push_symbol(ERF);
    push(p1);
    negate();
    list(2);
    negate();
    return;
  }
  push_symbol(ERF);
  push(p1);
  list(2);
};

test_erf = function() {
  return run_test(["erf(a)", "erf(a)", "erf(0.0) + 1", "1", "float(erf(0)) + 1", "1"]);
};


/*

#two potential more tests that were
 * commented-out

#if 0
"float(erf(1))",
"0.842701",
#endif
 */

Eval_erfc = function() {
  push(cadr(p1));
  Eval();
  return yerfc();
};

yerfc = function() {
  save();
  yyerfc();
  return restore();
};

yyerfc = function() {
  var d;
  d = 0.0;
  p1 = pop();
  if (isdouble(p1)) {
    d = erfc(p1.d);
    push_double(d);
    return;
  }
  push_symbol(ERFC);
  push(p1);
  list(2);
};

erfc = function(x) {
  var ans, t, z;
  t = 0.0;
  z = 0.0;
  ans = 0.0;
  z = Math.abs(x);
  t = 1.0 / (1.0 + 0.5 * z);
  ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));
  if (x >= 0.0) {
    return ans;
  } else {
    return 2.0 - ans;
  }
};


/*
	 * commented-out test
	"float(erfc(1))",
	"0.157299",
 */

test_erfc = function() {
  return run_test(["erfc(a)", "erfc(a)", "erfc(0.0)", "1", "float(erfc(0))", "1"]);
};

Eval = function() {
  check_esc_flag();
  save();
  p1 = pop();
  if (p1 == null) {
    debugger;
  }
  switch (p1.k) {
    case CONS:
      Eval_cons();
      break;
    case NUM:
      push(p1);
      break;
    case DOUBLE:
      push(p1);
      break;
    case STR:
      push(p1);
      break;
    case TENSOR:
      Eval_tensor();
      break;
    case SYM:
      Eval_sym();
      break;
    default:
      stop("atom?");
  }
  return restore();
};

Eval_sym = function() {
  if (iskeyword(p1)) {
    push(p1);
    push(symbol(LAST));
    list(2);
    Eval();
    return;
  }
  p2 = get_binding(p1);
  push(p2);
  if (p1 !== p2) {
    return Eval();
  }
};

Eval_cons = function() {
  if (!issymbol(car(p1))) {
    stop("cons?");
  }
  switch (symnum(car(p1))) {
    case ABS:
      return Eval_abs();
    case ADD:
      return Eval_add();
    case ADJ:
      return Eval_adj();
    case AND:
      return Eval_and();
    case ARCCOS:
      return Eval_arccos();
    case ARCCOSH:
      return Eval_arccosh();
    case ARCSIN:
      return Eval_arcsin();
    case ARCSINH:
      return Eval_arcsinh();
    case ARCTAN:
      return Eval_arctan();
    case ARCTANH:
      return Eval_arctanh();
    case ARG:
      return Eval_arg();
    case ATOMIZE:
      return Eval_atomize();
    case BESSELJ:
      return Eval_besselj();
    case BESSELY:
      return Eval_bessely();
    case BINDING:
      return Eval_binding();
    case BINOMIAL:
      return Eval_binomial();
    case CEILING:
      return Eval_ceiling();
    case CHECK:
      return Eval_check();
    case CHOOSE:
      return Eval_choose();
    case CIRCEXP:
      return Eval_circexp();
    case CLEAR:
      return Eval_clear();
    case CLOCK:
      return Eval_clock();
    case COEFF:
      return Eval_coeff();
    case COFACTOR:
      return Eval_cofactor();
    case CONDENSE:
      return Eval_condense();
    case CONJ:
      return Eval_conj();
    case CONTRACT:
      return Eval_contract();
    case COS:
      return Eval_cos();
    case COSH:
      return Eval_cosh();
    case DECOMP:
      return Eval_decomp();
    case DEGREE:
      return Eval_degree();
    case DEFINT:
      return Eval_defint();
    case DENOMINATOR:
      return Eval_denominator();
    case DERIVATIVE:
      return Eval_derivative();
    case DET:
      return Eval_det();
    case DIM:
      return Eval_dim();
    case DIRAC:
      return Eval_dirac();
    case DISPLAY:
      return Eval_display();
    case DIVISORS:
      return Eval_divisors();
    case DO:
      return Eval_do();
    case DOT:
      return Eval_inner();
    case DRAW:
      return Eval_draw();
    case DSOLVE:
      return Eval_dsolve();
    case EIGEN:
      return Eval_eigen();
    case EIGENVAL:
      return Eval_eigenval();
    case EIGENVEC:
      return Eval_eigenvec();
    case ERF:
      return Eval_erf();
    case ERFC:
      return Eval_erfc();
    case EVAL:
      return Eval_Eval();
    case EXP:
      return Eval_exp();
    case EXPAND:
      return Eval_expand();
    case EXPCOS:
      return Eval_expcos();
    case EXPSIN:
      return Eval_expsin();
    case FACTOR:
      return Eval_factor();
    case FACTORIAL:
      return Eval_factorial();
    case FACTORPOLY:
      return Eval_factorpoly();
    case FILTER:
      return Eval_filter();
    case FLOATF:
      return Eval_float();
    case FLOOR:
      return Eval_floor();
    case FOR:
      return Eval_for();
    case GAMMA:
      return Eval_gamma();
    case GCD:
      return Eval_gcd();
    case HERMITE:
      return Eval_hermite();
    case HILBERT:
      return Eval_hilbert();
    case IMAG:
      return Eval_imag();
    case INDEX:
      return Eval_index();
    case INNER:
      return Eval_inner();
    case INTEGRAL:
      return Eval_integral();
    case INV:
      return Eval_inv();
    case INVG:
      return Eval_invg();
    case ISINTEGER:
      return Eval_isinteger();
    case ISPRIME:
      return Eval_isprime();
    case LAGUERRE:
      return Eval_laguerre();
    case LCM:
      return Eval_lcm();
    case LEADING:
      return Eval_leading();
    case LEGENDRE:
      return Eval_legendre();
    case LOG:
      return Eval_log();
    case MAG:
      return Eval_mag();
    case MOD:
      return Eval_mod();
    case MULTIPLY:
      return Eval_multiply();
    case NOT:
      return Eval_not();
    case NROOTS:
      return Eval_nroots();
    case NUMBER:
      return Eval_number();
    case NUMERATOR:
      return Eval_numerator();
    case OPERATOR:
      return Eval_operator();
    case OR:
      return Eval_or();
    case OUTER:
      return Eval_outer();
    case POLAR:
      return Eval_polar();
    case POWER:
      return Eval_power();
    case PRIME:
      return Eval_prime();
    case PRINT:
      return Eval_display();
    case PRODUCT:
      return Eval_product();
    case QUOTE:
      return Eval_quote();
    case QUOTIENT:
      return Eval_quotient();
    case RANK:
      return Eval_rank();
    case RATIONALIZE:
      return Eval_rationalize();
    case REAL:
      return Eval_real();
    case YYRECT:
      return Eval_rect();
    case ROOTS:
      return Eval_roots();
    case SETQ:
      return Eval_setq();
    case SGN:
      return Eval_sgn();
    case SIMPLIFY:
      return Eval_simplify();
    case SIN:
      return Eval_sin();
    case SINH:
      return Eval_sinh();
    case SQRT:
      return Eval_sqrt();
    case STOP:
      return Eval_stop();
    case SUBST:
      return Eval_subst();
    case SUM:
      return Eval_sum();
    case TAN:
      return Eval_tan();
    case TANH:
      return Eval_tanh();
    case TAYLOR:
      return Eval_taylor();
    case TEST:
      return Eval_test();
    case TESTEQ:
      return Eval_testeq();
    case TESTGE:
      return Eval_testge();
    case TESTGT:
      return Eval_testgt();
    case TESTLE:
      return Eval_testle();
    case TESTLT:
      return Eval_testlt();
    case TRANSPOSE:
      return Eval_transpose();
    case UNIT:
      return Eval_unit();
    case ZERO:
      return Eval_zero();
    default:
      return Eval_user_function();
  }
};

Eval_binding = function() {
  return push(get_binding(cadr(p1)));
};

Eval_check = function() {
  push(cadr(p1));
  Eval_predicate();
  p1 = pop();
  if (iszero(p1)) {
    stop("check(arg): arg is zero");
  }
  return push(symbol(NIL));
};

Eval_det = function() {
  push(cadr(p1));
  Eval();
  return det();
};

Eval_dim = function() {
  var n;
  push(cadr(p1));
  Eval();
  p2 = pop();
  if (iscons(cddr(p1))) {
    push(caddr(p1));
    Eval();
    n = pop_integer();
  } else {
    n = 1;
  }
  if (!istensor(p2)) {
    return push_integer(1);
  } else if (n < 1 || n > p2.tensor.ndim) {
    return push(p1);
  } else {
    return push_integer(p2.tensor.dim[n - 1]);
  }
};

Eval_divisors = function() {
  push(cadr(p1));
  Eval();
  return divisors();
};

Eval_do = function() {
  var results;
  push(car(p1));
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    pop();
    push(car(p1));
    Eval();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_dsolve = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadddr(p1));
  Eval();
  return dsolve();
};

Eval_Eval = function() {
  push(cadr(p1));
  Eval();
  p1 = cddr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    push(cadr(p1));
    Eval();
    subst();
    p1 = cddr(p1);
  }
  return Eval();
};

Eval_exp = function() {
  push(cadr(p1));
  Eval();
  return exponential();
};

Eval_factorial = function() {
  push(cadr(p1));
  Eval();
  return factorial();
};

Eval_factorpoly = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  factorpoly();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    factorpoly();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_hermite = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return hermite();
};

Eval_hilbert = function() {
  push(cadr(p1));
  Eval();
  return hilbert();
};

Eval_index = function() {
  var h;
  h = tos;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    p1 = cdr(p1);
  }
  return index_function(tos - h);
};

Eval_inv = function() {
  push(cadr(p1));
  Eval();
  return inv();
};

Eval_invg = function() {
  push(cadr(p1));
  Eval();
  return invg();
};

Eval_isinteger = function() {
  var n;
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (isrational(p1)) {
    if (isinteger(p1)) {
      push(one);
    } else {
      push(zero);
    }
    return;
  }
  if (isdouble(p1)) {
    n = Math.floor(p1.d);
    if (n === p1.d) {
      push(one);
    } else {
      push(zero);
    }
    return;
  }
  push_symbol(ISINTEGER);
  push(p1);
  return list(2);
};

Eval_multiply = function() {
  var results;
  push(cadr(p1));
  Eval();
  p1 = cddr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    multiply();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_number = function() {
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (p1.k === NUM || p1.k === DOUBLE) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_operator = function() {
  var h;
  h = tos;
  push_symbol(OPERATOR);
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    p1 = cdr(p1);
  }
  return list(tos - h);
};

Eval_print = function() {
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    if (equaln(get_binding(symbol(TTY)), 1)) {
      printline(pop());
    } else {
      display(pop());
    }
    p1 = cdr(p1);
  }
  return push(symbol(NIL));
};

Eval_quote = function() {
  return push(cadr(p1));
};

Eval_rank = function() {
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (istensor(p1)) {
    return push_integer(p1.tensor.ndim);
  } else {
    return push(zero);
  }
};

setq_indexed = function() {
  var h;
  p4 = cadadr(p1);
  if (!issymbol(p4)) {
    stop("indexed assignment: error in symbol");
  }
  h = tos;
  push(caddr(p1));
  Eval();
  p2 = cdadr(p1);
  while (iscons(p2)) {
    push(car(p2));
    Eval();
    p2 = cdr(p2);
  }
  set_component(tos - h);
  p3 = pop();
  set_binding(p4, p3);
  return push(symbol(NIL));
};

Eval_setq = function() {
  if (caadr(p1) === symbol(INDEX)) {
    setq_indexed();
    return;
  }
  if (iscons(cadr(p1))) {
    define_user_function();
    return;
  }
  if (!issymbol(cadr(p1))) {
    stop("symbol assignment: error in symbol");
  }
  push(caddr(p1));
  Eval();
  p2 = pop();
  set_binding(cadr(p1), p2);
  return push(symbol(NIL));
};

Eval_sqrt = function() {
  push(cadr(p1));
  Eval();
  push_rational(1, 2);
  return power();
};

Eval_stop = function() {
  return stop("user stop");
};

Eval_subst = function() {
  push(cadddr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadr(p1));
  Eval();
  subst();
  return Eval();
};

Eval_unit = function() {
  var ad, i, n, ref1;
  i = 0;
  n = 0;
  push(cadr(p1));
  Eval();
  n = pop_integer();
  if (n < 2) {
    push(p1);
    return;
  }
  p1 = alloc_tensor(n * n);
  p1.tensor.ndim = 2;
  p1.tensor.dim[0] = n;
  p1.tensor.dim[1] = n;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    p1.tensor.elem[n * i + i] = one;
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  return push(p1);
};

Eval_noexpand = function() {
  var x;
  x = expanding;
  expanding = 0;
  Eval();
  return expanding = x;
};

Eval_predicate = function() {
  save();
  p1 = pop();
  if (car(p1) === symbol(SETQ)) {
    Eval_testeq();
  } else {
    push(p1);
    Eval();
  }
  return restore();
};

Eval_expand = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    guess();
  } else {
    push(p2);
  }
  return expand();
};

expand = function() {
  save();
  p9 = pop();
  p5 = pop();
  if (istensor(p5)) {
    expand_tensor();
    restore();
    return;
  }
  if (car(p5) === symbol(ADD)) {
    push_integer(0);
    p1 = cdr(p5);
    while (iscons(p1)) {
      push(car(p1));
      push(p9);
      expand();
      add();
      p1 = cdr(p1);
    }
    restore();
    return;
  }
  push(p5);
  numerator();
  p3 = pop();
  push(p5);
  denominator();
  p2 = pop();
  remove_negative_exponents();
  push(p3);
  push(p2);
  push(p9);
  divpoly();
  p7 = pop();
  push(p3);
  push(p2);
  push(p7);
  multiply();
  subtract();
  p3 = pop();
  if (iszero(p3)) {
    push(p7);
    restore();
    return;
  }
  push(p2);
  push(p9);
  factorpoly();
  p2 = pop();
  expand_get_C();
  expand_get_B();
  expand_get_A();
  if (istensor(p4)) {
    push(p4);
    inv();
    push(p3);
    inner();
    push(p2);
    inner();
  } else {
    push(p3);
    push(p4);
    divide();
    push(p2);
    multiply();
  }
  push(p7);
  add();
  return restore();
};

expand_tensor = function() {
  var ad, i, ref1;
  i = 0;
  push(p5);
  copy_tensor();
  p5 = pop();
  for (i = ad = 0, ref1 = p5.tensor.nelem; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    push(p5.tensor.elem[i]);
    push(p9);
    expand();
    p5.tensor.elem[i] = pop();
  }
  return push(p5);
};

remove_negative_exponents = function() {
  var ad, h, i, j, k, n, ref1;
  h = 0;
  i = 0;
  j = 0;
  k = 0;
  n = 0;
  h = tos;
  factors(p2);
  factors(p3);
  n = tos - h;
  j = 0;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    p1 = stack[h + i];
    if (car(p1) !== symbol(POWER)) {
      continue;
    }
    if (cadr(p1) !== p9) {
      continue;
    }
    push(caddr(p1));
    k = pop_integer();
    if (k === 0x80000000) {
      continue;
    }
    if (k < j) {
      j = k;
    }
  }
  tos = h;
  if (j === 0) {
    return;
  }
  push(p2);
  push(p9);
  push_integer(-j);
  power();
  multiply();
  p2 = pop();
  push(p3);
  push(p9);
  push_integer(-j);
  power();
  multiply();
  return p3 = pop();
};

expand_get_C = function() {
  var a, ad, ae, h, i, j, n, ref1, ref2;
  h = 0;
  i = 0;
  j = 0;
  n = 0;
  h = tos;
  if (car(p2) === symbol(MULTIPLY)) {
    p1 = cdr(p2);
    while (iscons(p1)) {
      p5 = car(p1);
      expand_get_CF();
      p1 = cdr(p1);
    }
  } else {
    p5 = p2;
    expand_get_CF();
  }
  n = tos - h;
  if (n === 1) {
    p4 = pop();
    return;
  }
  p4 = alloc_tensor(n * n);
  p4.tensor.ndim = 2;
  p4.tensor.dim[0] = n;
  p4.tensor.dim[1] = n;
  a = h;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    for (j = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; j = 0 <= ref2 ? ++ae : --ae) {
      push(stack[a + j]);
      push(p9);
      push_integer(i);
      power();
      divide();
      push(p9);
      filter();
      p4.tensor.elem[n * i + j] = pop();
    }
  }
  return tos -= n;
};

expand_get_CF = function() {
  var ad, d, i, j, n, ref1, results;
  d = 0;
  i = 0;
  j = 0;
  n = 0;
  if (!Find(p5, p9)) {
    return;
  }
  trivial_divide();
  if (car(p5) === symbol(POWER)) {
    push(caddr(p5));
    n = pop_integer();
    p6 = cadr(p5);
  } else {
    n = 1;
    p6 = p5;
  }
  push(p6);
  push(p9);
  degree();
  d = pop_integer();
  results = [];
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    results.push((function() {
      var ae, ref2, results1;
      results1 = [];
      for (j = ae = 0, ref2 = d; 0 <= ref2 ? ae < ref2 : ae > ref2; j = 0 <= ref2 ? ++ae : --ae) {
        push(p8);
        push(p6);
        push_integer(i);
        power();
        multiply();
        push(p9);
        push_integer(j);
        power();
        results1.push(multiply());
      }
      return results1;
    })());
  }
  return results;
};

trivial_divide = function() {
  var h;
  h = 0;
  if (car(p2) === symbol(MULTIPLY)) {
    h = tos;
    p0 = cdr(p2);
    while (iscons(p0)) {
      if (!equal(car(p0), p5)) {
        push(car(p0));
        Eval();
      }
      p0 = cdr(p0);
    }
    multiply_all(tos - h);
  } else {
    push_integer(1);
  }
  return p8 = pop();
};

expand_get_B = function() {
  var ad, i, n, ref1;
  i = 0;
  n = 0;
  if (!istensor(p4)) {
    return;
  }
  n = p4.tensor.dim[0];
  p8 = alloc_tensor(n);
  p8.tensor.ndim = 1;
  p8.tensor.dim[0] = n;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    push(p3);
    push(p9);
    push_integer(i);
    power();
    divide();
    push(p9);
    filter();
    p8.tensor.elem[i] = pop();
  }
  return p3 = p8;
};

expand_get_A = function() {
  var ad, h, i, n, ref1;
  h = 0;
  i = 0;
  n = 0;
  if (!istensor(p4)) {
    push(p2);
    reciprocate();
    p2 = pop();
    return;
  }
  h = tos;
  if (car(p2) === symbol(MULTIPLY)) {
    p8 = cdr(p2);
    while (iscons(p8)) {
      p5 = car(p8);
      expand_get_AF();
      p8 = cdr(p8);
    }
  } else {
    p5 = p2;
    expand_get_AF();
  }
  n = tos - h;
  p8 = alloc_tensor(n);
  p8.tensor.ndim = 1;
  p8.tensor.dim[0] = n;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    p8.tensor.elem[i] = stack[h + i];
  }
  tos = h;
  return p2 = p8;
};

expand_get_AF = function() {
  var ad, d, i, j, n, ref1, results;
  d = 0;
  i = 0;
  j = 0;
  n = 1;
  if (!Find(p5, p9)) {
    return;
  }
  if (car(p5) === symbol(POWER)) {
    push(caddr(p5));
    n = pop_integer();
    p5 = cadr(p5);
  }
  push(p5);
  push(p9);
  degree();
  d = pop_integer();
  results = [];
  for (i = ad = ref1 = n; ref1 <= 0 ? ad < 0 : ad > 0; i = ref1 <= 0 ? ++ad : --ad) {
    results.push((function() {
      var ae, ref2, results1;
      results1 = [];
      for (j = ae = 0, ref2 = d; 0 <= ref2 ? ae < ref2 : ae > ref2; j = 0 <= ref2 ? ++ae : --ae) {
        push(p5);
        push_integer(i);
        power();
        reciprocate();
        push(p9);
        push_integer(j);
        power();
        results1.push(multiply());
      }
      return results1;
    })());
  }
  return results;
};

test_expand = function() {
  return run_test(["expand(1/(x+1)/(x+2))", "1/(x+1)-1/(x+2)", "expand((2x^3-x+2)/(x^2-2x+1))", "4+2*x+5/(x-1)+3/(x^2-2*x+1)", "expand(1/x^2/(x-1))", "-1/(x^2)-1/x+1/(x-1)", "p=5s+2", "", "q=(s+1)(s+2)^2", "", "expand(p/q)", "-3/(s+1)+3/(s+2)+8/(s^2+4*s+4)", "q=(x-1)(x-2)^3", "", "expand(1/q)", "1/(x^3-6*x^2+12*x-8)+1/(x-2)-1/(x-1)-1/(x^2-4*x+4)", "expand(1/(x+1/2)/(x+1/3))", "-12/(2*x+1)+18/(3*x+1)", "f=1/(x+1)/(x+2)", "", "g=1/(x+1)-1/(x+2)", "", "expand(((f,f),(f,f)))-((g,g),(g,g))", "((0,0),(0,0))", "expand(1/(1+1/x))", "1-1/(x+1)", "expand(1/x/(x+1))", "1/x-1/(x+1)", "expand(1/x^2/(x+1))", "x^(-2)-1/x+1/(x+1)", "expand(1/x)", "1/x", "expand(1/x^2)", "x^(-2)", "expand(1/(x^2-4x+4))", "1/(x^2-4*x+4)"]);
};

Eval_expcos = function() {
  push(cadr(p1));
  Eval();
  return expcos();
};

expcos = function() {
  save();
  p1 = pop();
  push(imaginaryunit);
  push(p1);
  multiply();
  exponential();
  push_rational(1, 2);
  multiply();
  push(imaginaryunit);
  negate();
  push(p1);
  multiply();
  exponential();
  push_rational(1, 2);
  multiply();
  add();
  return restore();
};

test_expcos = function() {
  return run_test(["expcos(x)", "1/2*exp(-i*x)+1/2*exp(i*x)"]);
};

Eval_expsin = function() {
  push(cadr(p1));
  Eval();
  return expsin();
};

expsin = function() {
  save();
  p1 = pop();
  push(imaginaryunit);
  push(p1);
  multiply();
  exponential();
  push(imaginaryunit);
  divide();
  push_rational(1, 2);
  multiply();
  push(imaginaryunit);
  negate();
  push(p1);
  multiply();
  exponential();
  push(imaginaryunit);
  divide();
  push_rational(1, 2);
  multiply();
  subtract();
  return restore();
};

test_expsin = function() {
  return run_test(["expsin(x)", "1/2*i*exp(-i*x)-1/2*i*exp(i*x)"]);
};

Eval_factor = function() {
  var results;
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    guess();
  } else {
    push(p2);
  }
  factor();
  p1 = cdddr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    factor_again();
    results.push(p1 = cdr(p1));
  }
  return results;
};

factor_again = function() {
  var h, n;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      factor_term();
      p1 = cdr(p1);
    }
  } else {
    push(p1);
    push(p2);
    factor_term();
  }
  n = tos - h;
  if (n > 1) {
    multiply_all_noexpand(n);
  }
  return restore();
};

factor_term = function() {
  save();
  factorpoly();
  p1 = pop();
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
    }
  } else {
    push(p1);
  }
  return restore();
};

factor = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (isinteger(p1)) {
    push(p1);
    factor_number();
  } else {
    push(p1);
    push(p2);
    factorpoly();
  }
  return restore();
};

factor_small_number = function() {
  var ad, d, expo, i, n, ref1;
  i = 0;
  save();
  n = pop_integer();
  if (n === 0x80000000) {
    stop("number too big to factor");
  }
  if (n < 0) {
    n = -n;
  }
  for (i = ad = 0, ref1 = MAXPRIMETAB; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    d = primetab[i];
    if (d > n / d) {
      break;
    }
    expo = 0;
    while (n % d === 0) {
      n /= d;
      expo++;
    }
    if (expo) {
      push_integer(d);
      push_integer(expo);
    }
  }
  if (n > 1) {
    push_integer(n);
    push_integer(1);
  }
  return restore();
};

test_factor_number = function() {
  return run_test(["factor(0)", "0", "factor(1)", "1", "factor(2)", "2", "factor(3)", "3", "factor(4)", "2^2", "factor(5)", "5", "factor(6)", "2*3", "factor(7)", "7", "factor(8)", "2^3", "factor(9)", "3^2", "factor(10)", "2*5", "factor(100!)", "2^97*3^48*5^24*7^16*11^9*13^7*17^5*19^5*23^4*29^3*31^3*37^2*41^2*43^2*47^2*53*59*61*67*71*73*79*83*89*97", "factor(2*(2^30-35))", "2*1073741789", "a=104729", "", "factor(2*(a^2+6))", "2*10968163447", "factor((a^2+6)^2)", "10968163447*10968163447", "factor((a^2+6)*(a^2+60))", "10968163501*10968163447", "f=(x+1)(x+2)(y+3)(y+4)", "", "factor(f,x,y)", "(x+1)*(x+2)*(y+3)*(y+4)", "factor(f,y,x)", "(x+1)*(x+2)*(y+3)*(y+4)", "f=(x+1)(x+1)(y+2)(y+2)", "", "factor(f,x,y)", "(x+1)^2*(y+2)^2", "factor(f,y,x)", "(x+1)^2*(y+2)^2"]);
};

factorial = function() {
  var n;
  n = 0;
  save();
  p1 = pop();
  push(p1);
  n = pop_integer();
  if (n < 0 || n === 0x80000000) {
    push_symbol(FACTORIAL);
    push(p1);
    list(2);
    restore();
    return;
  }
  bignum_factorial(n);
  return restore();
};

simplifyfactorials = function() {
  var x;
  x = 0;
  save();
  x = expanding;
  expanding = 0;
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    push(zero);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      simplifyfactorials();
      add();
      p1 = cdr(p1);
    }
    expanding = x;
    restore();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    sfac_product();
    expanding = x;
    restore();
    return;
  }
  push(p1);
  expanding = x;
  return restore();
};

sfac_product = function() {
  var ad, ae, af, i, j, n, ref1, ref2, ref3, ref4;
  i = 0;
  j = 0;
  n = 0;
  s = tos;
  p1 = cdr(p1);
  n = 0;
  while (iscons(p1)) {
    push(car(p1));
    p1 = cdr(p1);
    n++;
  }
  for (i = ad = 0, ref1 = n - 1; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    if (stack[s + i] === symbol(NIL)) {
      continue;
    }
    for (j = ae = ref2 = i + 1, ref3 = n; ref2 <= ref3 ? ae < ref3 : ae > ref3; j = ref2 <= ref3 ? ++ae : --ae) {
      if (stack[s + j] === symbol(NIL)) {
        continue;
      }
      sfac_product_f(s, i, j);
    }
  }
  push(one);
  for (i = af = 0, ref4 = n; 0 <= ref4 ? af < ref4 : af > ref4; i = 0 <= ref4 ? ++af : --af) {
    if (stack[s + i] === symbol(NIL)) {
      continue;
    }
    push(stack[s + i]);
    multiply();
  }
  p1 = pop();
  tos -= n;
  return push(p1);
};

sfac_product_f = function(s, a, b) {
  var ad, i, n, ref1;
  i = 0;
  n = 0;
  p1 = stack[s + a];
  p2 = stack[s + b];
  if (ispower(p1)) {
    p3 = caddr(p1);
    p1 = cadr(p1);
  } else {
    p3 = one;
  }
  if (ispower(p2)) {
    p4 = caddr(p2);
    p2 = cadr(p2);
  } else {
    p4 = one;
  }
  if (isfactorial(p1) && isfactorial(p2)) {
    push(p3);
    push(p4);
    add();
    yyexpand();
    n = pop_integer();
    if (n !== 0) {
      return;
    }
    push(cadr(p1));
    push(cadr(p2));
    subtract();
    yyexpand();
    n = pop_integer();
    if (n === 0 || n === 0x80000000) {
      return;
    }
    if (n < 0) {
      n = -n;
      p5 = p1;
      p1 = p2;
      p2 = p5;
      p5 = p3;
      p3 = p4;
      p4 = p5;
    }
    push(one);
    for (i = ad = 1, ref1 = n; 1 <= ref1 ? ad <= ref1 : ad >= ref1; i = 1 <= ref1 ? ++ad : --ad) {
      push(cadr(p2));
      push_integer(i);
      add();
      push(p3);
      power();
      multiply();
    }
    stack[s + a] = pop();
    return stack[s + b] = symbol(NIL);
  }
};

polycoeff = 0;

factpoly_expo = 0;

factorpoly = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (!Find(p1, p2)) {
    push(p1);
    restore();
    return;
  }
  if (!ispoly(p1, p2)) {
    push(p1);
    restore();
    return;
  }
  if (!issymbol(p2)) {
    push(p1);
    restore();
    return;
  }
  push(p1);
  push(p2);
  yyfactorpoly();
  return restore();
};

yyfactorpoly = function() {
  var ad, h, i, ref1;
  h = 0;
  i = 0;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  if (isfloating(p1)) {
    stop("floating point numbers in polynomial");
  }
  polycoeff = tos;
  push(p1);
  push(p2);
  factpoly_expo = coeff() - 1;
  rationalize_coefficients(h);
  while (factpoly_expo > 0) {
    if (iszero(stack[polycoeff + 0])) {
      push_integer(1);
      p4 = pop();
      push_integer(0);
      p5 = pop();
    } else if (get_factor() === 0) {
      if (verbosing) {
        printf("no factor found\n");
      }
      break;
    }
    push(p4);
    push(p2);
    multiply();
    push(p5);
    add();
    p8 = pop();
    if (verbosing) {
      printf("success\nFACTOR=");
      print(p8);
      printf("\n");
    }

    /*
    		if (isnegativeterm(p4))
    			push(p8);
    			negate();
    			p8 = pop();
    			push(p7);
    			negate_noexpand();
    			p7 = pop();
     */
    push(p7);
    push(p8);
    multiply_noexpand();
    p7 = pop();
    yydivpoly();
    while (factpoly_expo && iszero(stack[polycoeff + factpoly_expo])) {
      factpoly_expo--;
    }
  }
  push(zero);
  for (i = ad = 0, ref1 = factpoly_expo; 0 <= ref1 ? ad <= ref1 : ad >= ref1; i = 0 <= ref1 ? ++ad : --ad) {
    push(stack[polycoeff + i]);
    push(p2);
    push_integer(i);
    power();
    multiply();
    add();
  }
  p1 = pop();
  if (verbosing) {
    printf("POLY=");
    print(p1);
    printf("\n");
  }
  if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {
    push(p1);
    negate();
    p1 = pop();
    push(p7);
    negate_noexpand();
    p7 = pop();
  }
  push(p7);
  push(p1);
  multiply_noexpand();
  p7 = pop();
  if (verbosing) {
    printf("RESULT=");
    print(p7);
    printf("\n");
  }
  stack[h] = p7;
  tos = h + 1;
  return restore();
};

rationalize_coefficients = function(h) {
  var ad, ae, i, ref1, ref2, ref3, ref4;
  i = 0;
  p7 = one;
  for (i = ad = ref1 = h, ref2 = tos; ref1 <= ref2 ? ad < ref2 : ad > ref2; i = ref1 <= ref2 ? ++ad : --ad) {
    push(stack[i]);
    denominator();
    push(p7);
    lcm();
    p7 = pop();
  }
  for (i = ae = ref3 = h, ref4 = tos; ref3 <= ref4 ? ae < ref4 : ae > ref4; i = ref3 <= ref4 ? ++ae : --ae) {
    push(p7);
    push(stack[i]);
    multiply();
    stack[i] = pop();
  }
  push(p7);
  reciprocate();
  p7 = pop();
  console.log("rationalize_coefficients result");
  return print1(p7);
};

get_factor = function() {
  var a0, ad, ae, af, ag, ah, an, h, i, j, na0, nan, ref1, ref2, ref3, ref4, ref5, rootsTries_i, rootsTries_j;
  i = 0;
  j = 0;
  h = 0;
  a0 = 0;
  an = 0;
  na0 = 0;
  nan = 0;
  if (verbosing) {
    push(zero);
    for (i = ad = 0, ref1 = factpoly_expo; 0 <= ref1 ? ad <= ref1 : ad >= ref1; i = 0 <= ref1 ? ++ad : --ad) {
      push(stack[polycoeff + i]);
      push(p2);
      push_integer(i);
      power();
      multiply();
      add();
    }
    p1 = pop();
    printf("POLY=");
    print(p1);
    printf("\n");
  }
  h = tos;
  an = tos;
  push(stack[polycoeff + factpoly_expo]);
  divisors_onstack();
  nan = tos - an;
  a0 = tos;
  push(stack[polycoeff + 0]);
  divisors_onstack();
  na0 = tos - a0;
  if (verbosing) {
    printf("divisors of base term");
    for (i = ae = 0, ref2 = na0; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      printf(", ");
      print(stack[a0 + i]);
    }
    printf("\n");
    printf("divisors of leading term");
    for (i = af = 0, ref3 = nan; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
      printf(", ");
      print(stack[an + i]);
    }
    printf("\n");
  }
  for (rootsTries_i = ag = 0, ref4 = nan; 0 <= ref4 ? ag < ref4 : ag > ref4; rootsTries_i = 0 <= ref4 ? ++ag : --ag) {
    for (rootsTries_j = ah = 0, ref5 = na0; 0 <= ref5 ? ah < ref5 : ah > ref5; rootsTries_j = 0 <= ref5 ? ++ah : --ah) {
      p4 = stack[an + rootsTries_i];
      p5 = stack[a0 + rootsTries_j];
      push(p5);
      push(p4);
      divide();
      negate();
      p3 = pop();
      Evalpoly();
      if (verbosing) {
        printf("try A=");
        print(p4);
        printf(", B=");
        print(p5);
        printf(", root ");
        print(p2);
        printf("=-B/A=");
        print(p3);
        printf(", POLY(");
        print(p3);
        printf(")=");
        print(p6);
        printf("\n");
      }
      if (iszero(p6)) {
        tos = h;
        console.log("get_factor returning 1");
        return 1;
      }
      push(p5);
      negate();
      p5 = pop();
      push(p3);
      negate();
      p3 = pop();
      Evalpoly();
      if (verbosing) {
        printf("try A=");
        print(p4);
        printf(", B=");
        print(p5);
        printf(", root ");
        print(p2);
        printf("=-B/A=");
        print(p3);
        printf(", POLY(");
        print(p3);
        printf(")=");
        print(p6);
        printf("\n");
      }
      if (iszero(p6)) {
        tos = h;
        console.log("get_factor returning 1");
        return 1;
      }
    }
  }
  tos = h;
  console.log("get_factor returning 0");
  return 0;
};

yydivpoly = function() {
  var ad, i, ref1;
  i = 0;
  p6 = zero;
  for (i = ad = ref1 = factpoly_expo; ref1 <= 0 ? ad < 0 : ad > 0; i = ref1 <= 0 ? ++ad : --ad) {
    push(stack[polycoeff + i]);
    stack[polycoeff + i] = p6;
    push(p4);
    divide();
    p6 = pop();
    push(stack[polycoeff + i - 1]);
    push(p6);
    push(p5);
    multiply();
    subtract();
    stack[polycoeff + i - 1] = pop();
  }
  stack[polycoeff + 0] = p6;
  console.log("yydivpoly Q:");
  return print1(p6);
};

Evalpoly = function() {
  var ad, i, ref1;
  i = 0;
  push(zero);
  for (i = ad = ref1 = factpoly_expo; ref1 <= 0 ? ad <= 0 : ad >= 0; i = ref1 <= 0 ? ++ad : --ad) {
    push(p3);
    multiply();
    push(stack[polycoeff + i]);
    console.log("Evalpoly top of stack:");
    print1(stack[tos - i]);
    add();
  }
  return p6 = pop();
};

test_factorpoly = function() {
  return run_test(["bake=0", "", "factor((x+1)*(x+2)*(x+3),x)", "(1+x)*(2+x)*(3+x)", "factor((x+a)*(x^2+x+1),x)", "(1+x+x^2)*(a+x)", "factor(x*(x+1)*(x+2),x)", "x*(1+x)*(2+x)", "factor((-2*x+3)*(x+4),x)", "-(-3+2*x)*(4+x)", "(-2*x+3)*(x+4)+(-3+2*x)*(4+x)", "0", "factor((x+1)*(-x^2+x+1),x)", "-(-1-x+x^2)*(1+x)", "factor((x+1/2)*(+x+1/3)*(+x+1/4),x)", "1/24*(1+2*x)*(1+3*x)*(1+4*x)", "(x+1/2)*(+x+1/3)*(+x+1/4)-1/24*(1+2*x)*(1+3*x)*(1+4*x)", "0", "factor((x+1/2)*(+x+1/3)*(+x-1/4),x)", "1/24*(-1+4*x)*(1+2*x)*(1+3*x)", "(x+1/2)*(+x+1/3)*(+x-1/4)-1/24*(-1+4*x)*(1+2*x)*(1+3*x)", "0", "factor((x+1/2)*(+x+1/3)*(-x+1/4),x)", "-1/24*(-1+4*x)*(1+2*x)*(1+3*x)", "(x+1/2)*(+x+1/3)*(-x+1/4)+1/24*(-1+4*x)*(1+2*x)*(1+3*x)", "0", "factor((x+1/2)*(+x+1/3)*(-x-1/4),x)", "-1/24*(1+2*x)*(1+3*x)*(1+4*x)", "(x+1/2)*(+x+1/3)*(-x-1/4)+1/24*(1+2*x)*(1+3*x)*(1+4*x)", "0", "factor((x+1/2)*(+x-1/3)*(+x+1/4),x)", "1/24*(-1+3*x)*(1+2*x)*(1+4*x)", "(x+1/2)*(+x-1/3)*(+x+1/4)-1/24*(-1+3*x)*(1+2*x)*(1+4*x)", "0", "factor((x+1/2)*(+x-1/3)*(+x-1/4),x)", "1/24*(-1+3*x)*(-1+4*x)*(1+2*x)", "(x+1/2)*(+x-1/3)*(+x-1/4)-1/24*(-1+3*x)*(-1+4*x)*(1+2*x)", "0", "factor((x+1/2)*(+x-1/3)*(-x+1/4),x)", "-1/24*(-1+3*x)*(-1+4*x)*(1+2*x)", "(x+1/2)*(+x-1/3)*(-x+1/4)+1/24*(-1+3*x)*(-1+4*x)*(1+2*x)", "0", "factor((x+1/2)*(+x-1/3)*(-x-1/4),x)", "-1/24*(-1+3*x)*(1+2*x)*(1+4*x)", "(x+1/2)*(+x-1/3)*(-x-1/4)+1/24*(-1+3*x)*(1+2*x)*(1+4*x)", "0", "factor((x+1/2)*(-x+1/3)*(+x+1/4),x)", "-1/24*(-1+3*x)*(1+2*x)*(1+4*x)", "(x+1/2)*(-x+1/3)*(+x+1/4)+1/24*(-1+3*x)*(1+2*x)*(1+4*x)", "0", "factor((x+1/2)*(-x+1/3)*(+x-1/4),x)", "-1/24*(-1+3*x)*(-1+4*x)*(1+2*x)", "(x+1/2)*(-x+1/3)*(+x-1/4)+1/24*(-1+3*x)*(-1+4*x)*(1+2*x)", "0", "factor((x+1/2)*(-x+1/3)*(-x+1/4),x)", "1/24*(-1+3*x)*(-1+4*x)*(1+2*x)", "(x+1/2)*(-x+1/3)*(-x+1/4)-1/24*(-1+3*x)*(-1+4*x)*(1+2*x)", "0", "factor((x+1/2)*(-x+1/3)*(-x-1/4),x)", "1/24*(-1+3*x)*(1+2*x)*(1+4*x)", "(x+1/2)*(-x+1/3)*(-x-1/4)-1/24*(-1+3*x)*(1+2*x)*(1+4*x)", "0", "factor((x+1/2)*(-x-1/3)*(+x+1/4),x)", "-1/24*(1+2*x)*(1+3*x)*(1+4*x)", "(x+1/2)*(-x-1/3)*(+x+1/4)+1/24*(1+2*x)*(1+3*x)*(1+4*x)", "0", "factor((x+1/2)*(-x-1/3)*(+x-1/4),x)", "-1/24*(-1+4*x)*(1+2*x)*(1+3*x)", "(x+1/2)*(-x-1/3)*(+x-1/4)+1/24*(-1+4*x)*(1+2*x)*(1+3*x)", "0", "factor((x+1/2)*(-x-1/3)*(-x+1/4),x)", "1/24*(-1+4*x)*(1+2*x)*(1+3*x)", "(x+1/2)*(-x-1/3)*(-x+1/4)-1/24*(-1+4*x)*(1+2*x)*(1+3*x)", "0", "factor((x+1/2)*(-x-1/3)*(-x-1/4),x)", "1/24*(1+2*x)*(1+3*x)*(1+4*x)", "(x+1/2)*(-x-1/3)*(-x-1/4)-1/24*(1+2*x)*(1+3*x)*(1+4*x)", "0", "factor((+x+a)*(+x+b)*(+x+c),x)", "(a+x)*(b+x)*(c+x)", "(a+x)*(b+x)*(c+x)-(a+x)*(b+x)*(c+x)", "0", "factor((+x+a)*(+x+b)*(+x-c),x)", "(a+x)*(b+x)*(-c+x)", "(+x+a)*(+x+b)*(+x-c)-(a+x)*(b+x)*(-c+x)", "0", "factor((+x+a)*(+x+b)*(-x+c),x)", "-(a+x)*(b+x)*(-c+x)", "(+x+a)*(+x+b)*(-x+c)+(a+x)*(b+x)*(-c+x)", "0", "factor((+x+a)*(+x+b)*(-x-c),x)", "-(a+x)*(b+x)*(c+x)", "(+x+a)*(+x+b)*(-x-c)+(a+x)*(b+x)*(c+x)", "0", "factor((+a*x+b)*(+c*x+d),x)", "(b+a*x)*(d+c*x)", "(+a*x+b)*(+c*x+d)-(b+a*x)*(d+c*x)", "0", "factor((+a*x+b)*(+c*x-d),x)", "(b+a*x)*(-d+c*x)", "(+a*x+b)*(+c*x-d)-(b+a*x)*(-d+c*x)", "0", "factor((+a*x+b)*(-c*x+d),x)", "-(b+a*x)*(-d+c*x)", "(+a*x+b)*(-c*x+d)+(b+a*x)*(-d+c*x)", "0", "factor((+a*x+b)*(-c*x-d),x)", "-(b+a*x)*(d+c*x)", "(+a*x+b)*(-c*x-d)+(b+a*x)*(d+c*x)", "0", "factor((+a*x-b)*(+c*x+d),x)", "(d+c*x)*(-b+a*x)", "(+a*x-b)*(+c*x+d)-(d+c*x)*(-b+a*x)", "0", "factor((+a*x-b)*(+c*x-d),x)", "(-b+a*x)*(-d+c*x)", "(+a*x-b)*(+c*x-d)-(-b+a*x)*(-d+c*x)", "0", "factor((+a*x-b)*(-c*x+d),x)", "-(-b+a*x)*(-d+c*x)", "(+a*x-b)*(-c*x+d)+(-b+a*x)*(-d+c*x)", "0", "factor((+a*x-b)*(-c*x-d),x)", "-(d+c*x)*(-b+a*x)", "(+a*x-b)*(-c*x-d)+(d+c*x)*(-b+a*x)", "0", "factor((-a*x+b)*(+c*x+d),x)", "-(d+c*x)*(-b+a*x)", "(-a*x+b)*(+c*x+d)+(d+c*x)*(-b+a*x)", "0", "factor((-a*x+b)*(+c*x-d),x)", "-(-b+a*x)*(-d+c*x)", "(-a*x+b)*(+c*x-d)+(-b+a*x)*(-d+c*x)", "0", "factor((-a*x+b)*(-c*x+d),x)", "(-b+a*x)*(-d+c*x)", "(-a*x+b)*(-c*x+d)-(-b+a*x)*(-d+c*x)", "0", "factor((-a*x+b)*(-c*x-d),x)", "(d+c*x)*(-b+a*x)", "(-a*x+b)*(-c*x-d)-(d+c*x)*(-b+a*x)", "0", "factor((-a*x-b)*(+c*x+d),x)", "-(b+a*x)*(d+c*x)", "(-a*x-b)*(+c*x+d)+(b+a*x)*(d+c*x)", "0", "factor((-a*x-b)*(+c*x-d),x)", "-(b+a*x)*(-d+c*x)", "(-a*x-b)*(+c*x-d)+(b+a*x)*(-d+c*x)", "0", "factor((-a*x-b)*(-c*x+d),x)", "(b+a*x)*(-d+c*x)", "(-a*x-b)*(-c*x+d)-(b+a*x)*(-d+c*x)", "0", "factor((-a*x-b)*(-c*x-d),x)", "(b+a*x)*(d+c*x)", "(-a*x-b)*(-c*x-d)-(b+a*x)*(d+c*x)", "0", "factor(x,x)", "x", "factor(x^2,x)", "x^2", "factor(x^3,x)", "x^3", "bake=1", "", "y=(x+1)(x+2)", "", "factor(y,z)", "x^2+3*x+2", "factor(y,y)", "x^2+3*x+2", "y=x^2+exp(x)", "", "factor(y)", "x^2+exp(x)"]);
};

factors = function(p) {
  var h;
  h = tos;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    while (iscons(p)) {
      push_term_factors(car(p));
      p = cdr(p);
    }
  } else {
    push_term_factors(p);
  }
  return tos - h;
};

push_term_factors = function(p) {
  var results;
  if (car(p) === symbol(MULTIPLY)) {
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      push(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return push(p);
  }
};


/*
Remove terms that involve a given symbol or expression. For example...

	filter(x^2 + x + 1, x)		=>	1

	filter(x^2 + x + 1, x^2)	=>	x + 1
 */

Eval_filter = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    filter();
    results.push(p1 = cdr(p1));
  }
  return results;
};


/*
 For example...

	push(F)
	push(X)
	filter()
	F = pop()
 */

filter = function() {
  save();
  p2 = pop();
  p1 = pop();
  filter_main();
  return restore();
};

filter_main = function() {
  if (car(p1) === symbol(ADD)) {
    return filter_sum();
  } else if (istensor(p1)) {
    return filter_tensor();
  } else if (Find(p1, p2)) {
    return push_integer(0);
  } else {
    return push(p1);
  }
};

filter_sum = function() {
  var results;
  push_integer(0);
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    push(p2);
    filter();
    add();
    results.push(p1 = cdr(p1));
  }
  return results;
};

filter_tensor = function() {
  var ad, ae, i, n, ref1, ref2;
  i = 0;
  n = 0;
  n = p1.tensor.nelem;
  p3 = alloc_tensor(n);
  p3.tensor.ndim = p1.tensor.ndim;
  for (i = ad = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    push(p1.tensor.elem[i]);
    push(p2);
    filter();
    p3.tensor.elem[i] = pop();
  }
  return push(p3);
};

Find = function(p, q) {
  var ad, i, ref1;
  i = 0;
  if (equal(p, q)) {
    return 1;
  }
  if (istensor(p)) {
    for (i = ad = 0, ref1 = p.tensor.nelem; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
      if (Find(p.tensor.elem[i], q)) {
        return 1;
      }
    }
    return 0;
  }
  while (iscons(p)) {
    if (Find(car(p), q)) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

Eval_float = function() {
  push(cadr(p1));
  Eval();
  yyfloat();
  return Eval();
};

yyfloat = function() {
  var ad, h, i, ref1;
  i = 0;
  h = 0;
  save();
  p1 = pop();
  if (iscons(p1)) {
    h = tos;
    while (iscons(p1)) {
      push(car(p1));
      yyfloat();
      p1 = cdr(p1);
    }
    list(tos - h);
  } else if (p1.k === TENSOR) {
    push(p1);
    copy_tensor();
    p1 = pop();
    for (i = ad = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
      push(p1.tensor.elem[i]);
      yyfloat();
      p1.tensor.elem[i] = pop();
    }
    push(p1);
  } else if (p1.k === NUM) {
    push(p1);
    bignum_float();
  } else if (p1 === symbol(PI)) {
    push_double(Math.PI);
  } else if (p1 === symbol(E)) {
    push_double(Math.E);
  } else {
    push(p1);
  }
  return restore();
};

test_float = function() {
  return run_test(["float(x)", "x", "float(1/2)", "0.5", "float(pi)", "3.14159", "float(exp(1))", "2.71828", "x=(1/2,1/4)", "", "float(x)", "(0.5,0.25)", "x", "(1/2,1/4)", "x=quote(x)", ""]);
};

Eval_floor = function() {
  push(cadr(p1));
  Eval();
  return yfloor();
};

yfloor = function() {
  save();
  yyfloor();
  return restore();
};

yyfloor = function() {
  var d;
  d = 0.0;
  p1 = pop();
  if (!isnum(p1)) {
    push_symbol(FLOOR);
    push(p1);
    list(2);
    return;
  }
  if (isdouble(p1)) {
    d = Math.floor(p1.d);
    push_double(d);
    return;
  }
  if (isinteger(p1)) {
    push(p1);
    return;
  }
  p3 = new U();
  p3.k = NUM;
  p3.q.a = mdiv(p1.q.a, p1.q.b);
  p3.q.b = mint(1);
  push(p3);
  if (isnegativenumber(p1)) {
    push_integer(-1);
    return add();
  }
};

test_floor = function() {
  return run_test(["floor(a)", "floor(a)", "floor(a+b)", "floor(a+b)", "floor(5/2)", "2", "floor(4/2)", "2", "floor(3/2)", "1", "floor(2/2)", "1", "floor(1/2)", "0", "floor(0/2)", "0", "floor(-1/2)", "-1", "floor(-2/2)", "-1", "floor(-3/2)", "-2", "floor(-4/2)", "-2", "floor(-5/2)", "-3", "floor(5/2.0)", "2", "floor(4/2.0)", "2", "floor(3/2.0)", "1", "floor(2/2.0)", "1", "floor(1/2.0)", "0", "floor(0.0)", "0", "floor(-1/2.0)", "-1", "floor(-2/2.0)", "-1", "floor(-3/2.0)", "-2", "floor(-4/2.0)", "-2", "floor(-5/2.0)", "-3"]);
};

Eval_gamma = function() {
  push(cadr(p1));
  Eval();
  return gamma();
};

gamma = function() {
  save();
  gammaf();
  return restore();
};

gammaf = function() {
  p1 = pop();
  if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {
    push_symbol(PI);
    push_rational(1, 2);
    power();
    return;
  }
  if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {
    push_symbol(PI);
    push_rational(1, 2);
    power();
    push_rational(1, 2);
    multiply();
    return;
  }
  if (isnegativeterm(p1)) {
    push_symbol(PI);
    push_integer(-1);
    multiply();
    push_symbol(PI);
    push(p1);
    multiply();
    sine();
    push(p1);
    multiply();
    push(p1);
    negate();
    gamma();
    multiply();
    divide();
    return;
  }
  if (car(p1) === symbol(ADD)) {
    gamma_of_sum();
    return;
  }
  push_symbol(GAMMA);
  push(p1);
  list(2);
};

gamma_of_sum = function() {
  p3 = cdr(p1);
  if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {
    push(cadr(p3));
    push(cadr(p3));
    gamma();
    return multiply();
  } else {
    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {
      push(cadr(p3));
      gamma();
      push(cadr(p3));
      push_integer(-1);
      add();
      return divide();
    } else {
      push_symbol(GAMMA);
      push(p1);
      list(2);
    }
  }
};

test_gamma = function() {
  return run_test(["Gamma(a)", "Gamma(a)", "Gamma(x+1)", "x*Gamma(x)", "Gamma(1/2)", "pi^(1/2)", "Gamma(x-1)-Gamma(x)/(-1+x)", "0", "Gamma(-x)", "-pi/(x*Gamma(x)*sin(pi*x))"]);
};

Eval_gcd = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    gcd();
    results.push(p1 = cdr(p1));
  }
  return results;
};

gcd = function() {
  var x;
  x = expanding;
  save();
  gcd_main();
  restore();
  return expanding = x;
};

gcd_main = function() {
  expanding = 1;
  p2 = pop();
  p1 = pop();
  if (equal(p1, p2)) {
    push(p1);
    return;
  }
  if (isrational(p1) && isrational(p2)) {
    push(p1);
    push(p2);
    gcd_numbers();
    return;
  }
  if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {
    gcd_expr_expr();
    return;
  }
  if (car(p1) === symbol(ADD)) {
    gcd_expr(p1);
    p1 = pop();
  }
  if (car(p2) === symbol(ADD)) {
    gcd_expr(p2);
    p2 = pop();
  }
  if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {
    gcd_term_term();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    gcd_term_factor();
    return;
  }
  if (car(p2) === symbol(MULTIPLY)) {
    gcd_factor_term();
    return;
  }
  if (car(p1) === symbol(POWER)) {
    p3 = caddr(p1);
    p1 = cadr(p1);
  } else {
    p3 = one;
  }
  if (car(p2) === symbol(POWER)) {
    p4 = caddr(p2);
    p2 = cadr(p2);
  } else {
    p4 = one;
  }
  if (!equal(p1, p2)) {
    push(one);
    return;
  }
  if (isnum(p3) && isnum(p4)) {
    push(p1);
    if (lessp(p3, p4)) {
      push(p3);
    } else {
      push(p4);
    }
    power();
    return;
  }
  push(p3);
  push(p4);
  divide();
  p5 = pop();
  if (isnum(p5)) {
    push(p1);
    if (car(p3) === symbol(MULTIPLY) && isnum(cadr(p3))) {
      p5 = cadr(p3);
    } else {
      p5 = one;
    }
    if (car(p4) === symbol(MULTIPLY) && isnum(cadr(p4))) {
      p6 = cadr(p4);
    } else {
      p6 = one;
    }
    if (lessp(p5, p6)) {
      push(p3);
    } else {
      push(p4);
    }
    power();
    return;
  }
  push(p3);
  push(p4);
  subtract();
  p5 = pop();
  if (!isnum(p5)) {
    push(one);
    return;
  }
  push(p1);
  if (isnegativenumber(p5)) {
    push(p3);
  } else {
    push(p4);
  }
  return power();
};

gcd_expr_expr = function() {
  if (length(p1) !== length(p2)) {
    push(one);
    return;
  }
  p3 = cdr(p1);
  push(car(p3));
  p3 = cdr(p3);
  while (iscons(p3)) {
    push(car(p3));
    gcd();
    p3 = cdr(p3);
  }
  p3 = pop();
  p4 = cdr(p2);
  push(car(p4));
  p4 = cdr(p4);
  while (iscons(p4)) {
    push(car(p4));
    gcd();
    p4 = cdr(p4);
  }
  p4 = pop();
  push(p1);
  push(p3);
  divide();
  p5 = pop();
  push(p2);
  push(p4);
  divide();
  p6 = pop();
  if (equal(p5, p6)) {
    push(p5);
    push(p3);
    push(p4);
    gcd();
    return multiply();
  } else {
    return push(one);
  }
};

gcd_expr = function(p) {
  var results;
  p = cdr(p);
  push(car(p));
  p = cdr(p);
  results = [];
  while (iscons(p)) {
    push(car(p));
    gcd();
    results.push(p = cdr(p));
  }
  return results;
};

gcd_term_term = function() {
  var results;
  push(one);
  p3 = cdr(p1);
  results = [];
  while (iscons(p3)) {
    p4 = cdr(p2);
    while (iscons(p4)) {
      push(car(p3));
      push(car(p4));
      gcd();
      multiply();
      p4 = cdr(p4);
    }
    results.push(p3 = cdr(p3));
  }
  return results;
};

gcd_term_factor = function() {
  var results;
  push(one);
  p3 = cdr(p1);
  results = [];
  while (iscons(p3)) {
    push(car(p3));
    push(p2);
    gcd();
    multiply();
    results.push(p3 = cdr(p3));
  }
  return results;
};

gcd_factor_term = function() {
  var results;
  push(one);
  p4 = cdr(p2);
  results = [];
  while (iscons(p4)) {
    push(p1);
    push(car(p4));
    gcd();
    multiply();
    results.push(p4 = cdr(p4));
  }
  return results;
};

test_gcd = function() {
  return run_test(["gcd(30,42)", "6", "gcd(42,30)", "6", "gcd(-30,42)", "6", "gcd(42,-30)", "6", "gcd(30,-42)", "6", "gcd(-42,30)", "6", "gcd(-30,-42)", "6", "gcd(-42,-30)", "6", "gcd(x,x)", "x", "gcd(-x,x)", "x", "gcd(x,-x)", "x", "gcd(-x,-x)", "-x", "gcd(x^2,x^3)", "x^2", "gcd(x,y)", "1", "gcd(y,x)", "1", "gcd(x*y,y)", "y", "gcd(x*y,y^2)", "y", "gcd(x^2*y^2,x^3*y^3)", "x^2*y^2", "gcd(x^2,x^3)", "x^2", "gcd(x+y,x+z)", "1", "gcd(x+y,x+y)", "x+y", "gcd(x+y,2*x+2*y)", "x+y", "gcd(-x-y,x+y)", "x+y", "gcd(4*x+4*y,6*x+6*y)", "2*x+2*y", "gcd(4*x+4*y+4,6*x+6*y+6)", "2+2*x+2*y", "gcd(4*x+4*y+4,6*x+6*y+12)", "1", "gcd(27*t^3+y^3+9*t*y^2+27*t^2*y,t+y)", "1", "gcd(2*a^2*x^2+a*x+a*b,a)", "a", "gcd(2*a^2*x^2+a*x+a*b,a^2)", "a", "gcd(2*a^2*x^2+2*a*x+2*a*b,a)", "a", "gcd(2*a^2*x^2+2*a*x+2*a*b,2*a)", "2*a", "gcd(2*a^2*x^2+2*a*x+2*a*b,3*a)", "a", "gcd(2*a^2*x^2+2*a*x+2*a*b,4*a)", "2*a", "gcd(x,x^2)", "x", "gcd(x,x^a)", "1", "gcd(12,18,9)", "3"]);
};

guess = function() {
  var p;
  p = pop();
  push(p);
  if (Find(p, symbol(SYMBOL_X))) {
    return push_symbol(SYMBOL_X);
  } else if (Find(p, symbol(SYMBOL_Y))) {
    return push_symbol(SYMBOL_Y);
  } else if (Find(p, symbol(SYMBOL_Z))) {
    return push_symbol(SYMBOL_Z);
  } else if (Find(p, symbol(SYMBOL_T))) {
    return push_symbol(SYMBOL_T);
  } else if (Find(p, symbol(SYMBOL_S))) {
    return push_symbol(SYMBOL_S);
  } else {
    return push_symbol(SYMBOL_X);
  }
};

hermite = function() {
  save();
  yyhermite();
  return restore();
};

yyhermite = function() {
  var n;
  n = 0;
  p2 = pop();
  p1 = pop();
  push(p2);
  n = pop_integer();
  if (n < 0 || n === 0x80000000) {
    push_symbol(HERMITE);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  if (issymbol(p1)) {
    return yyhermite2(n);
  } else {
    p3 = p1;
    p1 = symbol(SECRETX);
    yyhermite2(n);
    p1 = p3;
    push(symbol(SECRETX));
    push(p1);
    subst();
    return Eval();
  }
};

yyhermite2 = function(n) {
  var ad, i, ref1, results;
  i = 0;
  push_integer(1);
  push_integer(0);
  p4 = pop();
  results = [];
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    p5 = p4;
    p4 = pop();
    push(p1);
    push(p4);
    multiply();
    push_integer(i);
    push(p5);
    multiply();
    subtract();
    push_integer(2);
    results.push(multiply());
  }
  return results;
};

test_hermite = function() {
  return run_test(["hermite(x,n)", "hermite(x,n)", "hermite(x,0)-1", "0", "hermite(x,1)-2*x", "0", "hermite(x,2)-(4*x^2-2)", "0", "hermite(x,3)-(8*x^3-12*x)", "0", "hermite(x,4)-(16*x^4-48*x^2+12)", "0", "hermite(x,5)-(32*x^5-160*x^3+120*x)", "0", "hermite(x,6)-(64*x^6-480*x^4+720*x^2-120)", "0", "hermite(x,7)-(128*x^7-1344*x^5+3360*x^3-1680*x)", "0", "hermite(x,8)-(256*x^8-3584*x^6+13440*x^4-13440*x^2+1680)", "0", "hermite(x,9)-(512*x^9-9216*x^7+48384*x^5-80640*x^3+30240*x)", "0", "hermite(x,10)-(1024*x^10-23040*x^8+161280*x^6-403200*x^4+302400*x^2-30240)", "0", "hermite(a-b,10)-eval(subst(a-b,x,hermite(x,10)))", "0"]);
};

hilbert = function() {
  var ad, ae, i, j, n, ref1, ref2;
  i = 0;
  j = 0;
  n = 0;
  save();
  p2 = pop();
  push(p2);
  n = pop_integer();
  if (n < 2) {
    push_symbol(HILBERT);
    push(p2);
    list(2);
    restore();
    return;
  }
  push_zero_matrix(n, n);
  p1 = pop();
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    for (j = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; j = 0 <= ref2 ? ++ae : --ae) {
      push_integer(i + j + 1);
      inverse();
      p1.tensor.elem[i * n + j] = pop();
    }
  }
  push(p1);
  return restore();
};


/*
 Returns the coefficient of the imaginary part of complex z

	z		imag(z)
	-		-------

	a + i b		b

	exp(i a)	sin(a)
 */

Eval_imag = function() {
  push(cadr(p1));
  Eval();
  return imag();
};

imag = function() {
  save();
  rect();
  p1 = pop();
  push(p1);
  push(p1);
  conjugate();
  subtract();
  push_integer(2);
  divide();
  push(imaginaryunit);
  divide();
  return restore();
};

test_imag = function() {
  return run_test(["imag(a+i*b)", "b", "imag(1+exp(i*pi/3))", "1/2*3^(1/2)", "imag(i)", "1", "imag((-1)^(1/3))", "1/2*3^(1/2)", "imag(-i)", "-1"]);
};

index_function = function(n) {
  var ad, ae, af, ag, ah, i, k, m, ndim, nelem, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, t;
  i = 0;
  k = 0;
  m = 0;
  ndim = 0;
  nelem = 0;
  t = 0;
  save();
  s = tos - n;
  p1 = stack[s];
  if (!istensor(p1)) {
    tos -= n;
    push(p1);
    restore();
    return;
  }
  ndim = p1.tensor.ndim;
  m = n - 1;
  if (m > ndim) {
    stop("too many indices for tensor");
  }
  k = 0;
  for (i = ad = 0, ref1 = m; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    push(stack[s + i + 1]);
    t = pop_integer();
    if (t < 1 || t > p1.tensor.dim[i]) {
      stop("index out of range");
    }
    k = k * p1.tensor.dim[i] + t - 1;
  }
  if (ndim === m) {
    tos -= n;
    push(p1.tensor.elem[k]);
    restore();
    return;
  }
  for (i = ae = ref2 = m, ref3 = ndim; ref2 <= ref3 ? ae < ref3 : ae > ref3; i = ref2 <= ref3 ? ++ae : --ae) {
    k = k * p1.tensor.dim[i] + 0;
  }
  nelem = 1;
  for (i = af = ref4 = m, ref5 = ndim; ref4 <= ref5 ? af < ref5 : af > ref5; i = ref4 <= ref5 ? ++af : --af) {
    nelem *= p1.tensor.dim[i];
  }
  p2 = alloc_tensor(nelem);
  p2.tensor.ndim = ndim - m;
  for (i = ag = ref6 = m, ref7 = ndim; ref6 <= ref7 ? ag < ref7 : ag > ref7; i = ref6 <= ref7 ? ++ag : --ag) {
    p2.tensor.dim[i - m] = p1.tensor.dim[i];
  }
  for (i = ah = 0, ref8 = nelem; 0 <= ref8 ? ah < ref8 : ah > ref8; i = 0 <= ref8 ? ++ah : --ah) {
    p2.tensor.elem[i] = p1.tensor.elem[k + i];
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  tos -= n;
  push(p2);
  return restore();
};

set_component = function(n) {
  var ad, ae, af, ag, ah, aj, i, k, m, ndim, ref1, ref2, ref3, ref4, ref5, ref6, ref7, t;
  i = 0;
  k = 0;
  m = 0;
  ndim = 0;
  t = 0;
  save();
  if (n < 3) {
    stop("error in indexed assign");
  }
  s = tos - n;
  p2 = stack[s];
  p1 = stack[s + 1];
  if (!istensor(p1)) {
    stop("error in indexed assign");
  }
  ndim = p1.tensor.ndim;
  m = n - 2;
  if (m > ndim) {
    stop("error in indexed assign");
  }
  k = 0;
  for (i = ad = 0, ref1 = m; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    push(stack[s + i + 2]);
    t = pop_integer();
    if (t < 1 || t > p1.tensor.dim[i]) {
      stop("error in indexed assign\n");
    }
    k = k * p1.tensor.dim[i] + t - 1;
  }
  for (i = ae = ref2 = m, ref3 = ndim; ref2 <= ref3 ? ae < ref3 : ae > ref3; i = ref2 <= ref3 ? ++ae : --ae) {
    k = k * p1.tensor.dim[i] + 0;
  }
  p3 = alloc_tensor(p1.tensor.nelem);
  p3.tensor.ndim = p1.tensor.ndim;
  for (i = af = 0, ref4 = p1.tensor.ndim; 0 <= ref4 ? af < ref4 : af > ref4; i = 0 <= ref4 ? ++af : --af) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (i = ag = 0, ref5 = p1.tensor.nelem; 0 <= ref5 ? ag < ref5 : ag > ref5; i = 0 <= ref5 ? ++ag : --ag) {
    p3.tensor.elem[i] = p1.tensor.elem[i];
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p3.tensor.nelem !== p3.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  p1 = p3;
  if (ndim === m) {
    if (istensor(p2)) {
      stop("error in indexed assign");
    }
    p1.tensor.elem[k] = p2;
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    tos -= n;
    push(p1);
    restore();
    return;
  }
  if (!istensor(p2)) {
    stop("error in indexed assign");
  }
  if (ndim - m !== p2.tensor.ndim) {
    stop("error in indexed assign");
  }
  for (i = ah = 0, ref6 = p2.tensor.ndim; 0 <= ref6 ? ah < ref6 : ah > ref6; i = 0 <= ref6 ? ++ah : --ah) {
    if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {
      stop("error in indexed assign");
    }
  }
  for (i = aj = 0, ref7 = p2.tensor.nelem; 0 <= ref7 ? aj < ref7 : aj > ref7; i = 0 <= ref7 ? ++aj : --aj) {
    p1.tensor.elem[k + i] = p2.tensor.elem[i];
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  tos -= n;
  push(p1);
  return restore();
};

s = ["A=((A11,A12),(A21,A22))", "", "A[1,1]", "A11", "A[1,2]", "A12", "A[2,1]", "A21", "A[2,2]", "A22", "A[1]", "(A11,A12)", "A[2]", "(A21,A22)", "A[1]=(B11,B12)", "", "A", "((B11,B12),(A21,A22))", "A[2]=(B21,B22)", "", "A", "((B11,B12),(B21,B22))", "A=((0,0),(0,0))", "", "A[1,1]", "0", "1[2]", "1"];


/*
void
test_index(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

init = function() {
  var ad, ae, i, ref1, ref2;
  i = 0;
  flag = 0;
  tos = 0;
  esc_flag = 0;
  draw_flag = 0;
  frame = TOS;
  if (flag) {
    return;
  }
  flag = 1;
  for (i = ad = 0, ref1 = NSYM; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    symtab[i] = new U();
  }
  for (i = ae = 0, ref2 = NSYM; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    symtab[i].k = SYM;
    binding[i] = symtab[i];
    arglist[i] = symbol(NIL);
  }
  p0 = symbol(NIL);
  p1 = symbol(NIL);
  p2 = symbol(NIL);
  p3 = symbol(NIL);
  p4 = symbol(NIL);
  p5 = symbol(NIL);
  p6 = symbol(NIL);
  p7 = symbol(NIL);
  p8 = symbol(NIL);
  p9 = symbol(NIL);
  std_symbol("abs", ABS);
  std_symbol("add", ADD);
  std_symbol("adj", ADJ);
  std_symbol("and", AND);
  std_symbol("arccos", ARCCOS);
  std_symbol("arccosh", ARCCOSH);
  std_symbol("arcsin", ARCSIN);
  std_symbol("arcsinh", ARCSINH);
  std_symbol("arctan", ARCTAN);
  std_symbol("arctanh", ARCTANH);
  std_symbol("arg", ARG);
  std_symbol("atomize", ATOMIZE);
  std_symbol("besselj", BESSELJ);
  std_symbol("bessely", BESSELY);
  std_symbol("binding", BINDING);
  std_symbol("binomial", BINOMIAL);
  std_symbol("ceiling", CEILING);
  std_symbol("check", CHECK);
  std_symbol("choose", CHOOSE);
  std_symbol("circexp", CIRCEXP);
  std_symbol("clear", CLEAR);
  std_symbol("clock", CLOCK);
  std_symbol("coeff", COEFF);
  std_symbol("cofactor", COFACTOR);
  std_symbol("condense", CONDENSE);
  std_symbol("conj", CONJ);
  std_symbol("contract", CONTRACT);
  std_symbol("cos", COS);
  std_symbol("cosh", COSH);
  std_symbol("decomp", DECOMP);
  std_symbol("defint", DEFINT);
  std_symbol("deg", DEGREE);
  std_symbol("denominator", DENOMINATOR);
  std_symbol("det", DET);
  std_symbol("derivative", DERIVATIVE);
  std_symbol("dim", DIM);
  std_symbol("dirac", DIRAC);
  std_symbol("display", DISPLAY);
  std_symbol("divisors", DIVISORS);
  std_symbol("do", DO);
  std_symbol("dot", DOT);
  std_symbol("draw", DRAW);
  std_symbol("dsolve", DSOLVE);
  std_symbol("erf", ERF);
  std_symbol("erfc", ERFC);
  std_symbol("eigen", EIGEN);
  std_symbol("eigenval", EIGENVAL);
  std_symbol("eigenvec", EIGENVEC);
  std_symbol("eval", EVAL);
  std_symbol("exp", EXP);
  std_symbol("expand", EXPAND);
  std_symbol("expcos", EXPCOS);
  std_symbol("expsin", EXPSIN);
  std_symbol("factor", FACTOR);
  std_symbol("factorial", FACTORIAL);
  std_symbol("factorpoly", FACTORPOLY);
  std_symbol("filter", FILTER);
  std_symbol("float", FLOATF);
  std_symbol("floor", FLOOR);
  std_symbol("for", FOR);
  std_symbol("Gamma", GAMMA);
  std_symbol("gcd", GCD);
  std_symbol("hermite", HERMITE);
  std_symbol("hilbert", HILBERT);
  std_symbol("imag", IMAG);
  std_symbol("component", INDEX);
  std_symbol("inner", INNER);
  std_symbol("integral", INTEGRAL);
  std_symbol("inv", INV);
  std_symbol("invg", INVG);
  std_symbol("isinteger", ISINTEGER);
  std_symbol("isprime", ISPRIME);
  std_symbol("laguerre", LAGUERRE);
  std_symbol("lcm", LCM);
  std_symbol("leading", LEADING);
  std_symbol("legendre", LEGENDRE);
  std_symbol("log", LOG);
  std_symbol("mag", MAG);
  std_symbol("mod", MOD);
  std_symbol("multiply", MULTIPLY);
  std_symbol("not", NOT);
  std_symbol("nroots", NROOTS);
  std_symbol("number", NUMBER);
  std_symbol("numerator", NUMERATOR);
  std_symbol("operator", OPERATOR);
  std_symbol("or", OR);
  std_symbol("outer", OUTER);
  std_symbol("polar", POLAR);
  std_symbol("power", POWER);
  std_symbol("prime", PRIME);
  std_symbol("print", PRINT);
  std_symbol("product", PRODUCT);
  std_symbol("quote", QUOTE);
  std_symbol("quotient", QUOTIENT);
  std_symbol("rank", RANK);
  std_symbol("rationalize", RATIONALIZE);
  std_symbol("real", REAL);
  std_symbol("rect", YYRECT);
  std_symbol("roots", ROOTS);
  std_symbol("equals", SETQ);
  std_symbol("sgn", SGN);
  std_symbol("simplify", SIMPLIFY);
  std_symbol("sin", SIN);
  std_symbol("sinh", SINH);
  std_symbol("sqrt", SQRT);
  std_symbol("stop", STOP);
  std_symbol("subst", SUBST);
  std_symbol("sum", SUM);
  std_symbol("tan", TAN);
  std_symbol("tanh", TANH);
  std_symbol("taylor", TAYLOR);
  std_symbol("test", TEST);
  std_symbol("testeq", TESTEQ);
  std_symbol("testge", TESTGE);
  std_symbol("testgt", TESTGT);
  std_symbol("testle", TESTLE);
  std_symbol("testlt", TESTLT);
  std_symbol("transpose", TRANSPOSE);
  std_symbol("unit", UNIT);
  std_symbol("zero", ZERO);
  std_symbol("nil", NIL);
  std_symbol("autoexpand", AUTOEXPAND);
  std_symbol("bake", BAKE);
  std_symbol("last", LAST);
  std_symbol("trace", TRACE);
  std_symbol("tty", TTY);
  std_symbol("~", YYE);
  std_symbol("$DRAWX", DRAWX);
  std_symbol("$METAA", METAA);
  std_symbol("$METAB", METAB);
  std_symbol("$METAX", METAX);
  std_symbol("$SECRETX", SECRETX);
  std_symbol("pi", PI);
  std_symbol("a", SYMBOL_A);
  std_symbol("b", SYMBOL_B);
  std_symbol("c", SYMBOL_C);
  std_symbol("d", SYMBOL_D);
  std_symbol("i", SYMBOL_I);
  std_symbol("j", SYMBOL_J);
  std_symbol("n", SYMBOL_N);
  std_symbol("r", SYMBOL_R);
  std_symbol("s", SYMBOL_S);
  std_symbol("t", SYMBOL_T);
  std_symbol("x", SYMBOL_X);
  std_symbol("y", SYMBOL_Y);
  std_symbol("z", SYMBOL_Z);
  std_symbol("$C1", C1);
  std_symbol("$C2", C2);
  std_symbol("$C3", C3);
  std_symbol("$C4", C4);
  std_symbol("$C5", C5);
  std_symbol("$C6", C6);
  push_integer(0);
  zero = pop();
  push_integer(1);
  one = pop();
  push_symbol(POWER);
  print1(stack[tos - 1]);
  push_integer(-1);
  print1(stack[tos - 1]);
  push_rational(1, 2);
  print1(stack[tos - 1]);
  list(3);
  print1(stack[tos - 1]);
  imaginaryunit = pop();
  return defn();
};

defn_str = ["e=exp(1)", "i=sqrt(-1)", "autoexpand=1", "trange=(-pi,pi)", "xrange=(-10,10)", "yrange=(-10,10)", "last=0", "trace=0", "tty=0", "cross(u,v)=(u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1])", "curl(v)=(d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y))", "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)", "ln(x)=log(x)"];

defn = function() {
  var ad, definitionOfInterest, defn_i, ref1, results;
  results = [];
  for (defn_i = ad = 0, ref1 = defn_str.length; 0 <= ref1 ? ad < ref1 : ad > ref1; defn_i = 0 <= ref1 ? ++ad : --ad) {
    definitionOfInterest = defn_str[defn_i];
    scan(definitionOfInterest);
    console.log("... evaling " + definitionOfInterest);
    console.log("top of stack:");
    print1(stack[tos - 1]);
    Eval();
    results.push(pop());
  }
  return results;
};

Eval_inner = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    inner();
    results.push(p1 = cdr(p1));
  }
  return results;
};

inner = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (istensor(p1) && istensor(p2)) {
    inner_f();
  } else {
    push(p1);
    push(p2);
    if (istensor(p1)) {
      tensor_times_scalar();
    } else if (istensor(p2)) {
      scalar_times_tensor();
    } else {
      multiply();
    }
  }
  return restore();
};

inner_f = function() {
  debugger;
  var a, ad, ae, af, ag, ah, aj, ak, al, b, bk, c, i, j, k, n, ndim, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
  i = 0;
  n = p1.tensor.dim[p1.tensor.ndim - 1];
  if (n !== p2.tensor.dim[0]) {
    debugger;
    stop("inner: tensor dimension check");
  }
  ndim = p1.tensor.ndim + p2.tensor.ndim - 2;
  if (ndim > MAXDIM) {
    stop("inner: rank of result exceeds maximum");
  }
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  ak = 1;
  for (i = ad = 0, ref1 = p1.tensor.ndim - 1; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    ak *= p1.tensor.dim[i];
  }
  bk = 1;
  for (i = ae = 1, ref2 = p2.tensor.ndim; 1 <= ref2 ? ae < ref2 : ae > ref2; i = 1 <= ref2 ? ++ae : --ae) {
    bk *= p2.tensor.dim[i];
  }
  p3 = alloc_tensor(ak * bk);
  c = p3.tensor.elem;
  for (i = af = 0, ref3 = ak; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    for (j = ag = 0, ref4 = n; 0 <= ref4 ? ag < ref4 : ag > ref4; j = 0 <= ref4 ? ++ag : --ag) {
      if (iszero(a[i * n + j])) {
        continue;
      }
      for (k = ah = 0, ref5 = bk; 0 <= ref5 ? ah < ref5 : ah > ref5; k = 0 <= ref5 ? ++ah : --ah) {
        push(a[i * n + j]);
        push(b[j * bk + k]);
        multiply();
        push(c[i * bk + k]);
        add();
        c[i * bk + k] = pop();
      }
    }
  }
  if (ndim === 0) {
    return push(p3.tensor.elem[0]);
  } else {
    p3.tensor.ndim = ndim;
    j = 0;
    for (i = aj = 0, ref6 = p1.tensor.ndim - 1; 0 <= ref6 ? aj < ref6 : aj > ref6; i = 0 <= ref6 ? ++aj : --aj) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    j = p1.tensor.ndim - 1;
    for (i = al = 0, ref7 = p2.tensor.ndim - 1; 0 <= ref7 ? al < ref7 : al > ref7; i = 0 <= ref7 ? ++al : --al) {
      p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];
    }
    return push(p3);
  }
};

test_inner = function() {
  return run_test(["inner(a,b)", "a*b", "inner(a,(b1,b2))", "(a*b1,a*b2)", "inner((a1,a2),b)", "(a1*b,a2*b)", "inner(((a11,a12),(a21,a22)),(x1,x2))", "(a11*x1+a12*x2,a21*x1+a22*x2)", "inner((1,2),(3,4))", "11", "inner(inner((1,2),((3,4),(5,6))),(7,8))", "219", "inner((1,2),inner(((3,4),(5,6)),(7,8)))", "219", "inner((1,2),((3,4),(5,6)),(7,8))", "219"]);
};

Eval_integral = function() {
  var ad, ae, doNothing, i, n, ref1, ref2;
  i = 0;
  n = 0;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    guess();
    push(symbol(NIL));
  } else if (isnum(p2)) {
    guess();
    push(p2);
  } else {
    push(p2);
    p1 = cdr(p1);
    push(car(p1));
    Eval();
  }
  p5 = pop();
  p4 = pop();
  p3 = pop();
  while (1.) {
    if (isnum(p5)) {
      push(p5);
      n = pop_integer();
      if (n === 0x80000000) {
        stop("nth integral: check n");
      }
    } else {
      n = 1;
    }
    push(p3);
    if (n >= 0) {
      for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
        push(p4);
        integral();
      }
    } else {
      n = -n;
      for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
        push(p4);
        derivative();
      }
    }
    p3 = pop();
    if (p5 === symbol(NIL)) {
      break;
    }
    if (isnum(p5)) {
      p1 = cdr(p1);
      push(car(p1));
      Eval();
      p5 = pop();
      if (p5 === symbol(NIL)) {
        break;
      }
      if (isnum(p5)) {
        doNothing = 1;
      } else {
        p4 = p5;
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
      }
    } else {
      p4 = p5;
      p1 = cdr(p1);
      push(car(p1));
      Eval();
      p5 = pop();
    }
  }
  return push(p3);
};

integral = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    integral_of_sum();
  } else if (car(p1) === symbol(MULTIPLY)) {
    integral_of_product();
  } else {
    integral_of_form();
  }
  p1 = pop();
  if (Find(p1, symbol(INTEGRAL))) {
    stop("integral: sorry, could not find a solution");
  }
  push(p1);
  simplify();
  Eval();
  return restore();
};

integral_of_sum = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  push(p2);
  integral();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    push(p2);
    integral();
    add();
    results.push(p1 = cdr(p1));
  }
  return results;
};

integral_of_product = function() {
  push(p1);
  push(p2);
  partition();
  p1 = pop();
  integral_of_form();
  return multiply();
};

integral_of_form = function() {
  push(p1);
  push(p2);
  transform(itab);
  p3 = pop();
  if (p3 === symbol(NIL)) {
    push_symbol(INTEGRAL);
    push(p1);
    push(p2);
    return list(3);
  } else {
    return push(p3);
  }
};

check_arg = function() {
  if (!istensor(p1)) {
    return 0;
  } else if (p1.tensor.ndim !== 2) {
    return 0;
  } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {
    return 0;
  } else {
    return 1;
  }
};

inv = function() {
  var a, ad, i, n, ref1;
  i = 0;
  n = 0;
  save();
  p1 = pop();
  if (check_arg() === 0) {
    push_symbol(INV);
    push(p1);
    list(2);
    restore();
    return;
  }
  n = p1.tensor.nelem;
  a = p1.tensor.elem;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    if (!isnum(a[i])) {
      break;
    }
  }
  if (i === n) {
    yyinvg();
  } else {
    push(p1);
    adj();
    push(p1);
    det();
    p2 = pop();
    if (iszero(p2)) {
      stop("inverse of singular matrix");
    }
    push(p2);
    divide();
  }
  return restore();
};

invg = function() {
  save();
  p1 = pop();
  if (check_arg() === 0) {
    push_symbol(INVG);
    push(p1);
    list(2);
    restore();
    return;
  }
  yyinvg();
  return restore();
};

yyinvg = function() {
  var ad, ae, af, ag, h, i, j, n, ref1, ref2, ref3, ref4;
  h = 0;
  i = 0;
  j = 0;
  n = 0;
  n = p1.tensor.dim[0];
  h = tos;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    for (j = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; j = 0 <= ref2 ? ++ae : --ae) {
      if (i === j) {
        push(one);
      } else {
        push(zero);
      }
    }
  }
  for (i = af = 0, ref3 = n * n; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    push(p1.tensor.elem[i]);
  }
  decomp(n);
  p1 = alloc_tensor(n * n);
  p1.tensor.ndim = 2;
  p1.tensor.dim[0] = n;
  p1.tensor.dim[1] = n;
  for (i = ag = 0, ref4 = n * n; 0 <= ref4 ? ag < ref4 : ag > ref4; i = 0 <= ref4 ? ++ag : --ag) {
    p1.tensor.elem[i] = stack[h + i];
  }
  tos -= 2 * n * n;
  return push(p1);
};

decomp = function(n) {
  var a, ad, ae, af, ag, d, i, j, ref1, ref2, ref3, ref4, ref5, results, u;
  a = 0;
  d = 0;
  i = 0;
  j = 0;
  u = 0;
  a = tos - n * n;
  u = a - n * n;
  results = [];
  for (d = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; d = 0 <= ref1 ? ++ad : --ad) {
    if (equal(stack[a + n * d + d], zero)) {
      for (i = ae = ref2 = d + 1, ref3 = n; ref2 <= ref3 ? ae < ref3 : ae > ref3; i = ref2 <= ref3 ? ++ae : --ae) {
        if (!equal(stack[a + n * i + d], zero)) {
          break;
        }
      }
      if (i === n) {
        stop("inverse of singular matrix");
      }
      for (j = af = 0, ref4 = n; 0 <= ref4 ? af < ref4 : af > ref4; j = 0 <= ref4 ? ++af : --af) {
        p2 = stack[a + n * d + j];
        stack[a + n * d + j] = stack[a + n * i + j];
        stack[a + n * i + j] = p2;
        p2 = stack[u + n * d + j];
        stack[u + n * d + j] = stack[u + n * i + j];
        stack[u + n * i + j] = p2;
      }
    }
    p2 = stack[a + n * d + d];
    for (j = ag = 0, ref5 = n; 0 <= ref5 ? ag < ref5 : ag > ref5; j = 0 <= ref5 ? ++ag : --ag) {
      if (j > d) {
        push(stack[a + n * d + j]);
        push(p2);
        divide();
        stack[a + n * d + j] = pop();
      }
      push(stack[u + n * d + j]);
      push(p2);
      divide();
      stack[u + n * d + j] = pop();
    }
    results.push((function() {
      var ah, ref6, results1;
      results1 = [];
      for (i = ah = 0, ref6 = n; 0 <= ref6 ? ah < ref6 : ah > ref6; i = 0 <= ref6 ? ++ah : --ah) {
        if (i === d) {
          continue;
        }
        p2 = stack[a + n * i + d];
        results1.push((function() {
          var aj, ref7, results2;
          results2 = [];
          for (j = aj = 0, ref7 = n; 0 <= ref7 ? aj < ref7 : aj > ref7; j = 0 <= ref7 ? ++aj : --aj) {
            if (j > d) {
              push(stack[a + n * i + j]);
              push(stack[a + n * d + j]);
              push(p2);
              multiply();
              subtract();
              stack[a + n * i + j] = pop();
            }
            push(stack[u + n * i + j]);
            push(stack[u + n * d + j]);
            push(p2);
            multiply();
            subtract();
            results2.push(stack[u + n * i + j] = pop());
          }
          return results2;
        })());
      }
      return results1;
    })());
  }
  return results;
};

iszero = function(p) {
  var ad, i, ref1;
  i = 0;
  switch (p.k) {
    case NUM:
      if (MZERO(p.q.a)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === 0.0) {
        return 1;
      }
      break;
    case TENSOR:
      for (i = ad = 0, ref1 = p.tensor.nelem; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
        if (!iszero(p.tensor.elem[i])) {
          return 0;
        }
      }
      return 1;
  }
  return 0;
};

isnegativenumber = function(p) {
  switch (p.k) {
    case NUM:
      if (MSIGN(p.q.a) === -1) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d < 0.0) {
        return 1;
      }
  }
  return 0;
};

isplusone = function(p) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === 1.0) {
        return 1;
      }
  }
  return 0;
};

isminusone = function(p) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === -1.0) {
        return 1;
      }
  }
  return 0;
};

isinteger = function(p) {
  if (p.k === NUM && MEQUAL(p.q.b, 1)) {
    return 1;
  } else {
    return 0;
  }
};

isnonnegativeinteger = function(p) {
  if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {
    return 1;
  } else {
    return 0;
  }
};

isposint = function(p) {
  if (isinteger(p) && MSIGN(p.q.a) === 1) {
    return 1;
  } else {
    return 0;
  }
};

ispoly = function(p, x) {
  if (Find(p, x)) {
    return ispoly_expr(p, x);
  } else {
    return 0;
  }
};

ispoly_expr = function(p, x) {
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    while (iscons(p)) {
      if (!ispoly_term(car(p), x)) {
        return 0;
      }
      p = cdr(p);
    }
    return 1;
  } else {
    return ispoly_term(p, x);
  }
};

ispoly_term = function(p, x) {
  if (car(p) === symbol(MULTIPLY)) {
    p = cdr(p);
    while (iscons(p)) {
      if (!ispoly_factor(car(p), x)) {
        return 0;
      }
      p = cdr(p);
    }
    return 1;
  } else {
    return ispoly_factor(p, x);
  }
};

ispoly_factor = function(p, x) {
  if (equal(p, x)) {
    return 1;
  }
  if (car(p) === symbol(POWER) && equal(cadr(p), x)) {
    if (isposint(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  }
  if (Find(p, x)) {
    return 0;
  } else {
    return 1;
  }
};

isnegativeterm = function(p) {
  if (isnegativenumber(p)) {
    return 1;
  } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isimaginarynumber = function(p) {
  if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isnum(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit)) {
    return 1;
  } else {
    return 0;
  }
};

iscomplexnumber = function(p) {
  if ((car(p) === symbol(ADD) && length(p) === 3 && isnum(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {
    return 1;
  } else {
    return 0;
  }
};

iseveninteger = function(p) {
  if (isinteger(p) && p.q.a.isEven()) {
    return 1;
  } else {
    return 0;
  }
};

isnegative = function(p) {
  if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {
    return 1;
  } else if (isnegativeterm(p)) {
    return 1;
  } else {
    return 0;
  }
};

issymbolic = function(p) {
  if (issymbol(p)) {
    return 1;
  } else {
    while (iscons(p)) {
      if (issymbolic(car(p))) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  }
};

isintegerfactor = function(p) {
  if (isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isoneover = function(p) {
  if (car(p) === symbol(POWER) && isminusone(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isfraction = function(p) {
  if (p.k === NUM && !MEQUAL(p.q.b, 1)) {
    return 1;
  } else {
    return 0;
  }
};

equaln = function(p, n) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === n) {
        return 1;
      }
  }
  return 0;
};

equalq = function(p, a, b) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === a / b) {
        return 1;
      }
  }
  return 0;
};

isoneoversqrttwo = function(p) {
  if (car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2)) {
    return 1;
  } else {
    return 0;
  }
};

isminusoneoversqrttwo = function(p) {
  if (car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3) {
    return 1;
  } else {
    return 0;
  }
};

isfloating = function(p) {
  if (p.k === DOUBLE) {
    return 1;
  }
  while (iscons(p)) {
    if (isfloating(car(p))) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

isimaginaryunit = function(p) {
  if (equal(p, imaginaryunit)) {
    return 1;
  } else {
    return 0;
  }
};

isquarterturn = function(p) {
  var minussign, n;
  n = 0;
  minussign = 0;
  if (car(p) !== symbol(MULTIPLY)) {
    return 0;
  }
  if (equal(cadr(p), imaginaryunit)) {
    if (caddr(p) !== symbol(PI)) {
      return 0;
    }
    if (length(p) !== 3) {
      return 0;
    }
    return 2;
  }
  if (!isnum(cadr(p))) {
    return 0;
  }
  if (!equal(caddr(p), imaginaryunit)) {
    return 0;
  }
  if (cadddr(p) !== symbol(PI)) {
    return 0;
  }
  if (length(p) !== 4) {
    return 0;
  }
  push(cadr(p));
  push_integer(2);
  multiply();
  n = pop_integer();
  if (n === 0x80000000) {
    return 0;
  }
  if (n < 1) {
    minussign = 1;
    n = -n;
  }
  switch (n % 4) {
    case 0:
      n = 1;
      break;
    case 1:
      if (minussign) {
        n = 4;
      } else {
        n = 3;
      }
      break;
    case 2:
      n = 2;
      break;
    case 3:
      if (minussign) {
        n = 3;
      } else {
        n = 4;
      }
  }
  return n;
};

isnpi = function(p) {
  var doNothing, n;
  n = 0;
  if (p === symbol(PI)) {
    return 2;
  }
  if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {
    doNothing = 0;
  } else {
    return 0;
  }
  push(cadr(p));
  push_integer(2);
  multiply();
  n = pop_integer();
  if (n === 0x80000000) {
    return 0;
  }
  if (n < 0) {
    n = 4 - (-n) % 4;
  } else {
    n = 1 + (n - 1) % 4;
  }
  return n;
};


/*
 Laguerre function

Example

	laguerre(x,3)

Result

	   1   3    3   2
	- --- x  + --- x  - 3 x + 1
	   6        2

The computation uses the following recurrence relation.

	L(x,0,k) = 1

	L(x,1,k) = -x + k + 1

	n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)

In the "for" loop i = n-1 so the recurrence relation becomes

	(i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)
 */

Eval_laguerre = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadddr(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    push_integer(0);
  } else {
    push(p2);
  }
  return laguerre();
};

laguerre = function() {
  var n;
  n = 0;
  save();
  p3 = pop();
  p2 = pop();
  p1 = pop();
  push(p2);
  n = pop_integer();
  if (n < 0 || n === 0x80000000) {
    push_symbol(LAGUERRE);
    push(p1);
    push(p2);
    push(p3);
    list(4);
    restore();
    return;
  }
  if (issymbol(p1)) {
    laguerre2(n);
  } else {
    p4 = p1;
    p1 = symbol(SECRETX);
    laguerre2(n);
    p1 = p4;
    push(symbol(SECRETX));
    push(p1);
    subst();
    Eval();
  }
  return restore();
};

laguerre2 = function(n) {
  var ad, i, ref1, results;
  i = 0;
  push_integer(1);
  push_integer(0);
  p6 = pop();
  results = [];
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    p5 = p6;
    p6 = pop();
    push_integer(2 * i + 1);
    push(p1);
    subtract();
    push(p3);
    add();
    push(p6);
    multiply();
    push_integer(i);
    push(p3);
    add();
    push(p5);
    multiply();
    subtract();
    push_integer(i + 1);
    results.push(divide());
  }
  return results;
};

test_laguerre = function() {
  return run_test(["laguerre(x,n)", "laguerre(x,n,0)", "laguerre(x,n,k)", "laguerre(x,n,k)", "laguerre(x,0)-1", "0", "laguerre(x,1)-(-x+1)", "0", "laguerre(x,2)-1/2*(x^2-4*x+2)", "0", "laguerre(x,3)-1/6*(-x^3+9*x^2-18*x+6)", "0", "laguerre(x,0,k)-1", "0", "laguerre(x,1,k)-(-x+k+1)", "0", "laguerre(x,2,k)-1/2*(x^2-2*(k+2)*x+(k+1)*(k+2))", "0", "laguerre(x,3,k)-1/6*(-x^3+3*(k+3)*x^2-3*(k+2)*(k+3)*x+(k+1)*(k+2)*(k+3))", "0", "laguerre(a-b,10)-eval(subst(a-b,x,laguerre(x,10)))", "0"]);
};

Eval_lcm = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    lcm();
    results.push(p1 = cdr(p1));
  }
  return results;
};

lcm = function() {
  var x;
  x = 0;
  x = expanding;
  save();
  yylcm();
  restore();
  return expanding = x;
};

yylcm = function() {
  expanding = 1;
  p2 = pop();
  p1 = pop();
  push(p1);
  push(p2);
  gcd();
  push(p1);
  divide();
  push(p2);
  divide();
  return inverse();
};

test_lcm = function() {
  return run_test(["lcm(4,6)", "12", "lcm(4*x,6*x*y)", "12*x*y", "lcm(2,3,4)", "12"]);
};


/*
 Legendre function

Example

	legendre(x,3,0)

Result

	 5   3    3
	--- x  - --- x
	 2        2

The computation uses the following recurrence relation.

	P(x,0) = 1

	P(x,1) = x

	n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)

In the "for" loop we have i = n-1 so the recurrence relation becomes

	(i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)

For m > 0

	P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)
 */

Eval_legendre = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadddr(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    push_integer(0);
  } else {
    push(p2);
  }
  return legendre();
};

legendre = function() {
  save();
  __legendre();
  return restore();
};

__legendre = function() {
  var m, n;
  m = 0;
  n = 0;
  p3 = pop();
  p2 = pop();
  p1 = pop();
  push(p2);
  n = pop_integer();
  push(p3);
  m = pop_integer();
  if (n < 0 || n === 0x80000000 || m < 0 || m === 0x80000000) {
    push_symbol(LEGENDRE);
    push(p1);
    push(p2);
    push(p3);
    list(4);
    return;
  }
  if (issymbol(p1)) {
    __legendre2(n, m);
  } else {
    p4 = p1;
    p1 = symbol(SECRETX);
    __legendre2(n, m);
    p1 = p4;
    push(symbol(SECRETX));
    push(p1);
    subst();
    Eval();
  }
  return __legendre3(m);
};

__legendre2 = function(n, m) {
  var ad, ae, i, ref1, ref2, results;
  i = 0;
  push_integer(1);
  push_integer(0);
  p6 = pop();
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    p5 = p6;
    p6 = pop();
    push_integer(2 * i + 1);
    push(p1);
    multiply();
    push(p6);
    multiply();
    push_integer(i);
    push(p5);
    multiply();
    subtract();
    push_integer(i + 1);
    divide();
  }
  results = [];
  for (i = ae = 0, ref2 = m; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    push(p1);
    results.push(derivative());
  }
  return results;
};

__legendre3 = function(m) {
  if (m === 0) {
    return;
  }
  if (car(p1) === symbol(COS)) {
    push(cadr(p1));
    sine();
    square();
  } else if (car(p1) === symbol(SIN)) {
    push(cadr(p1));
    cosine();
    square();
  } else {
    push_integer(1);
    push(p1);
    square();
    subtract();
  }
  push_integer(m);
  push_rational(1, 2);
  multiply();
  power();
  multiply();
  if (m % 2) {
    return negate();
  }
};

test_legendre = function() {
  return run_test(["legendre(x,n)", "legendre(x,n,0)", "legendre(x,n,m)", "legendre(x,n,m)", "legendre(x,0)-1", "0", "legendre(x,1)-x", "0", "legendre(x,2)-1/2*(3*x^2-1)", "0", "legendre(x,3)-1/2*(5*x^3-3*x)", "0", "legendre(x,4)-1/8*(35*x^4-30*x^2+3)", "0", "legendre(x,5)-1/8*(63*x^5-70*x^3+15*x)", "0", "legendre(x,6)-1/16*(231*x^6-315*x^4+105*x^2-5)", "0", "legendre(x,0,0)-1", "0", "legendre(x,1,0)-x", "0", "legendre(x,1,1)+(1-x^2)^(1/2)", "0", "legendre(x,2,0)-1/2*(3*x^2-1)", "0", "legendre(x,2,1)+3*x*(1-x^2)^(1/2)", "0", "legendre(x,2,2)-3*(1-x^2)", "0", "legendre(x,3,0)-1/2*x*(5*x^2-3)", "0", "legendre(x,3,1)-3/2*(1-5*x^2)*(1-x^2)^(1/2)", "0", "legendre(x,3,2)-15*x*(1-x^2)", "0", "legendre(x,3,3)+15*(1-x^2)^(3/2)", "0", "legendre(x,4,0)-1/8*(35*x^4-30*x^2+3)", "0", "legendre(x,4,1)-5/2*x*(3-7*x^2)*(1-x^2)^(1/2)", "0", "legendre(x,4,2)-15/2*(7*x^2-1)*(1-x^2)", "0", "legendre(x,4,3)+105*x*(1-x^2)^(3/2)", "0", "legendre(x,4,4)-105*(1-x^2)^2", "0", "legendre(x,5,0)-1/8*x*(63*x^4-70*x^2+15)", "0", "legendre(cos(theta),0,0)-1", "0", "legendre(cos(theta),1,0)-cos(theta)", "0", "legendre(cos(theta),1,1)+sin(theta)", "0", "legendre(cos(theta),2,0)-1/2*(3*cos(theta)^2-1)", "0", "legendre(cos(theta),2,1)+3*sin(theta)*cos(theta)", "0", "legendre(cos(theta),2,2)-3*sin(theta)^2", "0", "legendre(cos(theta),3,0)-1/2*cos(theta)*(5*cos(theta)^2-3)", "0", "legendre(cos(theta),3,1)+3/2*(5*cos(theta)^2-1)*sin(theta)", "0", "legendre(cos(theta),3,2)-15*cos(theta)*sin(theta)^2", "0", "legendre(cos(theta),3,3)+15*sin(theta)^3", "0", "legendre(a-b,10)-eval(subst(a-b,x,legendre(x,10)))", "0"]);
};

list = function(n) {
  var ad, listIterator, ref1, results;
  listIterator = 0;
  push(symbol(NIL));
  results = [];
  for (listIterator = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; listIterator = 0 <= ref1 ? ++ad : --ad) {
    results.push(cons());
  }
  return results;
};

Eval_log = function() {
  push(cadr(p1));
  Eval();
  return logarithm();
};

logarithm = function() {
  save();
  yylog();
  return restore();
};

yylog = function() {
  var d;
  d = 0.0;
  p1 = pop();
  if (p1 === symbol(E)) {
    push_integer(1);
    return;
  }
  if (equaln(p1, 1)) {
    push_integer(0);
    return;
  }
  if (isnegativenumber(p1)) {
    push(p1);
    negate();
    logarithm();
    push(imaginaryunit);
    push_symbol(PI);
    multiply();
    add();
    return;
  }
  if (isdouble(p1)) {
    d = Math.log(p1.d);
    push_double(d);
    return;
  }
  if (isfraction(p1)) {
    push(p1);
    numerator();
    logarithm();
    push(p1);
    denominator();
    logarithm();
    subtract();
    return;
  }
  if (car(p1) === symbol(POWER)) {
    push(caddr(p1));
    push(cadr(p1));
    logarithm();
    multiply();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    push_integer(0);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      logarithm();
      add();
      p1 = cdr(p1);
    }
    return;
  }
  push_symbol(LOG);
  push(p1);
  return list(2);
};

test_log = function() {
  return run_test(["log(1)", "0", "log(exp(1))", "1", "log(exp(x))", "x", "exp(log(x))", "x", "log(x^2)", "2*log(x)", "log(1/x)", "-log(x)", "log(a^b)", "b*log(a)", "log(2)", "log(2)", "log(2.0)", "0.693147", "float(log(2))", "0.693147", "log(a*b)", "log(a)+log(b)", "log(1/3)+log(3)", "0", "log(-1)", "i*pi", "log(-1.0)", "i*pi"]);
};

madd = function(a, b) {
  return a.add(b);
};

msub = function(a, b) {
  return a.subtract(b);
};

addf = function(a, b) {
  return a.add(b);
};

subf = function(a, b) {
  return a.subtract(b);
};

ucmp = function(a, b) {
  return a.compareAbs(b);
};

test_madd = function() {
  var ad, ae, i, j, m;
  i = 0;
  console.log("test madd");
  m = mtotal;
  for (i = ad = -100; ad < 100; i = ++ad) {
    for (j = ae = -100; ae < 100; j = ++ae) {
      test_maddf(i, j, i + j);
    }
  }
  return logout("ok\n");
};

test_maddf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = madd(a, b);
  if (mcmp(c, d) === 0) {
    return;
  } else {
    throw new Error("test_maddf");
  }
  logout(logbuf);
  return errout();
};

test_msub = function() {
  var ad, ae, i, j, m;
  i = 0;
  logout("test msub\n");
  m = mtotal;
  for (i = ad = -100; ad <= 100; i = ++ad) {
    for (j = ae = -100; ae <= 100; j = ++ae) {
      test_msubf(i, j, i - j);
    }
  }
  if (m !== mtotal) {
    logout("memory leak\n");
    errout();
  }
  return logout("ok\n");
};

test_msubf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = msub(a, b);
  if (mcmp(c, d) === 0) {
    return;
  }
  logout(logbuf);
  return errout();
};


/*
 Magnitude of complex z

	z		mag(z)
	-		------

	a		a

	-a		a

	(-1)^a		1

	exp(a + i b)	exp(a)

	a b		mag(a) mag(b)

	a + i b		sqrt(a^2 + b^2)

Notes

	1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)

	2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then

		mag(numerator(z)) / mag(denominator(z))

	   must be used to get the correct answer. Now the operation is
	   automatic.
 */

Eval_mag = function() {
  push(cadr(p1));
  Eval();
  return mag();
};

mag = function() {
  save();
  p1 = pop();
  push(p1);
  numerator();
  yymag();
  push(p1);
  denominator();
  yymag();
  divide();
  return restore();
};

yymag = function() {
  save();
  p1 = pop();
  if (isnegativenumber(p1)) {
    push(p1);
    negate();
  } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {
    push_integer(1);
  } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {
    push(caddr(p1));
    real();
    exponential();
  } else if (car(p1) === symbol(MULTIPLY)) {
    push_integer(1);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      mag();
      multiply();
      p1 = cdr(p1);
    }
  } else if (car(p1) === symbol(ADD)) {
    push(p1);
    rect();
    p1 = pop();
    push(p1);
    real();
    push_integer(2);
    power();
    push(p1);
    imag();
    push_integer(2);
    power();
    add();
    push_rational(1, 2);
    power();
    simplify_trig();
  } else {
    push(p1);
  }
  return restore();
};

test_mag = function() {
  return run_test(["mag(a+i*b)", "(a^2+b^2)^(1/2)", "mag(exp(a+i*b))", "exp(a)", "mag(1)", "1", "mag(-1)", "1", "mag(1+exp(i*pi/3))", "3^(1/2)", "mag((a+i*b)/(c+i*d))", "(a^2+b^2)^(1/2)/((c^2+d^2)^(1/2))", "mag(exp(i theta))", "1", "mag(exp(-i theta))", "1", "mag((-1)^theta)", "1", "mag((-1)^(-theta))", "1", "mag(3*(-1)^theta)", "3", "mag(3*(-1)^(-theta))", "3", "mag(-3*(-1)^theta)", "3", "mag(-3*(-1)^(-theta))", "3"]);
};

mcmp = function(a, b) {
  return a.compare(b);
};

mcmpint = function(a, n) {
  var b, t;
  b = bigInt(n);
  t = mcmp(a, b);
  return t;
};


/*
#if SELFTEST

void
test_mcmp(void)
{
	int i, j, k;
	unsigned int *x, *y;
	logout("testing mcmp\n");
	for (i = -1000; i < 1000; i++) {
		x = mint(i);
		for (j = -1000; j < 1000; j++) {
			y = mint(j);
			k = mcmp(x, y);
			if (i == j && k != 0) {
				logout("failed\n");
				errout();
			}
			if (i < j && k != -1) {
				logout("failed\n");
				errout();
			}
			if (i > j && k != 1) {
				logout("failed\n");
				errout();
			}
			mfree(y);
		}
		mfree(x);
	}
	logout("ok\n");
}

#endif
 */

mgcd = function(u, v) {
  return bigInt.gcd(u, v);
};

test_mgcd = function() {
  var a, ad, ae, b, c, d, i, j;
  logout("testing mgcd\n");
  for (i = ad = 1; ad < 100; i = ++ad) {
    a = mint(i);
    for (j = ae = 1; ae < 100; j = ++ae) {
      b = mint(j);
      c = mgcd(a, b);
      d = egcd(a, b);
      if (mcmp(c, d) !== 0) {
        throw new Error("test_mgcd failed");
      }
    }
  }
  return logout("ok\n");
};

egcd = function(a, b) {
  var c, sign;
  sign = 0;
  if (MZERO(b)) {
    stop("divide by zero");
  }
  if (MZERO(a)) {
    return b;
  }
  sign = MSIGN(b);
  while (!MZERO(b)) {
    c = mmod(a, b);
    a = b;
    b = c;
  }
  a = setSignTo(a, sign);
  return a;
};

new_string = function(s) {
  save();
  p1 = new U();
  p1.k = STR;
  p1.str = s;
  push(p1);
  return restore();
};

out_of_memory = function() {
  return stop("out of memory");
};

push_zero_matrix = function(i, j) {
  push(alloc_tensor(i * j));
  stack[tos - 1].tensor.ndim = 2;
  stack[tos - 1].tensor.dim[0] = i;
  return stack[tos - 1].tensor.dim[1] = j;
};

push_identity_matrix = function(n) {
  var ad, i, ref1;
  push_zero_matrix(n, n);
  i = 0;
  for (i = ad = 0, ref1 = n; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    stack[tos - 1].tensor.elem[i * n + i] = one;
  }
  if (stack[tos - 1].tensor.nelem !== stack[tos - 1].tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
};

push_cars = function(p) {
  var results;
  results = [];
  while (iscons(p)) {
    push(car(p));
    results.push(p = cdr(p));
  }
  return results;
};

peek = function() {
  save();
  p1 = pop();
  push(p1);
  printline(p1);
  return restore();
};

peek2 = function() {
  print_lisp(stack[tos - 2]);
  return print_lisp(stack[tos - 1]);
};

equal = function(p1, p2) {
  if (cmp_expr(p1, p2) === 0) {
    return 1;
  } else {
    return 0;
  }
};

lessp = function(p1, p2) {
  if (cmp_expr(p1, p2) < 0) {
    return 1;
  } else {
    return 0;
  }
};

sign = function(n) {
  if (n < 0) {
    return -1;
  } else if (n > 0) {
    return 1;
  } else {
    return 0;
  }
};

cmp_expr = function(p1, p2) {
  var n;
  n = 0;
  if (p1 === p2) {
    return 0;
  }
  if (p1 === symbol(NIL)) {
    return -1;
  }
  if (p2 === symbol(NIL)) {
    return 1;
  }
  if (isnum(p1) && isnum(p2)) {
    return sign(compare_numbers(p1, p2));
  }
  if (isnum(p1)) {
    return -1;
  }
  if (isnum(p2)) {
    return 1;
  }
  if (isstr(p1) && isstr(p2)) {
    return sign(strcmp(p1.str, p2.str));
  }
  if (isstr(p1)) {
    return -1;
  }
  if (isstr(p2)) {
    return 1;
  }
  if (issymbol(p1) && issymbol(p2)) {
    return sign(strcmp(get_printname(p1), get_printname(p2)));
  }
  if (issymbol(p1)) {
    return -1;
  }
  if (issymbol(p2)) {
    return 1;
  }
  if (istensor(p1) && istensor(p2)) {
    return compare_tensors(p1, p2);
  }
  if (istensor(p1)) {
    return -1;
  }
  if (istensor(p2)) {
    return 1;
  }
  while (iscons(p1) && iscons(p2)) {
    n = cmp_expr(car(p1), car(p2));
    if (n !== 0) {
      return n;
    }
    p1 = cdr(p1);
    p2 = cdr(p2);
  }
  if (iscons(p2)) {
    return -1;
  }
  if (iscons(p1)) {
    return 1;
  }
  return 0;
};

length = function(p) {
  var n;
  n = 0;
  while (iscons(p)) {
    p = cdr(p);
    n++;
  }
  return n;
};

unique = function(p) {
  save();
  p1 = symbol(NIL);
  p2 = symbol(NIL);
  unique_f(p);
  if (p2 !== symbol(NIL)) {
    p1 = symbol(NIL);
  }
  p = p1;
  restore();
  return p;
};

unique_f = function(p) {
  if (isstr(p)) {
    if (p1 === symbol(NIL)) {
      p1 = p;
    } else if (p !== p1) {
      p2 = p;
    }
    return;
  }
  while (iscons(p)) {
    unique_f(car(p));
    if (p2 !== symbol(NIL)) {
      return;
    }
    p = cdr(p);
  }
};


/*
void
check_endianess(void)
{
	int tmp = 1;
	if (((char *) &tmp)[0] == 1 && Y_LITTLE_ENDIAN == 0) {
		printf("Please change Y_LITTLE_ENDIAN to 1 in defs.h and recompile.\n");
		Exit(1);
	}
	if (((char *) &tmp)[0] == 0 && Y_LITTLE_ENDIAN != 0) {
		printf("Please change Y_LITTLE_ENDIAN to 0 in defs.h and recompile.\n");
		Exit(1);
	}
}
 */

ssqrt = function() {
  push_rational(1, 2);
  return power();
};

yyexpand = function() {
  var x;
  x = expanding;
  expanding = 1;
  Eval();
  return expanding = x;
};

exponential = function() {
  push_symbol(E);
  swap();
  return power();
};

square = function() {
  push_integer(2);
  return power();
};

sort_stack = function(n) {
  var h, subsetOfStack;
  h = tos - n;
  subsetOfStack = stack.slice(h, h + n);
  subsetOfStack.sort(cmp_expr);
  return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
};

mmul = function(a, b) {
  return a.multiply(b);
};

mdiv = function(a, b) {
  return a.divide(b);
};


/*
static void
addf(unsigned int *a, unsigned int *b, int len)
{
	int i;
	long long t = 0; # can be signed or unsigned 
	for (i = 0; i < len; i++) {
		t += (long long) a[i] + b[i];
		a[i] = (unsigned int) t;
		t >>= 32;
	}
}

// a = a - b

static void
subf(unsigned int *a, unsigned int *b, int len)
{
	int i;
	long long t = 0; # must be signed
	for (i = 0; i < len; i++) {
		t += (long long) a[i] - b[i];
		a[i] = (unsigned int) t;
		t >>= 32;
	}
}

// a = b * c

// 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000

static void
mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)
{
	int i;
	unsigned long long t = 0; # must be unsigned
	for (i = 0; i < len; i++) {
		t += (unsigned long long) b[i] * c;
		a[i] = (unsigned int) t;
		t >>= 32;
	}
	a[i] = (unsigned int) t;
}
 */

mmod = function(a, b) {
  return a.mod(b);
};

mdivrem = function(a, b) {
  var toReturn;
  toReturn = a.divmod(b);
  return [toReturn.quotient, toReturn.remainder];
};

test_mmul = function() {
  var ad, ae, i, j, m;
  i = 0;
  j = 0;
  m = 0;
  logout("test mmul\n");
  for (i = ad = -100; ad <= 100; i = ++ad) {
    for (j = ae = -100; ae <= 100; j = ++ae) {
      test_mmulf(i, j, i * j);
    }
  }
  return logout("ok\n");
};

test_mmulf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = mmul(a, b);
  if (mcmp(c, d) === 0) {

  } else {
    throw new Error("test_mmulf error");
  }
};

test_mdiv = function() {
  var ad, ae, expectedResult, i, j, m;
  i = 0;
  j = 0;
  m = 0;
  logout("test mdiv\n");
  for (i = ad = -100; ad <= 100; i = ++ad) {
    for (j = ae = -100; ae <= 100; j = ++ae) {
      if (j) {
        if (i / j > 0) {
          expectedResult = Math.floor(i / j);
        } else {
          expectedResult = Math.ceil(i / j);
        }
        test_mdivf(i, j, expectedResult);
      }
    }
  }
  return logout("ok\n");
};

test_mdivf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = mdiv(a, b);
  if (mcmp(c, d) === 0) {

  } else {
    debugger;
    throw new Error("test_mdivf error");
  }
};

test_mmod = function() {
  var ad, ae, i, j, m;
  i = 0;
  j = 0;
  m = 0;
  logout("test mmod\n");
  for (i = ad = -100; ad <= 100; i = ++ad) {
    for (j = ae = -100; ae <= 100; j = ++ae) {
      if (j) {
        test_mmodf(i, j, i % j);
      }
    }
  }
  return logout("ok\n");
};

test_mmodf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = mmod(a, b);
  if (mcmp(c, d) === 0) {

  } else {
    throw new Error("test_mmodf error");
  }
};

Eval_mod = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return mod();
};

mod = function() {
  var n;
  n = 0;
  save();
  p2 = pop();
  p1 = pop();
  if (iszero(p2)) {
    stop("mod function: divide by zero");
  }
  if (!isnum(p1) || !isnum(p2)) {
    push_symbol(MOD);
    push(p1);
    push(p2);
    list(3);
    restore();
    return;
  }
  if (isdouble(p1)) {
    push(p1);
    n = pop_integer();
    if (n === 0x80000000) {
      stop("mod function: cannot convert float value to integer");
    }
    push_integer(n);
    p1 = pop();
  }
  if (isdouble(p2)) {
    push(p2);
    n = pop_integer();
    if (n === 0x80000000) {
      stop("mod function: cannot convert float value to integer");
    }
    push_integer(n);
    p2 = pop();
  }
  if (!isinteger(p1) || !isinteger(p2)) {
    stop("mod function: integer arguments expected");
  }
  p3 = new U();
  p3.k = NUM;
  p3.q.a = mmod(p1.q.a, p2.q.a);
  p3.q.b = mint(1);
  push(p3);
  return restore();
};

test_mod = function() {
  var run_test;
  return run_test = ["mod(2.0,3.0)", "2", "mod(-2.0,3.0)", "-2", "mod(2.0,-3.0)", "2", "mod(-2.0,-3.0)", "-2", "mod(2,3)", "2", "mod(-2,3)", "-2", "mod(2,-3)", "2", "mod(-2,-3)", "-2", "mod(a,b)", "mod(a,b)", "mod(2.0,0.0)", "Stop: mod function: divide by zero", "mod(2,0)", "Stop: mod function: divide by zero", "mod(1.2,2)", "Stop: mod function: cannot convert float value to integer", "mod(1/2,3)", "Stop: mod function: integer arguments expected", "mod(15,8.0)", "7"];
};

mpow = function(a, n) {
  return a.pow(n);
};

test_mpow = function() {
  var a, ad, ae, b, c, i, j, x;
  logout("testing mpow\n");
  for (i = ad = -10; ad < 10; i = ++ad) {
    a = mint(i);
    x = 1;
    for (j = ae = 0; ae < 10; j = ++ae) {
      b = mpow(a, j);
      c = mint(x);
      if (mcmp(b, c) !== 0) {
        throw new Error("failed test_mpow");
      }
      x *= i;
    }
  }
  return logout("ok\n");
};

mprime = function(n) {
  return n.isProbablePrime();
};

test_mprime = function() {
  var ad, i, k, m, n, t;
  i = 0;
  k = 0;
  m = 0;
  t = 0;
  logout("test mprime\n");
  k = 0;
  for (i = ad = 0; ad < 10000; i = ++ad) {
    n = mint(i);
    t = mprime(n);
    if (i === primetab[k]) {
      if (t === 0) {
        throw new Error("failed for prime number " + i);
      }
      k++;
    } else if (t === 1) {
      throw new Error("failed for composite number " + i);
    }
  }
  return logout("ok\n");
};

mroot = function(n, index) {
  var ad, i, j, k, ref1, x, y;
  n = n.abs();
  i = 0;
  j = 0;
  k = 0;
  if (index === 0) {
    stop("root index is zero");
  }
  k = 0;
  while (n.shiftRight(k) > 0) {
    k++;
  }
  if (k === 0) {
    return mint(0);
  }
  k = Math.floor((k - 1) / index);
  j = Math.floor(k / 32 + 1);
  x = bigInt(j);
  for (i = ad = 0, ref1 = j; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
    x = x.and(bigInt(1).shiftLeft(i).not());
  }
  while (k >= 0) {
    x = x.or(bigInt(1).shiftLeft(k));
    y = mpow(x, index);
    switch (mcmp(y, n)) {
      case 0:
        return x;
      case 1:
        x = x.and(bigInt(1).shiftLeft(k).not());
    }
    k--;
  }
  return 0;
};

test_mroot = function() {
  var a, ad, ae, af, b, c, i, j, mem;
  i = 0;
  j = 0;
  mem = 0;
  logout("testing mroot\n");
  for (i = ad = 0; ad < 10; i = ++ad) {
    a = mint(i);
    for (j = ae = 1; ae < 10; j = ++ae) {
      b = mpow(a, j);
      c = mroot(b, j);
      if (c === 0 || mcmp(a, c) !== 0) {
        debugger;
        throw new Error("failed test_mroot");
      }
    }
  }
  logout(" ...mroot small numbers ok\n");
  a = mint(12345);
  for (i = af = 1; af < 10; i = ++af) {
    b = mpow(a, i);
    c = mroot(b, i);
    if (c === 0 || mcmp(a, c) !== 0) {
      throw new Error("failed");
    }
  }
  logout(" ...mroot big numbers ok\n");
  return logout("ok");
};

multiply = function() {
  if (esc_flag) {
    stop("escape key stop");
  }
  if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
    return multiply_numbers();
  } else {
    save();
    yymultiply();
    return restore();
  }
};

yymultiply = function() {
  var ad, h, i, n, ref1, ref2;
  h = 0;
  i = 0;
  n = 0;
  p2 = pop();
  p1 = pop();
  h = tos;
  if (iszero(p1) || iszero(p2)) {
    push(zero);
    return;
  }
  if (expanding && isadd(p1)) {
    p1 = cdr(p1);
    push(zero);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      multiply();
      add();
      p1 = cdr(p1);
    }
    return;
  }
  if (expanding && isadd(p2)) {
    p2 = cdr(p2);
    push(zero);
    while (iscons(p2)) {
      push(p1);
      push(car(p2));
      multiply();
      add();
      p2 = cdr(p2);
    }
    return;
  }
  if (!istensor(p1) && istensor(p2)) {
    push(p1);
    push(p2);
    scalar_times_tensor();
    return;
  }
  if (istensor(p1) && !istensor(p2)) {
    push(p1);
    push(p2);
    tensor_times_scalar();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
  } else {
    push(p1);
    list(1);
    p1 = pop();
  }
  if (car(p2) === symbol(MULTIPLY)) {
    p2 = cdr(p2);
  } else {
    push(p2);
    list(1);
    p2 = pop();
  }
  if (isnum(car(p1)) && isnum(car(p2))) {
    push(car(p1));
    push(car(p2));
    multiply_numbers();
    p1 = cdr(p1);
    p2 = cdr(p2);
  } else if (isnum(car(p1))) {
    push(car(p1));
    p1 = cdr(p1);
  } else if (isnum(car(p2))) {
    push(car(p2));
    p2 = cdr(p2);
  } else {
    push(one);
  }
  parse_p1();
  parse_p2();
  while (iscons(p1) && iscons(p2)) {
    if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {
      push_symbol(OPERATOR);
      push(cdar(p1));
      push(cdar(p2));
      append();
      cons();
      p1 = cdr(p1);
      p2 = cdr(p2);
      parse_p1();
      parse_p2();
      continue;
    }
    switch (cmp_expr(p3, p4)) {
      case -1:
        push(car(p1));
        p1 = cdr(p1);
        parse_p1();
        break;
      case 1:
        push(car(p2));
        p2 = cdr(p2);
        parse_p2();
        break;
      case 0:
        combine_factors(h);
        p1 = cdr(p1);
        p2 = cdr(p2);
        parse_p1();
        parse_p2();
        break;
      default:
        stop("internal error 2");
    }
  }
  while (iscons(p1)) {
    push(car(p1));
    p1 = cdr(p1);
  }
  while (iscons(p2)) {
    push(car(p2));
    p2 = cdr(p2);
  }
  __normalize_radical_factors(h);
  if (expanding) {
    for (i = ad = ref1 = h, ref2 = tos; ref1 <= ref2 ? ad < ref2 : ad > ref2; i = ref1 <= ref2 ? ++ad : --ad) {
      if (isadd(stack[i])) {
        multiply_all(tos - h);
        return;
      }
    }
  }
  n = tos - h;
  if (n === 1) {
    return;
  }
  if (isrational(stack[h]) && equaln(stack[h], 1)) {
    if (n === 2) {
      p7 = pop();
      pop();
      push(p7);
    } else {
      stack[h] = symbol(MULTIPLY);
      list(n);
    }
    return;
  }
  list(n);
  p7 = pop();
  push_symbol(MULTIPLY);
  push(p7);
  return cons();
};

parse_p1 = function() {
  p3 = car(p1);
  p5 = one;
  if (car(p3) === symbol(POWER)) {
    p5 = caddr(p3);
    return p3 = cadr(p3);
  }
};

parse_p2 = function() {
  p4 = car(p2);
  p6 = one;
  if (car(p4) === symbol(POWER)) {
    p6 = caddr(p4);
    return p4 = cadr(p4);
  }
};

combine_factors = function(h) {
  push(p4);
  push(p5);
  push(p6);
  add();
  power();
  p7 = pop();
  if (isnum(p7)) {
    push(stack[h]);
    push(p7);
    multiply_numbers();
    return stack[h] = pop();
  } else if (car(p7) === symbol(MULTIPLY)) {
    if (isnum(cadr(p7)) && cdddr(p7) === symbol(NIL)) {
      push(stack[h]);
      push(cadr(p7));
      multiply_numbers();
      stack[h] = pop();
      return push(caddr(p7));
    } else {
      return push(p7);
    }
  } else {
    return push(p7);
  }
};

gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];

combine_gammas = function(h) {
  var n;
  n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];
  if (n < 0) {
    n = -n;
    push(stack[h]);
    negate();
    stack[h] = pop();
  }
  if (n > 1) {
    return push(_gamma[n]);
  }
};

multiply_noexpand = function() {
  var x;
  x = expanding;
  expanding = 0;
  multiply();
  return expanding = x;
};

multiply_all = function(n) {
  var ad, h, i, ref1;
  i = 0;
  if (n === 1) {
    return;
  }
  if (n === 0) {
    push(one);
    return;
  }
  h = tos - n;
  push(stack[h]);
  for (i = ad = 1, ref1 = n; 1 <= ref1 ? ad < ref1 : ad > ref1; i = 1 <= ref1 ? ++ad : --ad) {
    push(stack[h + i]);
    multiply();
  }
  stack[h] = pop();
  return tos = h + 1;
};

multiply_all_noexpand = function(n) {
  var x;
  x = expanding;
  expanding = 0;
  multiply_all(n);
  return expanding = x;
};

divide = function() {
  if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
    return divide_numbers();
  } else {
    inverse();
    return multiply();
  }
};

inverse = function() {
  if (isnum(stack[tos - 1])) {
    return invert_number();
  } else {
    push_integer(-1);
    return power();
  }
};

reciprocate = function() {
  if (isnum(stack[tos - 1])) {
    return invert_number();
  } else {
    push_integer(-1);
    return power();
  }
};

negate = function() {
  if (isnum(stack[tos - 1])) {
    return negate_number();
  } else {
    push_integer(-1);
    return multiply();
  }
};

negate_expand = function() {
  var x;
  x = expanding;
  expanding = 1;
  negate();
  return expanding = x;
};

negate_noexpand = function() {
  var x;
  x = expanding;
  expanding = 0;
  negate();
  return expanding = x;
};

__normalize_radical_factors = function(h) {
  var ad, ae, af, i, ref1, ref2, ref3, ref4, ref5, ref6;
  i = 0;
  if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {
    return;
  }
  for (i = ad = ref1 = h + 1, ref2 = tos; ref1 <= ref2 ? ad < ref2 : ad > ref2; i = ref1 <= ref2 ? ++ad : --ad) {
    if (__is_radical_number(stack[i])) {
      break;
    }
  }
  if (i === tos) {
    return;
  }
  save();
  push(stack[h]);
  mp_numerator();
  p1 = pop();
  for (i = ae = ref3 = h + 1, ref4 = tos; ref3 <= ref4 ? ae < ref4 : ae > ref4; i = ref3 <= ref4 ? ++ae : --ae) {
    if (isplusone(p1) || isminusone(p1)) {
      break;
    }
    if (!__is_radical_number(stack[i])) {
      continue;
    }
    p3 = cadr(stack[i]);
    p4 = caddr(stack[i]);
    if (!isnegativenumber(p4)) {
      continue;
    }
    push(p1);
    push(p3);
    divide();
    p5 = pop();
    if (!isinteger(p5)) {
      continue;
    }
    p1 = p5;
    push_symbol(POWER);
    push(p3);
    push(one);
    push(p4);
    add();
    list(3);
    stack[i] = pop();
  }
  push(stack[h]);
  mp_denominator();
  p2 = pop();
  for (i = af = ref5 = h + 1, ref6 = tos; ref5 <= ref6 ? af < ref6 : af > ref6; i = ref5 <= ref6 ? ++af : --af) {
    if (isplusone(p2)) {
      break;
    }
    if (!__is_radical_number(stack[i])) {
      continue;
    }
    p3 = cadr(stack[i]);
    p4 = caddr(stack[i]);
    if (isnegativenumber(p4)) {
      continue;
    }
    push(p2);
    push(p3);
    divide();
    p5 = pop();
    if (!isinteger(p5)) {
      continue;
    }
    p2 = p5;
    push_symbol(POWER);
    push(p3);
    push(p4);
    push(one);
    subtract();
    list(3);
    stack[i] = pop();
  }
  push(p1);
  push(p2);
  divide();
  stack[h] = pop();
  return restore();
};

__is_radical_number = function(p) {
  if (car(p) === symbol(POWER) && isnum(cadr(p)) && isnum(caddr(p)) && !isminusone(cadr(p))) {
    return 1;
  } else {
    return 0;
  }
};

test_multiply = function() {
  console.log("test_multiply ----------------------------");
  return run_test(["0*a", "0", "a*0", "0", "1*a", "a", "a*1", "a", "a*a", "a^2", "a^2*a", "a^3", "a*a^2", "a^3", "a^2*a^2", "a^4", "2^a*2^(3-a)", "8", "sqrt(2)/2", "2^(-1/2)", "2/sqrt(2)", "2^(1/2)", "-sqrt(2)/2", "-1/(2^(1/2))", "2^(1/2-a)*2^a/10", "1/(5*2^(1/2))", "i/4", "1/4*i", "1/(4 i)", "-1/4*i", "1.0 pi 1/2", "0.5*pi", "1.0 1/2 pi", "0.5*pi"]);
};

NROOTS_YMAX = 101;

NROOTS_DELTA = 1.0e-6;

NROOTS_EPSILON = 1.0e-9;

NROOTS_ABS = function(z) {
  return Math.sqrt(z.r * z.r + z.i * z.i);
};

theRandom = 0.0;

NROOTS_RANDOM = function() {
  return 4.0 * Math.random() - 2.0;
};

numericRootOfPolynomial = (function() {
  function numericRootOfPolynomial() {}

  numericRootOfPolynomial.prototype.r = 0.0;

  numericRootOfPolynomial.prototype.i = 0.0;

  return numericRootOfPolynomial;

})();

nroots_a = new numericRootOfPolynomial();

nroots_b = new numericRootOfPolynomial();

nroots_x = new numericRootOfPolynomial();

nroots_y = new numericRootOfPolynomial();

nroots_fa = new numericRootOfPolynomial();

nroots_fb = new numericRootOfPolynomial();

nroots_dx = new numericRootOfPolynomial();

nroots_df = new numericRootOfPolynomial();

nroots_c = [];

for (initNRoots = ad = 0, ref1 = NROOTS_YMAX; 0 <= ref1 ? ad < ref1 : ad > ref1; initNRoots = 0 <= ref1 ? ++ad : --ad) {
  nroots_c[initNRoots] = new numericRootOfPolynomial();
}

Eval_nroots = function() {
  var ae, af, ag, h, i, k, n, ref2, ref3, ref4;
  h = 0;
  i = 0;
  k = 0;
  n = 0;
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    guess();
  } else {
    push(p2);
  }
  p2 = pop();
  p1 = pop();
  if (!ispoly(p1, p2)) {
    stop("nroots: polynomial?");
  }
  h = tos;
  push(p1);
  push(p2);
  n = coeff();
  if (n > NROOTS_YMAX) {
    stop("nroots: degree?");
  }
  for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    push(stack[h + i]);
    real();
    yyfloat();
    Eval();
    p1 = pop();
    push(stack[h + i]);
    imag();
    yyfloat();
    Eval();
    p2 = pop();
    if (!isdouble(p1) || !isdouble(p2)) {
      stop("nroots: coefficients?");
    }
    nroots_c[i].r = p1.d;
    nroots_c[i].i = p2.d;
  }
  tos = h;
  monic(n);
  for (k = af = ref3 = n; af > 1; k = af += -1) {
    findroot(k);
    if (Math.abs(nroots_a.r) < NROOTS_DELTA) {
      nroots_a.r = 0.0;
    }
    if (Math.abs(nroots_a.i) < NROOTS_DELTA) {
      nroots_a.i = 0.0;
    }
    push_double(nroots_a.r);
    push_double(nroots_a.i);
    push(imaginaryunit);
    multiply();
    add();
    NROOTS_divpoly(k);
  }
  n = tos - h;
  if (n > 1) {
    sort_stack(n);
    p1 = alloc_tensor(n);
    p1.tensor.ndim = 1;
    p1.tensor.dim[0] = n;
    for (i = ag = 0, ref4 = n; 0 <= ref4 ? ag < ref4 : ag > ref4; i = 0 <= ref4 ? ++ag : --ag) {
      p1.tensor.elem[i] = stack[h + i];
    }
    tos = h;
    return push(p1);
  }
};

monic = function(n) {
  var ae, k, ref2, t;
  k = 0;
  t = 0.0;
  nroots_y.r = nroots_c[n - 1].r;
  nroots_y.i = nroots_c[n - 1].i;
  t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;
  for (k = ae = 0, ref2 = n - 1; 0 <= ref2 ? ae < ref2 : ae > ref2; k = 0 <= ref2 ? ++ae : --ae) {
    nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;
    nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;
  }
  nroots_c[n - 1].r = 1.0;
  return nroots_c[n - 1].i = 0.0;
};

findroot = function(n) {
  var ae, af, j, k, nrabs, t;
  j = 0;
  k = 0;
  t = 0.0;
  if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {
    nroots_a.r = 0.0;
    nroots_a.i = 0.0;
    return;
  }
  for (j = ae = 0; ae < 100; j = ++ae) {
    nroots_a.r = NROOTS_RANDOM();
    nroots_a.i = NROOTS_RANDOM();
    compute_fa(n);
    nroots_b.r = nroots_a.r;
    nroots_b.i = nroots_a.i;
    nroots_fb.r = nroots_fa.r;
    nroots_fb.i = nroots_fa.i;
    nroots_a.r = NROOTS_RANDOM();
    nroots_a.i = NROOTS_RANDOM();
    for (k = af = 0; af < 1000; k = ++af) {
      compute_fa(n);
      nrabs = NROOTS_ABS(nroots_fa);
      console.log("nrabs: " + nrabs);
      if (nrabs < NROOTS_EPSILON) {
        return;
      }
      if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {
        nroots_x.r = nroots_a.r;
        nroots_x.i = nroots_a.i;
        nroots_a.r = nroots_b.r;
        nroots_a.i = nroots_b.i;
        nroots_b.r = nroots_x.r;
        nroots_b.i = nroots_x.i;
        nroots_x.r = nroots_fa.r;
        nroots_x.i = nroots_fa.i;
        nroots_fa.r = nroots_fb.r;
        nroots_fa.i = nroots_fb.i;
        nroots_fb.r = nroots_x.r;
        nroots_fb.i = nroots_x.i;
      }
      nroots_dx.r = nroots_b.r - nroots_a.r;
      nroots_dx.i = nroots_b.i - nroots_a.i;
      nroots_df.r = nroots_fb.r - nroots_fa.r;
      nroots_df.i = nroots_fb.i - nroots_fa.i;
      t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;
      if (t === 0.0) {
        break;
      }
      nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;
      nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;
      nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);
      nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);
    }
  }
  return stop("nroots: convergence error");
};

compute_fa = function(n) {
  var ae, k, ref2, results, t;
  k = 0;
  t = 0.0;
  nroots_x.r = nroots_a.r;
  nroots_x.i = nroots_a.i;
  nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;
  nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;
  results = [];
  for (k = ae = 2, ref2 = n; 2 <= ref2 ? ae < ref2 : ae > ref2; k = 2 <= ref2 ? ++ae : --ae) {
    t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;
    nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;
    nroots_x.r = t;
    nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;
    results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);
  }
  return results;
};

NROOTS_divpoly = function(n) {
  var ae, af, k, ref2, ref3, results;
  k = 0;
  for (k = ae = ref2 = n - 1; ref2 <= 0 ? ae < 0 : ae > 0; k = ref2 <= 0 ? ++ae : --ae) {
    nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;
    nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;
  }
  if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {
    stop("nroots: residual error");
  }
  results = [];
  for (k = af = 0, ref3 = n - 1; 0 <= ref3 ? af < ref3 : af > ref3; k = 0 <= ref3 ? ++af : --af) {
    nroots_c[k].r = nroots_c[k + 1].r;
    results.push(nroots_c[k].i = nroots_c[k + 1].i);
  }
  return results;
};

test_nroots = function() {
  return run_test(["nroots(x)", "0", "nroots((1+i)*x^2+1)", "(-0.17178-0.727673*i,0.17178+0.727673*i)", "nroots(sqrt(2)*exp(i*pi/4)*x^2+1)", "(-0.17178-0.727673*i,0.17178+0.727673*i)"]);
};

Eval_numerator = function() {
  push(cadr(p1));
  Eval();
  return numerator();
};

numerator = function() {
  var h;
  h = 0;
  save();
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    push(p1);
    rationalize();
    p1 = pop();
  }
  if (car(p1) === symbol(MULTIPLY)) {
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      numerator();
      p1 = cdr(p1);
    }
    multiply_all(tos - h);
  } else if (isrational(p1)) {
    push(p1);
    mp_numerator();
  } else if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
    push(one);
  } else {
    push(p1);
  }
  return restore();
};

test_numerator = function() {
  return run_test(["numerator(2/3)", "2", "numerator(x)", "x", "numerator(1/x)", "1", "numerator(a+b)", "a+b", "numerator(1/a+1/b)", "a+b"]);
};

strcmp = function(str1, str2) {
  if (str1 === str2) {
    return 0;
  } else if (str1 > str2) {
    return 1;
  } else {
    return -1;
  }
};

doubleToReasonableString = function(d) {
  return parseFloat(d.toPrecision(6));
};

clear_term = function() {};

isspace = function(s) {
  if (s == null) {
    return false;
  }
  return s === ' ' || s === '\t' || s === '\n' || s === '\v' || s === '\f' || s === '\r';
};

isdigit = function(str) {
  if (str == null) {
    return false;
  }
  return /^\d+$/.test(str);
};

isalpha = function(str) {
  if (str == null) {
    return false;
  }
  if (str == null) {
    debugger;
  }
  return str.search(/[^A-Za-z]/) === -1;
};

isalnum = function(str) {
  if (str == null) {
    return false;
  }
  return isalpha(str) || isdigit(str);
};

Eval_outer = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    outer();
    results.push(p1 = cdr(p1));
  }
  return results;
};

outer = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (istensor(p1) && istensor(p2)) {
    yyouter();
  } else {
    push(p1);
    push(p2);
    if (istensor(p1)) {
      tensor_times_scalar();
    } else if (istensor(p2)) {
      scalar_times_tensor();
    } else {
      multiply();
    }
  }
  return restore();
};

yyouter = function() {
  var ae, af, ag, ah, i, j, k, ndim, nelem, ref2, ref3, ref4, ref5;
  i = 0;
  j = 0;
  k = 0;
  ndim = 0;
  nelem = 0;
  ndim = p1.tensor.ndim + p2.tensor.ndim;
  debugger;
  if (ndim > MAXDIM) {
    stop("outer: rank of result exceeds maximum");
  }
  nelem = p1.tensor.nelem * p2.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = ae = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  j = i;
  debugger;
  for (i = af = 0, ref3 = p2.tensor.ndim; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    p3.tensor.dim[j + i] = p2.tensor.dim[i];
  }
  k = 0;
  for (i = ag = 0, ref4 = p1.tensor.nelem; 0 <= ref4 ? ag < ref4 : ag > ref4; i = 0 <= ref4 ? ++ag : --ag) {
    for (j = ah = 0, ref5 = p2.tensor.nelem; 0 <= ref5 ? ah < ref5 : ah > ref5; j = 0 <= ref5 ? ++ah : --ah) {
      push(p1.tensor.elem[i]);
      push(p2.tensor.elem[j]);
      multiply();
      p3.tensor.elem[k++] = pop();
    }
  }
  return push(p3);
};

test_outer = function() {
  return run_test(["outer(a,b)", "a*b", "outer(a,(b1,b2))", "(a*b1,a*b2)", "outer((a1,a2),b)", "(a1*b,a2*b)", "H33=hilbert(3)", "", "H44=hilbert(4)", "", "H55=hilbert(5)", "", "H3344=outer(H33,H44)", "", "H4455=outer(H44,H55)", "", "H33444455=outer(H33,H44,H44,H55)", "", "simplify(inner(H3344,H4455)-contract(H33444455,4,5))", "0"]);
};


/*
 Partition a term

	Input stack:

		term (factor or product of factors)

		free variable

	Output stack:

		constant expression

		variable expression
 */

partition = function() {
  save();
  p2 = pop();
  p1 = pop();
  push_integer(1);
  p3 = pop();
  p4 = p3;
  p1 = cdr(p1);
  while (iscons(p1)) {
    if (Find(car(p1), p2)) {
      push(p4);
      push(car(p1));
      multiply();
      p4 = pop();
    } else {
      push(p3);
      push(car(p1));
      multiply();
      p3 = pop();
    }
    p1 = cdr(p1);
  }
  push(p3);
  push(p4);
  return restore();
};


/*
Convert complex z to polar form

	Input:		push	z

	Output:		Result on stack

	polar(z) = mag(z) * exp(i * arg(z))
 */

Eval_polar = function() {
  push(cadr(p1));
  Eval();
  return polar();
};

polar = function() {
  save();
  p1 = pop();
  push(p1);
  mag();
  push(imaginaryunit);
  push(p1);
  arg();
  multiply();
  exponential();
  multiply();
  return restore();
};

test_polar = function() {
  return run_test(["polar(1+i)", "2^(1/2)*exp(1/4*i*pi)", "polar(-1+i)", "2^(1/2)*exp(3/4*i*pi)", "polar(-1-i)", "2^(1/2)*exp(-3/4*i*pi)", "polar(1-i)", "2^(1/2)*exp(-1/4*i*pi)", "rect(polar(3+4*i))", "3+4*i", "rect(polar(-3+4*i))", "-3+4*i", "rect(polar(3-4*i))", "3-4*i", "rect(polar(-3-4*i))", "-3-4*i"]);
};

n_factor_number = 0;

factor_number = function() {
  var h;
  h = 0;
  save();
  p1 = pop();
  if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {
    push(p1);
    restore();
    return;
  }
  n_factor_number = p1.q.a;
  h = tos;
  factor_a();
  if (tos - h > 1) {
    list(tos - h);
    push_symbol(MULTIPLY);
    swap();
    cons();
  }
  return restore();
};

factor_a = function() {
  var ae, k;
  k = 0;
  if (n_factor_number.isNegative()) {
    n_factor_number = setSignTo(n_factor_number, 1);
    push_integer(-1);
  }
  for (k = ae = 0; ae < 10000; k = ++ae) {
    try_kth_prime(k);
    if (n_factor_number.compare(1) === 0) {
      return;
    }
  }
  return factor_b();
};

try_kth_prime = function(k) {
  var count, d, q, r, ref2;
  count = 0;
  d = mint(primetab[k]);
  count = 0;
  while (1.) {
    if (n_factor_number.compare(1) === 0) {
      if (count) {
        push_factor(d, count);
      }
      return;
    }
    ref2 = mdivrem(n_factor_number, d), q = ref2[0], r = ref2[1];
    if (r.isZero()) {
      count++;
      n_factor_number = q;
    } else {
      break;
    }
  }
  if (count) {
    push_factor(d, count);
  }
  if (mcmp(q, d) === -1) {
    push_factor(n_factor_number, 1);
    return n_factor_number = mint(1);
  }
};

factor_b = function() {
  var bigint_one, g, k, l, t, x, xprime;
  k = 0;
  l = 0;
  bigint_one = mint(1);
  x = mint(5);
  xprime = mint(2);
  k = 1;
  l = 1;
  while (1.) {
    if (mprime(n_factor_number)) {
      push_factor(n_factor_number, 1);
      return 0;
    }
    while (1.) {
      if (esc_flag) {
        stop("esc");
      }
      t = msub(xprime, x);
      t = setSignTo(t, 1);
      g = mgcd(t, n_factor_number);
      if (MEQUAL(g, 1)) {
        if (--k === 0) {
          xprime = x;
          l *= 2;
          k = l;
        }
        t = mmul(x, x);
        x = madd(t, bigint_one);
        t = mmod(x, n_factor_number);
        x = t;
        continue;
      }
      push_factor(g, 1);
      if (mcmp(g, n_factor_number) === 0) {
        return -1;
      }
      t = mdiv(n_factor_number, g);
      n_factor_number = t;
      t = mmod(x, n_factor_number);
      x = t;
      t = mmod(xprime, n_factor_number);
      xprime = t;
      break;
    }
  }
};

push_factor = function(d, count) {
  p1 = new U();
  p1.k = NUM;
  p1.q.a = d;
  p1.q.b = mint(1);
  push(p1);
  if (count > 1) {
    push_symbol(POWER);
    swap();
    p1 = new U();
    p1.k = NUM;
    p1.q.a = mint(count);
    p1.q.b = mint(1);
    push(p1);
    return list(3);
  }
};


/* Power function

	Input:		push	Base

			push	Exponent

	Output:		Result on stack
 */

Eval_power = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return power();
};

power = function() {
  save();
  yypower();
  return restore();
};

yypower = function() {
  var n;
  n = 0;
  p2 = pop();
  p1 = pop();
  if (isrational(p1) && isrational(p2)) {
    push(p1);
    push(p2);
    qpow();
    return;
  }
  if (isnum(p1) && isnum(p2)) {
    push(p1);
    push(p2);
    dpow();
    return;
  }
  if (istensor(p1)) {
    power_tensor();
    return;
  }
  if (p1 === symbol(E) && car(p2) === symbol(LOG)) {
    push(cadr(p2));
    return;
  }
  if (p1 === symbol(E) && isdouble(p2)) {
    push_double(exp(p2.d));
    return;
  }
  if (equal(p1, one) || iszero(p2)) {
    push(one);
    return;
  }
  if (equal(p2, one)) {
    push(p1);
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    push(car(p1));
    push(p2);
    power();
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      power();
      multiply();
      p1 = cdr(p1);
    }
    return;
  }
  if (car(p1) === symbol(POWER)) {
    push(cadr(p1));
    push(caddr(p1));
    push(p2);
    multiply();
    power();
    return;
  }
  if (expanding && isadd(p1) && isnum(p2)) {
    push(p2);
    n = pop_integer();
    if (n > 1 && n !== 0x80000000) {
      power_sum(n);
      return;
    }
  }
  if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {
    push_integer(1);
    push(cadr(p1));
    cosine();
    push_integer(2);
    power();
    subtract();
    push(p2);
    push_rational(1, 2);
    multiply();
    power();
    return;
  }
  if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {
    push_integer(1);
    push(cadr(p1));
    sine();
    push_integer(2);
    power();
    subtract();
    push(p2);
    push_rational(1, 2);
    multiply();
    power();
    return;
  }
  if (iscomplexnumber(p1)) {
    if (isinteger(p2)) {
      push(p1);
      conjugate();
      p3 = pop();
      push(p3);
      push(p3);
      push(p1);
      multiply();
      divide();
      push(p2);
      negate();
      power();
      return;
    }
    if (isnum(p2)) {
      push(p1);
      mag();
      push(p2);
      power();
      push_integer(-1);
      push(p1);
      arg();
      push(p2);
      multiply();
      push(symbol(PI));
      divide();
      power();
      multiply();
      return;

      /*
      			push(p1);
      			mag();
      			push(p2);
      			power();
      			push(symbol(E));
      			push(p1);
      			arg();
      			push(p2);
      			multiply();
      			push(imaginaryunit);
      			multiply();
      			power();
      			multiply();
       */
    }
  }
  if (simplify_polar()) {
    return;
  }
  push_symbol(POWER);
  push(p1);
  push(p2);
  return list(3);
};

power_sum = function(n) {
  var a, ae, af, ag, i, j, k, ref2, ref3, ref4;
  a = [];
  i = 0;
  j = 0;
  k = 0;
  k = length(p1) - 1;
  push_frame(k * (n + 1));
  p1 = cdr(p1);
  for (i = ae = 0, ref2 = k; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    for (j = af = 0, ref3 = n; 0 <= ref3 ? af <= ref3 : af >= ref3; j = 0 <= ref3 ? ++af : --af) {
      push(car(p1));
      push_integer(j);
      power();
      stack[frame + i * (n + 1) + j] = pop();
    }
    p1 = cdr(p1);
  }
  push_integer(n);
  factorial();
  p1 = pop();
  for (i = ag = 0, ref4 = k; 0 <= ref4 ? ag < ref4 : ag > ref4; i = 0 <= ref4 ? ++ag : --ag) {
    a[i] = 0;
  }
  push(zero);
  multinomial_sum(k, n, a, 0, n);
  return pop_frame(k * (n + 1));
};

multinomial_sum = function(k, n, a, i, m) {
  var ae, af, ag, j, ref2, ref3, ref4;
  j = 0;
  if (i < k - 1) {
    for (j = ae = 0, ref2 = m; 0 <= ref2 ? ae <= ref2 : ae >= ref2; j = 0 <= ref2 ? ++ae : --ae) {
      a[i] = j;
      multinomial_sum(k, n, a, i + 1, m - j);
    }
    return;
  }
  a[i] = m;
  push(p1);
  for (j = af = 0, ref3 = k; 0 <= ref3 ? af < ref3 : af > ref3; j = 0 <= ref3 ? ++af : --af) {
    push_integer(a[j]);
    factorial();
    divide();
  }
  for (j = ag = 0, ref4 = k; 0 <= ref4 ? ag < ref4 : ag > ref4; j = 0 <= ref4 ? ++ag : --ag) {
    push(stack[frame + j * (n + 1) + a[j]]);
    multiply();
  }
  return add();
};

simplify_polar = function() {
  var doNothing, n;
  n = 0;
  n = isquarterturn(p2);
  switch (n) {
    case 0:
      doNothing = 1;
      break;
    case 1:
      push_integer(1);
      return 1;
    case 2:
      push_integer(-1);
      return 1;
    case 3:
      push(imaginaryunit);
      return 1;
    case 4:
      push(imaginaryunit);
      negate();
      return 1;
  }
  if (car(p2) === symbol(ADD)) {
    p3 = cdr(p2);
    while (iscons(p3)) {
      n = isquarterturn(car(p3));
      if (n) {
        break;
      }
      p3 = cdr(p3);
    }
    switch (n) {
      case 0:
        return 0;
      case 1:
        push_integer(1);
        break;
      case 2:
        push_integer(-1);
        break;
      case 3:
        push(imaginaryunit);
        break;
      case 4:
        push(imaginaryunit);
        negate();
    }
    push(p2);
    push(car(p3));
    subtract();
    exponential();
    multiply();
    return 1;
  }
  return 0;
};

test_power = function() {
  return run_test(["2^(1/2)", "2^(1/2)", "2^(3/2)", "2*2^(1/2)", "(-2)^(1/2)", "i*2^(1/2)", "3^(4/3)", "3*3^(1/3)", "3^(-4/3)", "1/(3*3^(1/3))", "3^(5/3)", "3*3^(2/3)", "3^(2/3)-9^(1/3)", "0", "3^(10/3)", "27*3^(1/3)", "3^(-10/3)", "1/(27*3^(1/3))", "(1/3)^(10/3)", "1/(27*3^(1/3))", "(1/3)^(-10/3)", "27*3^(1/3)", "27^(2/3)", "9", "27^(-2/3)", "1/9", "102^(1/2)", "2^(1/2)*3^(1/2)*17^(1/2)", "32^(1/3)", "2*2^(2/3)", "9999^(1/2)", "3*11^(1/2)*101^(1/2)", "10000^(1/3)", "10*2^(1/3)*5^(1/3)", "sqrt(1000000)", "1000", "sqrt(-1000000)", "1000*i", "sqrt(2^60)", "1073741824", "6^(1/3) 3^(2/3)", "3*2^(1/3)", "1/(2+3*i)", "2/13-3/13*i", "1/(2+3*i)^2", "-5/169-12/169*i", "(-1+3i)/(2-i)", "-1+i", "(0.0)^(0.0)", "1", "(-4.0)^(1.5)", "-8*i", "(-4.0)^(0.5)", "2*i", "(-4.0)^(-0.5)", "-0.5*i", "(-4.0)^(-1.5)", "0.125*i", "(1+i)^2", "2*i", "(1+i)^(-2)", "-1/2*i", "(1+i)^(1/2)", "(-1)^(1/8)*2^(1/4)", "(1+i)^(-1/2)", "-(-1)^(7/8)/(2^(1/4))", "(1+i)^(0.5)", "1.09868+0.45509*i", "(1+i)^(-0.5)", "0.776887-0.321797*i", "exp(i*pi/2)", "i", "exp(i*pi)", "-1", "exp(i*3*pi/2)", "-i", "exp(i*2*pi)", "1", "exp(i*5*pi/2)", "i", "exp(i*3*pi)", "-1", "exp(i*7*pi/2)", "-i", "exp(i*4*pi)", "1", "exp(A+i*pi/2)", "i*exp(A)", "exp(A+i*pi)", "-exp(A)", "exp(A+i*3*pi/2)", "-i*exp(A)", "exp(A+i*2*pi)", "exp(A)", "exp(A+i*5*pi/2)", "i*exp(A)", "exp(A+i*3*pi)", "-exp(A)", "exp(A+i*7*pi/2)", "-i*exp(A)", "exp(A+i*4*pi)", "exp(A)", "exp(-i*pi/2)", "-i", "exp(-i*pi)", "-1", "exp(-i*3*pi/2)", "i", "exp(-i*2*pi)", "1", "exp(-i*5*pi/2)", "-i", "exp(-i*3*pi)", "-1", "exp(-i*7*pi/2)", "i", "exp(-i*4*pi)", "1", "exp(A-i*pi/2)", "-i*exp(A)", "exp(A-i*pi)", "-exp(A)", "exp(A-i*3*pi/2)", "i*exp(A)", "exp(A-i*2*pi)", "exp(A)", "exp(A-i*5*pi/2)", "-i*exp(A)", "exp(A-i*3*pi)", "-exp(A)", "exp(A-i*7*pi/2)", "i*exp(A)", "exp(A-i*4*pi)", "exp(A)"]);
};

power_str = "^";

stringToBePrinted = "";

print_str = function(s) {
  return stringToBePrinted += s;
};

print_char = function(c) {
  return stringToBePrinted += c;
};

collectResultLine = function(p) {
  stringToBePrinted = "";
  print_expr(p);
  return stringToBePrinted;
};

printline = function(p) {
  debugger;
  stringToBePrinted = "";
  print_expr(p);
  return console.log(stringToBePrinted);
};

print_denom = function(p, d) {
  save();
  p1 = cadr(p);
  p2 = caddr(p);
  if (d === 1 && !isminusone(p2)) {
    print_char('(');
  }
  if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) {
    print_char('(');
    print_expr(p1);
    print_char(')');
  } else {
    print_expr(p1);
  }
  if (isminusone(p2)) {
    restore();
    return;
  }
  if (test_flag === 0) {
    print_str(power_str);
  } else {
    print_char('^');
  }
  push(p2);
  negate();
  p2 = pop();
  if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) {
    print_char('(');
    print_expr(p2);
    print_char(')');
  } else {
    print_expr(p2);
  }
  if (d === 1) {
    print_char(')');
  }
  return restore();
};

print_a_over_b = function(p) {
  var d, doNothing, n;
  flag = 0;
  n = 0;
  d = 0;
  save();
  n = 0;
  d = 0;
  p1 = cdr(p);
  p2 = car(p1);
  if (isrational(p2)) {
    push(p2);
    mp_numerator();
    absval();
    p3 = pop();
    push(p2);
    mp_denominator();
    p4 = pop();
    if (!isplusone(p3)) {
      n++;
    }
    if (!isplusone(p4)) {
      d++;
    }
    p1 = cdr(p1);
  } else {
    p3 = one;
    p4 = one;
  }
  while (iscons(p1)) {
    p2 = car(p1);
    if (is_denominator(p2)) {
      d++;
    } else {
      n++;
    }
    p1 = cdr(p1);
  }
  if (n === 0) {
    print_char('1');
  } else {
    flag = 0;
    p1 = cdr(p);
    if (isrational(car(p1))) {
      p1 = cdr(p1);
    }
    if (!isplusone(p3)) {
      print_factor(p3);
      flag = 1;
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (is_denominator(p2)) {
        doNothing = 1;
      } else {
        if (flag) {
          print_multiply_sign();
        }
        print_factor(p2);
        flag = 1;
      }
      p1 = cdr(p1);
    }
  }
  if (test_flag === 0) {
    print_str(" / ");
  } else {
    print_str("/");
  }
  if (d > 1) {
    print_char('(');
  }
  flag = 0;
  p1 = cdr(p);
  if (isrational(car(p1))) {
    p1 = cdr(p1);
  }
  if (!isplusone(p4)) {
    print_factor(p4);
    flag = 1;
  }
  while (iscons(p1)) {
    p2 = car(p1);
    if (is_denominator(p2)) {
      if (flag) {
        print_multiply_sign();
      }
      print_denom(p2, d);
      flag = 1;
    }
    p1 = cdr(p1);
  }
  if (d > 1) {
    print_char(')');
  }
  return restore();
};

print_expr = function(p) {
  var results;
  if (isadd(p)) {
    p = cdr(p);
    if (sign_of_term(car(p)) === '-') {
      print_str("-");
    }
    print_term(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      if (sign_of_term(car(p)) === '+') {
        if (test_flag === 0) {
          print_str(" + ");
        } else {
          print_str("+");
        }
      } else {
        if (test_flag === 0) {
          print_str(" - ");
        } else {
          print_str("-");
        }
      }
      print_term(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    if (sign_of_term(p) === '-') {
      print_str("-");
    }
    return print_term(p);
  }
};

sign_of_term = function(p) {
  if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && lessp(cadr(p), zero)) {
    return '-';
  } else if (isnum(p) && lessp(p, zero)) {
    return '-';
  } else {
    return '+';
  }
};

print_term = function(p) {
  var results;
  if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {
    print_a_over_b(p);
    return;
  }
  if (car(p) === symbol(MULTIPLY)) {
    p = cdr(p);
    if (isminusone(car(p))) {
      p = cdr(p);
    }
    print_factor(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      print_multiply_sign();
      print_factor(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return print_factor(p);
  }
};

print_subexpr = function(p) {
  print_char('(');
  print_expr(p);
  return print_char(')');
};

print_factorial_function = function(p) {
  p = cadr(p);
  if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {
    print_subexpr(p);
  } else {
    print_expr(p);
  }
  return print_char('!');
};

print_tensor = function(p) {
  return print_tensor_inner(p, 0, 0);
};

print_tensor_inner = function(p, j, k) {
  var ae, i, ref2;
  i = 0;
  print_str("(");
  for (i = ae = 0, ref2 = p.tensor.dim[j]; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    if (j + 1 === p.tensor.ndim) {
      print_expr(p.tensor.elem[k]);
      k++;
    } else {
      k = print_tensor_inner(p, j + 1, k);
    }
    if (i + 1 < p.tensor.dim[j]) {
      if (test_flag === 0) {
        print_str(",");
      } else {
        print_str(",");
      }
    }
  }
  print_str(")");
  return k;
};

print_factor = function(p) {
  if (isnum(p)) {
    print_number(p);
    return;
  }
  if (isstr(p)) {
    print_str(p.str);
    return;
  }
  if (istensor(p)) {
    print_tensor(p);
    return;
  }
  if (isadd(p) || car(p) === symbol(MULTIPLY)) {
    print_str("(");
    print_expr(p);
    print_str(")");
    return;
  }
  if (car(p) === symbol(POWER)) {
    if (cadr(p) === symbol(E)) {
      print_str("exp(");
      print_expr(caddr(p));
      print_str(")");
      return;
    }
    if (isminusone(caddr(p))) {
      if (test_flag === 0) {
        print_str("1 / ");
      } else {
        print_str("1/");
      }
      if (iscons(cadr(p))) {
        print_str("(");
        print_expr(cadr(p));
        print_str(")");
      } else {
        print_expr(cadr(p));
      }
      return;
    }
    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {
      print_str("(");
      print_expr(cadr(p));
      print_str(")");
    } else if (isnum(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {
      print_str("(");
      print_factor(cadr(p));
      print_str(")");
    } else {
      print_factor(cadr(p));
    }
    if (test_flag === 0) {
      print_str(power_str);
    } else {
      print_str("^");
    }
    if (iscons(caddr(p)) || isfraction(caddr(p)) || (isnum(caddr(p)) && lessp(caddr(p), zero))) {
      print_str("(");
      print_expr(caddr(p));
      print_str(")");
    } else {
      print_factor(caddr(p));
    }
    return;
  }
  if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {
    print_index_function(p);
    return;
  }
  if (car(p) === symbol(FACTORIAL)) {
    print_factorial_function(p);
    return;
  }
  if (iscons(p)) {
    print_factor(car(p));
    p = cdr(p);
    print_str("(");
    if (iscons(p)) {
      print_expr(car(p));
      p = cdr(p);
      while (iscons(p)) {
        if (test_flag === 0) {
          print_str(",");
        } else {
          print_str(",");
        }
        print_expr(car(p));
        p = cdr(p);
      }
    }
    print_str(")");
    return;
  }
  if (p === symbol(DERIVATIVE)) {
    return print_char('d');
  } else if (p === symbol(E)) {
    return print_str("exp(1)");
  } else if (p === symbol(PI)) {
    return print_str("pi");
  } else {
    return print_str(get_printname(p));
  }
};

print1 = function(p, accumulator) {
  var topLevelCall;
  topLevelCall = false;
  if (accumulator == null) {
    topLevelCall = true;
    accumulator = "";
  }
  switch (p.k) {
    case CONS:
      accumulator += "(";
      accumulator = print1(car(p), accumulator);
      p = cdr(p);
      while (iscons(p)) {
        accumulator += " ";
        accumulator = print1(car(p), accumulator);
        p = cdr(p);
      }
      if (p !== symbol(NIL)) {
        accumulator += " . ";
        accumulator = print1(p, accumulator);
      }
      accumulator += ")";
      break;
    case STR:
      accumulator += p.str;
      break;
    case NUM:
    case DOUBLE:
      accumulator = print_number(p, accumulator);
      break;
    case SYM:
      accumulator += get_printname(p);
      break;
    default:
      accumulator += "<tensor>";
  }
  if (topLevelCall) {
    return console.log(accumulator);
  } else {
    return accumulator;
  }
};

print_multiply_sign = function() {
  if (test_flag === 0) {
    return print_str(" ");
  } else {
    return print_str("*");
  }
};

is_denominator = function(p) {
  if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

any_denominators = function(p) {
  var q;
  p = cdr(p);
  while (iscons(p)) {
    q = car(p);
    if (is_denominator(q)) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

qadd = function() {
  var a, ab, b, ba, c;
  save();
  p2 = pop();
  p1 = pop();
  ab = mmul(p1.q.a, p2.q.b);
  ba = mmul(p1.q.b, p2.q.a);
  a = madd(ab, ba);
  if (MZERO(a)) {
    push(zero);
    restore();
    return;
  }
  b = mmul(p1.q.b, p2.q.b);
  c = mgcd(a, b);
  c = makeSignSameAs(c, b);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = mdiv(a, c);
  p1.q.b = mdiv(b, c);
  push(p1);
  return restore();
};

qdiv = function() {
  var aa, bb, c;
  save();
  p2 = pop();
  p1 = pop();
  if (MZERO(p2.q.a)) {
    stop("divide by zero");
  }
  if (MZERO(p1.q.a)) {
    push(zero);
    restore();
    return;
  }
  aa = mmul(p1.q.a, p2.q.b);
  bb = mmul(p1.q.b, p2.q.a);
  c = mgcd(aa, bb);
  c = makeSignSameAs(c, bb);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = mdiv(aa, c);
  p1.q.b = mdiv(bb, c);
  push(p1);
  return restore();
};

qmul = function() {
  var aa, bb, c;
  save();
  p2 = pop();
  p1 = pop();
  if (MZERO(p1.q.a) || MZERO(p2.q.a)) {
    push(zero);
    restore();
    return;
  }
  aa = mmul(p1.q.a, p2.q.a);
  bb = mmul(p1.q.b, p2.q.b);
  c = mgcd(aa, bb);
  c = makeSignSameAs(c, bb);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = mdiv(aa, c);
  p1.q.b = mdiv(bb, c);
  push(p1);
  return restore();
};

qpow = function() {
  save();
  qpowf();
  return restore();
};

qpowf = function() {
  var a, b, expo, t, x, y;
  expo = 0;
  p2 = pop();
  p1 = pop();
  if (isplusone(p1) || iszero(p2)) {
    push_integer(1);
    return;
  }
  if (iszero(p1)) {
    if (isnegativenumber(p2)) {
      stop("divide by zero");
    }
    push(zero);
    return;
  }
  if (isplusone(p2)) {
    push(p1);
    return;
  }
  if (isinteger(p2)) {
    push(p2);
    expo = pop_integer();
    if (expo === 0x80000000) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    x = mpow(p1.q.a, Math.abs(expo));
    y = mpow(p1.q.b, Math.abs(expo));
    if (expo < 0) {
      t = x;
      x = y;
      y = t;
      x = makeSignSameAs(x, y);
      y = makePositive(y);
    }
    p3 = new U();
    p3.k = NUM;
    p3.q.a = x;
    p3.q.b = y;
    push(p3);
    return;
  }
  if (isminusone(p1)) {
    push(p2);
    normalize_angle();
    return;
  }
  if (isnegativenumber(p1)) {
    push(p1);
    negate();
    push(p2);
    qpow();
    push_integer(-1);
    push(p2);
    qpow();
    multiply();
    return;
  }
  if (!isinteger(p1)) {
    push(p1);
    mp_numerator();
    push(p2);
    qpow();
    push(p1);
    mp_denominator();
    push(p2);
    negate();
    qpow();
    multiply();
    return;
  }
  if (is_small_integer(p1)) {
    push(p1);
    push(p2);
    quickfactor();
    return;
  }
  if (!p2.q.a.isSmall || !p2.q.b.isSmall) {
    push_symbol(POWER);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  a = p2.q.a;
  b = p2.q.b;
  x = mroot(p1.q.a, b);
  if (x === 0) {
    push_symbol(POWER);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  y = mpow(x, a);
  p3 = new U();
  p3.k = NUM;
  if (p2.q.a.isNegative()) {
    p3.q.a = bigInt(1);
    p3.q.b = y;
  } else {
    p3.q.a = y;
    p3.q.b = bigInt(1);
  }
  return push(p3);
};

normalize_angle = function() {
  save();
  p1 = pop();
  if (isinteger(p1)) {
    if (p1.q.a.isOdd()) {
      push_integer(-1);
    } else {
      push_integer(1);
    }
    restore();
    return;
  }
  push(p1);
  bignum_truncate();
  p2 = pop();
  if (isnegativenumber(p1)) {
    push(p2);
    push_integer(-1);
    add();
    p2 = pop();
  }
  push(p1);
  push(p2);
  subtract();
  p3 = pop();
  push_symbol(POWER);
  push_integer(-1);
  push(p3);
  list(3);
  if (p2.q.a.isOdd()) {
    negate();
  }
  return restore();
};

is_small_integer = function(p) {
  return p.q.a.isSmall;
};

quickfactor = function() {
  var ae, h, i, n, ref2, stackIndex;
  i = 0;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  push(p1);
  factor_small_number();
  n = tos - h;
  stackIndex = h;
  for (i = ae = 0, ref2 = n; ae < ref2; i = ae += 2) {
    push(stack[stackIndex + i]);
    push(stack[stackIndex + i + 1]);
    push(p2);
    multiply();
    quickpower();
  }
  multiply_all(tos - h - n);
  p1 = pop();
  tos = h;
  push(p1);
  return restore();
};

quickpower = function() {
  var expo;
  expo = 0;
  save();
  p2 = pop();
  p1 = pop();
  push(p2);
  bignum_truncate();
  p3 = pop();
  push(p2);
  push(p3);
  subtract();
  p4 = pop();
  if (!iszero(p4)) {
    push_symbol(POWER);
    push(p1);
    push(p4);
    list(3);
  }
  push(p3);
  expo = pop_integer();
  if (expo === 0x80000000) {
    push_symbol(POWER);
    push(p1);
    push(p3);
    list(3);
    restore();
    return;
  }
  if (expo === 0) {
    restore();
    return;
  }
  push(p1);
  bignum_power_number(expo);
  return restore();
};

test_quickfactor = function() {
  var ae, base, expo, h, i, j;
  i = 0;
  logout("testing quickfactor\n");
  for (i = ae = 2; ae < 10001; i = ++ae) {
    if (i % 1000 === 0) {
      alert(i);
    }
    base = i;
    push_integer(base);
    push_integer(1);
    quickfactor();
    h = tos;
    j = 0;
    while (base > 1) {
      expo = 0;
      while (base % primetab[j] === 0) {
        base /= primetab[j];
        expo++;
      }
      if (expo) {
        push_integer(primetab[j]);
        push_integer(expo);
        quickpower();
      }
      j++;
    }
    multiply_all(tos - h);
    p2 = pop();
    p1 = pop();
    if (!equal(p1, p2)) {
      logout("failed\n");
      print_lisp(p1);
      print_lisp(p2);
      errout();
    }
  }
  alert("quickfactor is ok");
  return logout("ok\n");
};

Eval_quotient = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadddr(p1));
  Eval();
  p1 = pop();
  if (p1 === symbol(NIL)) {
    p1 = symbol(SYMBOL_X);
  }
  push(p1);
  return divpoly();
};

divpoly = function() {
  var ae, dividend, divisor, h, i, m, n, ref2, x;
  h = 0;
  i = 0;
  m = 0;
  n = 0;
  x = 0;
  save();
  p3 = pop();
  p2 = pop();
  p1 = pop();
  h = tos;
  dividend = tos;
  push(p1);
  push(p3);
  m = coeff() - 1;
  divisor = tos;
  push(p2);
  push(p3);
  n = coeff() - 1;
  x = m - n;
  push_integer(0);
  p5 = pop();
  while (x >= 0) {
    push(stack[dividend + m]);
    push(stack[divisor + n]);
    divide();
    p4 = pop();
    for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae <= ref2 : ae >= ref2; i = 0 <= ref2 ? ++ae : --ae) {
      push(stack[dividend + x + i]);
      push(stack[divisor + i]);
      push(p4);
      multiply();
      subtract();
      stack[dividend + x + i] = pop();
    }
    push(p5);
    push(p4);
    push(p3);
    push_integer(x);
    power();
    multiply();
    add();
    p5 = pop();
    m--;
    x--;
  }
  tos = h;
  push(p5);
  return restore();
};

test_quotient = function() {
  return run_test(["quotient(x^2+1,x+1)-x+1", "0", "quotient(a*x^2+b*x+c,d*x+e)-(-a*e/(d^2)+a*x/d+b/d)", "0"]);
};

DEBUG = 0;

Eval_rationalize = function() {
  push(cadr(p1));
  Eval();
  return rationalize();
};

rationalize = function() {
  var x;
  x = expanding;
  save();
  yyrationalize();
  restore();
  return expanding = x;
};

yyrationalize = function() {
  p1 = pop();
  if (istensor(p1)) {
    __rationalize_tensor();
    return;
  }
  expanding = 0;
  if (car(p1) !== symbol(ADD)) {
    push(p1);
    return;
  }
  if (DEBUG) {
    printf("rationalize: this is the input expr:\n");
    printline(p1);
  }
  push(one);
  multiply_denominators(p1);
  p2 = pop();
  if (DEBUG) {
    printf("rationalize: this is the common denominator:\n");
    printline(p2);
  }
  push(zero);
  p3 = cdr(p1);
  while (iscons(p3)) {
    push(p2);
    push(car(p3));
    multiply();
    add();
    p3 = cdr(p3);
  }
  if (DEBUG) {
    printf("rationalize: original expr times common denominator:\n");
    printline(stack[tos - 1]);
  }
  Condense();
  if (DEBUG) {
    printf("rationalize: after factoring:\n");
    printline(stack[tos - 1]);
  }
  push(p2);
  divide();
  if (DEBUG) {
    printf("rationalize: after dividing by common denom. (and we're done):\n");
    return printline(stack[tos - 1]);
  }
};

multiply_denominators = function(p) {
  var results;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      multiply_denominators_term(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return multiply_denominators_term(p);
  }
};

multiply_denominators_term = function(p) {
  var results;
  if (car(p) === symbol(MULTIPLY)) {
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      multiply_denominators_factor(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return multiply_denominators_factor(p);
  }
};

multiply_denominators_factor = function(p) {
  if (car(p) !== symbol(POWER)) {
    return;
  }
  push(p);
  p = caddr(p);
  if (isnegativenumber(p)) {
    inverse();
    __lcm();
    return;
  }
  if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
    inverse();
    __lcm();
    return;
  }
  return pop();
};

__rationalize_tensor = function() {
  var ae, i, n, ref2;
  i = 0;
  push(p1);
  Eval();
  p1 = pop();
  if (!istensor(p1)) {
    push(p1);
    return;
  }
  n = p1.tensor.nelem;
  for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    push(p1.tensor.elem[i]);
    rationalize();
    p1.tensor.elem[i] = pop();
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  return push(p1);
};

test_rationalize = function() {
  return run_test(["rationalize(a/b+c/d)", "(a*d+b*c)/(b*d)", "rationalize(t*y/(t+y)+2*t^2*y*(2*t+y)^(-2))", "t*y*(6*t^2+y^2+6*t*y)/((t+y)*(2*t+y)^2)", "rationalize(x^(-2*a)+x^(-4*a))", "(1+x^(2*a))/(x^(4*a))", "rationalize(x^(1/3)+x^(2/3))", "x^(1/3)*(1+x^(1/3))"]);
};

__lcm = function() {
  save();
  p1 = pop();
  p2 = pop();
  push(p1);
  push(p2);
  multiply();
  push(p1);
  push(p2);
  gcd();
  divide();
  return restore();
};


/*
 Returns the real part of complex z

	z		real(z)
	-		-------

	a + i b		a

	exp(i a)	cos(a)
 */

Eval_real = function() {
  push(cadr(p1));
  Eval();
  return real();
};

real = function() {
  save();
  rect();
  p1 = pop();
  push(p1);
  push(p1);
  conjugate();
  add();
  push_integer(2);
  divide();
  return restore();
};

test_real = function() {
  return run_test(["real(a+i*b)", "a", "real(1+exp(i*pi/3))", "3/2", "real(i)", "0", "real((-1)^(1/3))", "1/2"]);
};


/*
Convert complex z to rectangular form

	Input:		push	z

	Output:		Result on stack
 */

Eval_rect = function() {
  push(cadr(p1));
  Eval();
  return rect();
};

rect = function() {
  save();
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    push_integer(0);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      rect();
      add();
      p1 = cdr(p1);
    }
  } else {
    push(p1);
    mag();
    push(p1);
    arg();
    p1 = pop();
    push(p1);
    cosine();
    push(imaginaryunit);
    push(p1);
    sine();
    multiply();
    add();
    multiply();
  }
  return restore();
};

test_rect = function() {
  return run_test(["rect(a+i*b)", "a+i*b", "rect(exp(a+i*b))", "i*exp(a)*sin(b)+exp(a)*cos(b)", "rect(1+exp(i*pi/3))", "3/2+1/2*i*3^(1/2)", "z=(a+b*i)/(c+d*i)", "", "rect(z)-real(z)-i*imag(z)", "0", "z=quote(z)", ""]);
};

stop = function(s) {
  errorMessage += "Stop: ";
  errorMessage += s;
  throw new Error(errorMessage);
};

inited = false;

run = function(stringToBeRun) {
  var allReturnedStrings, collectedResult, error, error1, i, indexOfPartRemainingToBeParsed, n;
  stringToBeRun = stringToBeRun;
  if (stringToBeRun === "selftest") {
    selftest();
    return;
  }
  if (!inited) {
    inited = true;
    init();
  }
  i = 0;
  n = 0;
  indexOfPartRemainingToBeParsed = 0;
  allReturnedStrings = "";
  while (1.) {
    try {
      errorMessage = "";
      check_stack();
      n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));
      p1 = pop();
      check_stack();
    } catch (error1) {
      error = error1;
      console.log(error);
      debugger;
      allReturnedStrings += error.message;
      init();
      break;
    }
    if (n === 0) {
      break;
    }
    indexOfPartRemainingToBeParsed += n;
    push(p1);
    top_level_eval();
    p2 = pop();
    check_stack();
    if (p2 === symbol(NIL)) {
      continue;
    }
    if (isstr(p2)) {
      console.log(p2.str);
      console.log("\n");
      continue;
    }
    console.log("printline");
    collectedResult = collectResultLine(p2);
    allReturnedStrings += collectedResult;
    console.log(collectedResult);
    console.log("display:");
    display(p2);
    allReturnedStrings += "\n";
  }
  if (allReturnedStrings[allReturnedStrings.length - 1] === "\n") {
    allReturnedStrings = allReturnedStrings.substring(0, allReturnedStrings.length - 1);
  }
  return allReturnedStrings;
};

check_stack = function() {
  if (tos !== 0) {
    debugger;
    stop("stack error");
  }
  if (frame !== TOS) {
    debugger;
    return stop("frame error");
  }
};

echo_input = function(s) {
  console.log(s);
  return console.log("\n");
};

top_level_eval = function() {
  var doNothing;
  console.log("#### top level eval");
  save();
  trigmode = 0;
  p1 = symbol(AUTOEXPAND);
  if (iszero(get_binding(p1))) {
    expanding = 0;
  } else {
    expanding = 1;
  }
  p1 = pop();
  push(p1);
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    push(p2);
    restore();
    return;
  }
  set_binding(symbol(LAST), p2);
  if (!iszero(get_binding(symbol(BAKE)))) {
    push(p2);
    bake();
    p2 = pop();
  }
  if ((p1 === symbol(SYMBOL_I) || p1 === symbol(SYMBOL_J)) && isimaginaryunit(p2)) {
    doNothing = 0;
  } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {
    push(p2);
    push(imaginaryunit);
    push_symbol(SYMBOL_J);
    subst();
    p2 = pop();
  } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {
    push(p2);
    push(imaginaryunit);
    push_symbol(SYMBOL_I);
    subst();
    p2 = pop();
  }
  push(p2);
  return restore();
};

check_esc_flag = function() {
  if (esc_flag) {
    return stop("esc key");
  }
};

T_INTEGER = 1001;

T_DOUBLE = 1002;

T_SYMBOL = 1003;

T_FUNCTION = 1004;

T_NEWLINE = 1006;

T_STRING = 1007;

T_GTEQ = 1008;

T_LTEQ = 1009;

T_EQ = 1010;

token = "";

newline_flag = 0;

meta_mode = 0;

input_str = 0;

scan_str = 0;

token_str = 0;

token_buf = 0;

scanned = "";

scan = function(s) {
  console.log("#### scanning " + s);
  scanned = s;
  meta_mode = 0;
  expanding++;
  input_str = 0;
  scan_str = 0;
  get_next_token();
  if (token === "") {
    push(symbol(NIL));
    expanding--;
    return 0;
  }
  scan_stmt();
  expanding--;
  return token_str - input_str;
};

scan_meta = function(s) {
  scanned = s;
  meta_mode = 1;
  expanding++;
  input_str = 0;
  scan_str = 0;
  get_next_token();
  if (token === "") {
    push(symbol(NIL));
    expanding--;
    return 0;
  }
  scan_stmt();
  expanding--;
  return token_str - input_str;
};

scan_stmt = function() {
  scan_relation();
  if (token === '=') {
    get_next_token();
    push_symbol(SETQ);
    swap();
    scan_relation();
    return list(3);
  }
};

scan_relation = function() {
  scan_expression();
  switch (token) {
    case T_EQ:
      push_symbol(TESTEQ);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case T_LTEQ:
      push_symbol(TESTLE);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case T_GTEQ:
      push_symbol(TESTGE);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case '<':
      push_symbol(TESTLT);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case '>':
      push_symbol(TESTGT);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
  }
};

scan_expression = function() {
  var h;
  h = tos;
  switch (token) {
    case '+':
      get_next_token();
      scan_term();
      break;
    case '-':
      get_next_token();
      scan_term();
      negate();
      break;
    default:
      scan_term();
  }
  while (newline_flag === 0 && (token === '+' || token === '-')) {
    if (token === '+') {
      get_next_token();
      scan_term();
    } else {
      get_next_token();
      scan_term();
      negate();
    }
  }
  if (tos - h > 1) {
    list(tos - h);
    push_symbol(ADD);
    swap();
    return cons();
  }
};

is_factor = function() {
  switch (token) {
    case '*':
    case '/':
      return 1;
    case '(':
    case T_SYMBOL:
    case T_FUNCTION:
    case T_INTEGER:
    case T_DOUBLE:
    case T_STRING:
      if (newline_flag) {
        scan_str = token_str;
        return 0;
      } else {
        return 1;
      }
  }
  return 0;
};

scan_term = function() {
  var h;
  h = tos;
  scan_power();
  if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
    pop();
  }
  while (is_factor()) {
    if (token === '*') {
      get_next_token();
      scan_power();
    } else if (token === '/') {
      get_next_token();
      scan_power();
      inverse();
    } else {
      scan_power();
    }
    if (tos > h + 1 && isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      multiply();
    }
    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
      pop();
    }
  }
  if (h === tos) {
    return push_integer(1);
  } else if (tos - h > 1) {
    list(tos - h);
    push_symbol(MULTIPLY);
    swap();
    return cons();
  }
};

scan_power = function() {
  scan_factor();
  if (token === '^') {
    get_next_token();
    push_symbol(POWER);
    swap();
    scan_power();
    return list(3);
  }
};

scan_factor = function() {
  var h, results;
  h = tos;
  if (token === '(') {
    scan_subexpr();
  } else if (token === T_SYMBOL) {
    scan_symbol();
  } else if (token === T_FUNCTION) {
    scan_function_call();
  } else if (token === T_INTEGER) {
    bignum_scan_integer(token_buf);
    get_next_token();
  } else if (token === T_DOUBLE) {
    bignum_scan_float(token_buf);
    get_next_token();
  } else if (token === T_STRING) {
    scan_string();
  } else {
    error("syntax error");
  }
  if (token === '[') {
    get_next_token();
    push_symbol(INDEX);
    swap();
    scan_expression();
    while (token === ',') {
      get_next_token();
      scan_expression();
    }
    if (token !== ']') {
      error("] expected");
    }
    get_next_token();
    list(tos - h);
  }
  results = [];
  while (token === '!') {
    get_next_token();
    push_symbol(FACTORIAL);
    swap();
    results.push(list(2));
  }
  return results;
};

scan_symbol = function() {
  if (token !== T_SYMBOL) {
    error("symbol expected");
  }
  if (meta_mode && token_buf.length === 1) {
    switch (token_buf[0]) {
      case 'a':
        push(symbol(METAA));
        break;
      case 'b':
        push(symbol(METAB));
        break;
      case 'x':
        push(symbol(METAX));
        break;
      default:
        push(usr_symbol(token_buf));
    }
  } else {
    push(usr_symbol(token_buf));
  }
  return get_next_token();
};

scan_string = function() {
  new_string(token_buf);
  return get_next_token();
};

scan_function_call = function() {
  var n, p;
  n = 1;
  p = new U();
  p = usr_symbol(token_buf);
  push(p);
  get_next_token();
  get_next_token();
  if (token !== ')') {
    scan_stmt();
    n++;
    while (token === ',') {
      get_next_token();
      scan_stmt();
      n++;
    }
  }
  if (token !== ')') {
    error(") expected");
  }
  get_next_token();
  return list(n);
};

scan_subexpr = function() {
  var n;
  n = 0;
  if (token !== '(') {
    error("( expected");
  }
  get_next_token();
  scan_stmt();
  if (token === ',') {
    n = 1;
    while (token === ',') {
      get_next_token();
      scan_stmt();
      n++;
    }
    build_tensor(n);
  }
  if (token !== ')') {
    error(") expected");
  }
  return get_next_token();
};

error = function(errmsg) {
  errorMessage = "";
  while (input_str !== scan_str) {
    if ((scanned[input_str] === '\n' || scanned[input_str] === '\r') && input_str + 1 === scan_str) {
      break;
    }
    errorMessage += scanned[input_str++];
  }
  errorMessage += " ? ";
  while (scanned[input_str] && (scanned[input_str] !== '\n' && scanned[input_str] !== '\r')) {
    errorMessage += scanned[input_str++];
  }
  errorMessage += '\n';
  return stop(errmsg);
};

build_tensor = function(n) {
  var ae, i, ref2;
  i = 0;
  save();
  p2 = alloc_tensor(n);
  p2.tensor.ndim = 1;
  p2.tensor.dim[0] = n;
  for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p2.tensor.elem[i] = stack[tos - n + i];
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  tos -= n;
  push(p2);
  return restore();
};

get_next_token = function() {
  newline_flag = 0;
  while (1.) {
    get_token();
    if (token !== T_NEWLINE) {
      break;
    }
    newline_flag = 1;
  }
  return console.log("get_next_token token: " + token);
};

get_token = function() {
  while (isspace(scanned[scan_str])) {
    if (scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
      token = T_NEWLINE;
      scan_str++;
      return;
    }
    scan_str++;
  }
  token_str = scan_str;
  if (scan_str === scanned.length) {
    token = "";
    return;
  }
  if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {
    while (isdigit(scanned[scan_str])) {
      scan_str++;
    }
    if (scanned[scan_str] === '.') {
      scan_str++;
      while (isdigit(scanned[scan_str])) {
        scan_str++;
      }
      if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {
        scan_str += 2;
        while (isdigit(scanned[scan_str])) {
          scan_str++;
        }
      }
      token = T_DOUBLE;
    } else {
      token = T_INTEGER;
    }
    update_token_buf(token_str, scan_str);
    return;
  }
  if (isalpha(scanned[scan_str])) {
    while (isalnum(scanned[scan_str])) {
      scan_str++;
    }
    if (scanned[scan_str] === '(') {
      token = T_FUNCTION;
    } else {
      token = T_SYMBOL;
    }
    update_token_buf(token_str, scan_str);
    return;
  }
  if (scanned[scan_str] === '"') {
    scan_str++;
    while (scanned[scan_str] !== '"') {
      if (scan_str === scanned.length || scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
        error("runaway string");
      }
      scan_str++;
    }
    scan_str++;
    token = T_STRING;
    update_token_buf(token_str + 1, scan_str - 1);
    return;
  }
  if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {
    while (scanned[scan_str] && scanned[scan_str] !== '\n' && scanned[scan_str] !== '\r') {
      scan_str++;
    }
    if (scanned[scan_str]) {
      scan_str++;
    }
    token = T_NEWLINE;
    return;
  }
  if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {
    scan_str += 2;
    token = T_EQ;
    return;
  }
  if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {
    scan_str += 2;
    token = T_LTEQ;
    return;
  }
  if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {
    scan_str += 2;
    token = T_GTEQ;
    return;
  }
  return token = scanned[scan_str++];
};

update_token_buf = function(a, b) {
  return token_buf = scanned.substring(a, b);
};

test_scan = function() {
  console.log("test_scan ----------------------------");
  return run_test(["a^^b", "a^^ ? b\nStop: syntax error", "(a+b", "(a+b ? \nStop: ) expected", "quote(1/(x*log(a*x)))", "1/(x*log(a*x))", "\"hello", "\"hello ? \nStop: runaway string", "a+\nb+\nc+", "a+\nb+\nc+ ? \nStop: syntax error", "2+2\n(3+3)", "4\n6", "1\n-1", "1\n-1", "1\n+1", "1\n1"]);
};

ok_tests = 0;

ko_tests = 0;

selftest = function() {
  test_low_level();

  /*
  	test_multiply();
  	test_scan();
  	test_power();
  	test_factor_number(); # long
  	test_test();
  	test_tensor();
  	test_bake();
  	test_abs();
  	test_adj();
  	test_arg();
  	test_besselj();
  	test_bessely();
  	test_ceiling();
  	test_choose();
  	test_circexp();
  	test_clock();
  	test_cofactor();
  	test_condense();
  	test_contract();
  	test_defint(); # very long
  	test_denominator();
  	test_derivative();
  	test_dirac();
  	test_erf();
  	test_erfc();
  	test_expand();
  	test_expcos();
  	test_expsin();
  	test_factorpoly();
  	test_float();
  	test_floor();
  	test_gamma();
  	test_gcd();
  	test_imag();
  	test_inner();
  	test_lcm();
  	test_log();
  	test_mag();
  	test_mod();
  	test_nroots();
  	test_numerator();
  	test_outer();
  	test_polar();
  	test_quotient();
  	test_rationalize();
  	test_real();
  	test_rect();
  	test_sgn();
  	test_taylor();
  	test_transpose();
  	test_zero();
  	test_hermite();
  	test_laguerre();
  	test_legendre();
  	test_binomial();
  	test_divisors();
  	test_coeff();
  	test_sin();
  	test_cos();
  	test_tan();
  	test_sinh();
  	test_cosh();
  	test_tanh();
   */
  test_arcsin();
  alert("ok tests: " + ok_tests + " , ko tests: " + ko_tests);
  return;
  test_arcsinh();
  test_arccos();
  test_arccosh();
  test_arctan();
  test_arctanh();
  test_index();
  test_isprime();
  test_integral();
  test_simplify();
  test_roots();
  test_eigen();
  mini_test();
  return console.log("OK, all tests passed.");
};

logout = function(s) {
  return console.log(s);
};

run_test = function(s) {
  var ae, i, ref2, resultFromRun, t;
  i = 0;
  t = "";
  test_flag = 1;
  run("clear");
  run("e=quote(e)");
  for (i = ae = 0, ref2 = s.length; ae < ref2; i = ae += 2) {
    console.log("starting example: " + s[i]);
    out_count = 0;
    resultFromRun = run(s[i]);
    if (resultFromRun === s[i + 1]) {
      console.log("ok example: " + s[i]);
      ok_tests++;
      continue;
    }
    ko_tests++;
    console.log("expected to get the following result:\n");
    console.log(s[i + 1]);
    console.log("got this result instead:\n");
    console.log(resultFromRun);
  }
  return test_flag = 0;
};

test_low_level = function() {
  run("clear");
  test_signs_in_rationals();
  test_madd();
  test_msub();
  test_mmul();
  test_mdiv();
  test_mmod();
  test_mprime();
  test_mgcd();
  test_mpow();
  return test_mroot();
};

Eval_sgn = function() {
  push(cadr(p1));
  Eval();
  return sgn();
};

sgn = function() {
  save();
  yysgn();
  return restore();
};

yysgn = function() {
  p1 = pop();
  if (isdouble(p1)) {
    if (p1.d > 0) {
      push_integer(1);
      return;
    } else {
      if (p1.d === 0) {
        push_integer(1);
        return;
      } else {
        push_integer(-1);
        return;
      }
    }
  }
  if (isrational(p1)) {
    if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {
      push_integer(-1);
      return;
    } else {
      if (MZERO(mmul(p1.q.a, p1.q.b))) {
        push_integer(0);
        return;
      } else {
        push_integer(1);
        return;
      }
    }
  }
  if (iscomplexnumber(p1)) {
    push_integer(-1);
    push(p1);
    absval();
    power();
    push(p1);
    multiply();
    return;
  }
  if (isnegativeterm(p1)) {
    push_symbol(SGN);
    push(p1);
    negate();
    list(2);
    push_integer(-1);
    multiply();
    return;
  }

  /*
  	push_integer(2);
  	push(p1);
  	heaviside();
  	multiply();
  	push_integer(-1);
  	add();
   */
  push_symbol(SGN);
  push(p1);
  return list(2);
};

test_sgn = function() {
  return run_test(["sgn(-3)", "-1", "sgn(0)", "0", "sgn(3)", "1"]);
};

Eval_simplify = function() {
  push(cadr(p1));
  Eval();
  return simplify();
};

simplify = function() {
  save();
  simplify_main();
  return restore();
};

simplify_main = function() {
  p1 = pop();
  if (istensor(p1)) {
    simplify_tensor();
    return;
  }
  if (Find(p1, symbol(FACTORIAL))) {
    push(p1);
    simfac();
    p2 = pop();
    push(p1);
    rationalize();
    simfac();
    p3 = pop();
    if (count(p2) < count(p3)) {
      p1 = p2;
    } else {
      p1 = p3;
    }
  }
  f1();
  f2();
  f3();
  f4();
  f5();
  f9();
  return push(p1);
};

simplify_tensor = function() {
  var ae, af, i, ref2, ref3;
  i = 0;
  p2 = alloc_tensor(p1.tensor.nelem);
  p2.tensor.ndim = p1.tensor.ndim;
  for (i = ae = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p2.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (i = af = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    push(p1.tensor.elem[i]);
    simplify();
    p2.tensor.elem[i] = pop();
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (iszero(p2)) {
    p2 = zero;
  }
  return push(p2);
};

count = function(p) {
  var n;
  if (iscons(p)) {
    n = 0;
    while (iscons(p)) {
      n += count(car(p)) + 1;
      p = cdr(p);
    }
  } else {
    n = 1;
  }
  return n;
};

f1 = function() {
  if (car(p1) !== symbol(ADD)) {
    return;
  }
  push(p1);
  rationalize();
  p2 = pop();
  if (count(p2) < count(p1)) {
    return p1 = p2;
  }
};

f2 = function() {
  if (car(p1) !== symbol(ADD)) {
    return;
  }
  push(p1);
  Condense();
  p2 = pop();
  if (count(p2) <= count(p1)) {
    return p1 = p2;
  }
};

f3 = function() {
  push(p1);
  rationalize();
  negate();
  rationalize();
  negate();
  rationalize();
  p2 = pop();
  if (count(p2) < count(p1)) {
    return p1 = p2;
  }
};

f4 = function() {
  if (iszero(p1)) {
    return;
  }
  push(p1);
  rationalize();
  inverse();
  rationalize();
  inverse();
  rationalize();
  p2 = pop();
  if (count(p2) < count(p1)) {
    return p1 = p2;
  }
};

simplify_trig = function() {
  save();
  p1 = pop();
  f5();
  push(p1);
  return restore();
};

f5 = function() {
  if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {
    return;
  }
  p2 = p1;
  trigmode = 1;
  push(p2);
  Eval();
  p3 = pop();
  trigmode = 2;
  push(p2);
  Eval();
  p4 = pop();
  trigmode = 0;
  if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {
    p3 = p4;
  }
  if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {
    return p1 = p3;
  }
};

f9 = function() {
  if (car(p1) !== symbol(ADD)) {
    return;
  }
  push_integer(0);
  p2 = cdr(p1);
  while (iscons(p2)) {
    push(car(p2));
    simplify();
    add();
    p2 = cdr(p2);
  }
  p2 = pop();
  if (count(p2) < count(p1)) {
    return p1 = p2;
  }
};

nterms = function(p) {
  if (car(p) !== symbol(ADD)) {
    return 1;
  } else {
    return length(p) - 1;
  }
};

s = ["simplify(A)", "A", "simplify(A+B)", "A+B", "simplify(A B)", "A*B", "simplify(A^B)", "A^B", "simplify(A/(A+B)+B/(A+B))", "1", "simplify((A-B)/(B-A))", "-1", "A=((A11,A12),(A21,A22))", "", "simplify(det(A) inv(A) - adj(A))", "0", "A=quote(A)", "", "simplify(-3 exp(-1/3 r + i phi) cos(theta) / sin(theta)", " + 3 exp(-1/3 r + i phi) cos(theta) sin(theta)", " + 3 exp(-1/3 r + i phi) cos(theta)^3 / sin(theta))", "0", "simplify((A^2 C^2 + A^2 D^2 + B^2 C^2 + B^2 D^2)/(A^2+B^2)/(C^2+D^2))", "1", "simplify(d(arctan(y/x),y))", "x/(x^2+y^2)", "simplify(d(arctan(y/x),x))", "-y/(x^2+y^2)", "simplify(1-sin(x)^2)", "cos(x)^2", "simplify(1-cos(x)^2)", "sin(x)^2", "simplify(sin(x)^2-1)", "-cos(x)^2", "simplify(cos(x)^2-1)", "-sin(x)^2", "simplify(n!/n)-(n-1)!", "0", "simplify(n/n!)-1/(n-1)!", "0", "simplify(rationalize((n+k+1)/(n+k+1)!))-1/(n+k)!", "0", "simplify(condense((n+1)*n!))-(n+1)!", "0", "simplify(1/((n+1)*n!))-1/(n+1)!", "0", "simplify((n+1)!/n!)-n-1", "0", "simplify(n!/(n+1)!)-1/(n+1)", "0", "simplify(binomial(n+1,k)/binomial(n,k))", "(1+n)/(1-k+n)", "simplify(binomial(n,k)/binomial(n+1,k))", "(1-k+n)/(1+n)", "F(nn,kk)=kk*binomial(nn,kk)", "", "simplify((F(n,k)+F(n,k-1))/F(n+1,k))-n/(n+1)", "0", "F=quote(F)", "", "simplify((n+1)/(n+1)!)-1/n!", "0", "simplify(a*b+a*c)", "a*(b+c)", "x=simplify(a*b+a*c)", "", "x", "a*b+a*c"];


/*
void
test_simplify(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

Eval_sin = function() {
  push(cadr(p1));
  Eval();
  return sine();
};

sine = function() {
  save();
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    sine_of_angle_sum();
  } else {
    sine_of_angle();
  }
  return restore();
};

sine_of_angle_sum = function() {
  p2 = cdr(p1);
  while (iscons(p2)) {
    p4 = car(p2);
    if (isnpi(p4)) {
      push(p1);
      push(p4);
      subtract();
      p3 = pop();
      push(p3);
      sine();
      push(p4);
      cosine();
      multiply();
      push(p3);
      cosine();
      push(p4);
      sine();
      multiply();
      add();
      return;
    }
    p2 = cdr(p2);
  }
  return sine_of_angle();
};

sine_of_angle = function() {
  var d, n;
  if (car(p1) === symbol(ARCSIN)) {
    push(cadr(p1));
    return;
  }
  if (isdouble(p1)) {
    d = Math.sin(p1.d);
    if (Math.abs(d) < 1e-10) {
      d = 0.0;
    }
    push_double(d);
    return;
  }
  if (isnegative(p1)) {
    push(p1);
    negate();
    sine();
    negate();
    return;
  }
  if (car(p1) === symbol(ARCTAN)) {
    push(cadr(p1));
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    add();
    push_rational(-1, 2);
    power();
    multiply();
    return;
  }
  push(p1);
  push_integer(180);
  multiply();
  push_symbol(PI);
  divide();
  n = pop_integer();
  if (n < 0 || n === 0x80000000) {
    push(symbol(SIN));
    push(p1);
    list(2);
    return;
  }
  switch (n % 360) {
    case 0:
    case 180:
      return push_integer(0);
    case 30:
    case 150:
      return push_rational(1, 2);
    case 210:
    case 330:
      return push_rational(-1, 2);
    case 45:
    case 135:
      push_rational(1, 2);
      push_integer(2);
      push_rational(1, 2);
      power();
      return multiply();
    case 225:
    case 315:
      push_rational(-1, 2);
      push_integer(2);
      push_rational(1, 2);
      power();
      return multiply();
    case 60:
    case 120:
      push_rational(1, 2);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 240:
    case 300:
      push_rational(-1, 2);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 90:
      return push_integer(1);
    case 270:
      return push_integer(-1);
    default:
      push(symbol(SIN));
      push(p1);
      return list(2);
  }
};

test_sin = function() {
  return run_test(["sin(x)", "sin(x)", "sin(-x)", "-sin(x)", "sin(b-a)", "-sin(a-b)", "f(a,x)=1+sin(float(a/360*2*pi))-float(x)+sin(a/360*2*pi)-x", "", "f(0,0)", "1", "f(90,1)", "1", "f(180,0)", "1", "f(270,-1)", "1", "f(360,0)", "1", "f(-90,-1)", "1", "f(-180,0)", "1", "f(-270,1)", "1", "f(-360,0)", "1", "f(45,sqrt(2)/2)", "1", "f(135,sqrt(2)/2)", "1", "f(225,-sqrt(2)/2)", "1", "f(315,-sqrt(2)/2)", "1", "f(-45,-sqrt(2)/2)", "1", "f(-135,-sqrt(2)/2)", "1", "f(-225,sqrt(2)/2)", "1", "f(-315,sqrt(2)/2)", "1", "f(30,1/2)", "1", "f(150,1/2)", "1", "f(210,-1/2)", "1", "f(330,-1/2)", "1", "f(-30,-1/2)", "1", "f(-150,-1/2)", "1", "f(-210,1/2)", "1", "f(-330,1/2)", "1", "f(60,sqrt(3)/2)", "1", "f(120,sqrt(3)/2)", "1", "f(240,-sqrt(3)/2)", "1", "f(300,-sqrt(3)/2)", "1", "f(-60,-sqrt(3)/2)", "1", "f(-120,-sqrt(3)/2)", "1", "f(-240,sqrt(3)/2)", "1", "f(-300,sqrt(3)/2)", "1", "f=quote(f)", "", "sin(arcsin(x))", "x", "sin(1/12*pi)", "sin(1/12*pi)", "sin(arctan(4/3))", "4/5", "sin(-arctan(4/3))", "-4/5", "sin(x-8/2*pi)", "sin(x)", "sin(x-7/2*pi)", "cos(x)", "sin(x-6/2*pi)", "-sin(x)", "sin(x-5/2*pi)", "-cos(x)", "sin(x-4/2*pi)", "sin(x)", "sin(x-3/2*pi)", "cos(x)", "sin(x-2/2*pi)", "-sin(x)", "sin(x-1/2*pi)", "-cos(x)", "sin(x+0/2*pi)", "sin(x)", "sin(x+1/2*pi)", "cos(x)", "sin(x+2/2*pi)", "-sin(x)", "sin(x+3/2*pi)", "-cos(x)", "sin(x+4/2*pi)", "sin(x)", "sin(x+5/2*pi)", "cos(x)", "sin(x+6/2*pi)", "-sin(x)", "sin(x+7/2*pi)", "-cos(x)", "sin(x+8/2*pi)", "sin(x)"]);
};

Eval_sinh = function() {
  push(cadr(p1));
  Eval();
  return ysinh();
};

ysinh = function() {
  save();
  yysinh();
  return restore();
};

yysinh = function() {
  var d;
  d = 0.0;
  p1 = pop();
  if (car(p1) === symbol(ARCSINH)) {
    push(cadr(p1));
    return;
  }
  if (isdouble(p1)) {
    d = Math.sinh(p1.d);
    if (Math.abs(d) < 1e-10) {
      d = 0.0;
    }
    push_double(d);
    return;
  }
  if (iszero(p1)) {
    push(zero);
    return;
  }
  push_symbol(SINH);
  push(p1);
  return list(2);
};

test_sinh = function() {
  return run_test(["sinh(x)", "sinh(x)", "sinh(0)", "0", "sinh(arcsinh(x))", "x"]);
};

tos = 0;

nil_symbols = 0;

push = function(p) {
  if (p == null) {
    debugger;
  }
  if (p.isZero != null) {
    debugger;
  }
  if (p === symbol(NIL)) {
    nil_symbols++;
    console.log("pushing symbol(NIL) #" + nil_symbols);
    if (nil_symbols === 827) {
      debugger;
    }
  }
  if (tos >= frame) {
    stop("stack overflow");
  }
  return stack[tos++] = p;
};

pop = function() {
  var elementToBeReturned;
  if (tos === 0) {
    debugger;
    stop("stack underflow");
  }
  if (stack[tos - 1] == null) {
    debugger;
  }
  elementToBeReturned = stack[--tos];
  return elementToBeReturned;
};

push_frame = function(n) {
  var ae, i, ref2, results;
  i = 0;
  frame -= n;
  if (frame < tos) {
    debugger;
    stop("frame overflow, circular reference?");
  }
  results = [];
  for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    results.push(stack[frame + i] = symbol(NIL));
  }
  return results;
};

pop_frame = function(n) {
  frame += n;
  if (frame > TOS) {
    return stop("frame underflow");
  }
};

save = function() {
  frame -= 10;
  if (frame < tos) {
    debugger;
    stop("frame overflow, circular reference?");
  }
  stack[frame + 0] = p0;
  stack[frame + 1] = p1;
  stack[frame + 2] = p2;
  stack[frame + 3] = p3;
  stack[frame + 4] = p4;
  stack[frame + 5] = p5;
  stack[frame + 6] = p6;
  stack[frame + 7] = p7;
  stack[frame + 8] = p8;
  return stack[frame + 9] = p9;
};

restore = function() {
  if (frame > TOS - 10) {
    stop("frame underflow");
  }
  p0 = stack[frame + 0];
  p1 = stack[frame + 1];
  p2 = stack[frame + 2];
  p3 = stack[frame + 3];
  p4 = stack[frame + 4];
  p5 = stack[frame + 5];
  p6 = stack[frame + 6];
  p7 = stack[frame + 7];
  p8 = stack[frame + 8];
  p9 = stack[frame + 9];
  return frame += 10;
};

swap = function() {
  var p, q;
  p = pop();
  q = pop();
  push(p);
  return push(q);
};

dupl = function() {
  var p;
  p = pop();
  push(p);
  return push(p);
};


/*
	Substitute new expr for old expr in expr.

	Input:	push	expr

		push	old expr

		push	new expr

	Output:	Result on stack
 */

subst = function() {
  var ae, af, i, ref2, ref3;
  i = 0;
  save();
  p3 = pop();
  p2 = pop();
  if (p2 === symbol(NIL) || p3 === symbol(NIL)) {
    restore();
    return;
  }
  p1 = pop();
  if (istensor(p1)) {
    p4 = alloc_tensor(p1.tensor.nelem);
    p4.tensor.ndim = p1.tensor.ndim;
    for (i = ae = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      p4.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = af = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
      push(p1.tensor.elem[i]);
      push(p2);
      push(p3);
      subst();
      p4.tensor.elem[i] = pop();
      if (p4.tensor.nelem !== p4.tensor.elem.length) {
        console.log("something wrong in tensor dimensions");
        debugger;
      }
    }
    push(p4);
  } else if (equal(p1, p2)) {
    push(p3);
  } else if (iscons(p1)) {
    push(car(p1));
    push(p2);
    push(p3);
    subst();
    push(cdr(p1));
    push(p2);
    push(p3);
    subst();
    cons();
  } else {
    push(p1);
  }
  return restore();
};

std_symbol = function(s, n) {
  var p;
  p = symtab[n];
  if (p == null) {
    debugger;
  }
  return p.printname = s;
};

usr_symbol = function(s) {
  var ae, i, p, ref2;
  i = 0;
  for (i = ae = 0, ref2 = NSYM; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    if (symtab[i].printname === "") {
      break;
    }
    if (s === symtab[i].printname) {
      return symtab[i];
    }
  }
  if (i === NSYM) {
    stop("symbol table overflow");
  }
  p = symtab[i];
  p.printname = s;
  return p;
};

get_printname = function(p) {
  if (p.k !== SYM) {
    stop("symbol error");
  }
  return p.printname;
};

set_binding = function(p, q) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> set_binding lookup " + indexFound);
  binding[indexFound] = q;
  return arglist[indexFound] = symbol(NIL);
};

get_binding = function(p) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> get_binding lookup " + indexFound);
  if (indexFound === 139) {
    debugger;
  }
  return binding[indexFound];
};

set_binding_and_arglist = function(p, q, r) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> set_binding_and_arglist lookup " + indexFound);
  binding[indexFound] = q;
  return arglist[indexFound] = r;
};

get_arglist = function(p) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> get_arglist lookup " + indexFound);
  return arglist[indexFound];
};

lookupsTotal = 0;

symnum = function(p) {
  var indexFound;
  lookupsTotal++;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> symnum lookup " + indexFound + " lookup # " + lookupsTotal);
  if (lookupsTotal === 19) {
    debugger;
  }
  return indexFound;
};

push_symbol = function(k) {
  return push(symtab[k]);
};

clear_symbols = function() {
  var ae, i, ref2, results;
  i = 0;
  results = [];
  for (i = ae = 0, ref2 = NSYM; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    binding[i] = symtab[i];
    results.push(arglist[i] = symbol(NIL));
  }
  return results;
};

Eval_tan = function() {
  push(cadr(p1));
  Eval();
  return tangent();
};

tangent = function() {
  save();
  yytangent();
  return restore();
};

yytangent = function() {
  var d, n;
  n = 0;
  d = 0.0;
  p1 = pop();
  if (car(p1) === symbol(ARCTAN)) {
    push(cadr(p1));
    return;
  }
  if (isdouble(p1)) {
    d = Math.tan(p1.d);
    if (Math.abs(d) < 1e-10) {
      d = 0.0;
    }
    push_double(d);
    return;
  }
  if (isnegative(p1)) {
    push(p1);
    negate();
    tangent();
    negate();
    return;
  }
  push(p1);
  push_integer(180);
  multiply();
  push_symbol(PI);
  divide();
  n = pop_integer();
  if (n < 0 || n === 0x80000000) {
    push(symbol(TAN));
    push(p1);
    list(2);
    return;
  }
  switch (n % 360) {
    case 0:
    case 180:
      return push_integer(0);
    case 30:
    case 210:
      push_rational(1, 3);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 150:
    case 330:
      push_rational(-1, 3);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 45:
    case 225:
      return push_integer(1);
    case 135:
    case 315:
      return push_integer(-1);
    case 60:
    case 240:
      push_integer(3);
      push_rational(1, 2);
      return power();
    case 120:
    case 300:
      push_integer(3);
      push_rational(1, 2);
      power();
      return negate();
    default:
      push(symbol(TAN));
      push(p1);
      return list(2);
  }
};

test_tan = function() {
  return run_test(["tan(x)", "tan(x)", "tan(-x)", "-tan(x)", "tan(b-a)", "-tan(a-b)", "f(a,x)=1+tan(float(a/360*2*pi))-float(x)+tan(a/360*2*pi)-x", "", "f(0,0)", "1", "f(180,0)", "1", "f(360,0)", "1", "f(-180,0)", "1", "f(-360,0)", "1", "f(45,1)", "1", "f(135,-1)", "1", "f(225,1)", "1", "f(315,-1)", "1", "f(-45,-1)", "1", "f(-135,1)", "1", "f(-225,-1)", "1", "f(-315,1)", "1", "f(30,sqrt(3)/3)", "1", "f(150,-sqrt(3)/3)", "1", "f(210,sqrt(3)/3)", "1", "f(330,-sqrt(3)/3)", "1", "f(-30,-sqrt(3)/3)", "1", "f(-150,sqrt(3)/3)", "1", "f(-210,-sqrt(3)/3)", "1", "f(-330,sqrt(3)/3)", "1", "f(60,sqrt(3))", "1", "f(120,-sqrt(3))", "1", "f(240,sqrt(3))", "1", "f(300,-sqrt(3))", "1", "f(-60,-sqrt(3))", "1", "f(-120,sqrt(3))", "1", "f(-240,-sqrt(3))", "1", "f(-300,sqrt(3))", "1", "f=quote(f)", "", "tan(arctan(x))", "x", "tan(1/12*pi)", "tan(1/12*pi)"]);
};

Eval_tanh = function() {
  var d;
  d = 0.0;
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (car(p1) === symbol(ARCTANH)) {
    push(cadr(p1));
    return;
  }
  if (isdouble(p1)) {
    d = Math.tanh(p1.d);
    if (Math.abs(d) < 1e-10) {
      d = 0.0;
    }
    push_double(d);
    return;
  }
  if (iszero(p1)) {
    push(zero);
    return;
  }
  push_symbol(TANH);
  push(p1);
  return list(2);
};

test_tanh = function() {
  return run_test(["tanh(x)", "tanh(x)", "tanh(0)", "0", "tanh(arctanh(x))", "x"]);
};


/*
Taylor expansion of a function

	push(F)
	push(X)
	push(N)
	push(A)
	taylor()
 */

Eval_taylor = function() {
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    guess();
  } else {
    push(p2);
  }
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    push_integer(24);
  } else {
    push(p2);
  }
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    push_integer(0);
  } else {
    push(p2);
  }
  return taylor();
};

taylor = function() {
  var ae, i, k, ref2;
  i = 0;
  k = 0;
  save();
  p4 = pop();
  p3 = pop();
  p2 = pop();
  p1 = pop();
  push(p3);
  k = pop_integer();
  if (k === 0x80000000) {
    push_symbol(TAYLOR);
    push(p1);
    push(p2);
    push(p3);
    push(p4);
    list(5);
    restore();
    return;
  }
  push(p1);
  push(p2);
  push(p4);
  subst();
  Eval();
  push_integer(1);
  p5 = pop();
  for (i = ae = 1, ref2 = k; 1 <= ref2 ? ae <= ref2 : ae >= ref2; i = 1 <= ref2 ? ++ae : --ae) {
    push(p1);
    push(p2);
    derivative();
    p1 = pop();
    if (iszero(p1)) {
      break;
    }
    push(p5);
    push(p2);
    push(p4);
    subtract();
    multiply();
    p5 = pop();
    push(p1);
    push(p2);
    push(p4);
    subst();
    Eval();
    push(p5);
    multiply();
    push_integer(i);
    factorial();
    divide();
    add();
  }
  return restore();
};

test_taylor = function() {
  return run_test(["taylor(1/(5+4*cos(x)),x,6,0)-(1/9+2/81*x^2+5/1458*x^4+49/131220*x^6)", "0", "taylor(1/(5+4*cos(x)),x,6)-(1/9+2/81*x^2+5/1458*x^4+49/131220*x^6)", "0"]);
};

Eval_tensor = function() {
  var a, ae, af, b, i, ndim, nelem, ref2, ref3;
  i = 0;
  ndim = 0;
  nelem = 0;
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  nelem = p1.tensor.nelem;
  ndim = p1.tensor.ndim;
  p2 = alloc_tensor(nelem);
  p2.tensor.ndim = ndim;
  for (i = ae = 0, ref2 = ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p2.tensor.dim[i] = p1.tensor.dim[i];
  }
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  for (i = af = 0, ref3 = nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    push(a[i]);
    Eval();
    b[i] = pop();
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  push(p2);
  return promote_tensor();
};

tensor_plus_tensor = function() {
  var a, ae, af, ag, b, c, i, ndim, nelem, ref2, ref3, ref4;
  i = 0;
  ndim = 0;
  nelem = 0;
  save();
  p2 = pop();
  p1 = pop();
  ndim = p1.tensor.ndim;
  if (ndim !== p2.tensor.ndim) {
    push(symbol(NIL));
    restore();
    return;
  }
  for (i = ae = 0, ref2 = ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {
      push(symbol(NIL));
      restore();
      return;
    }
  }
  nelem = p1.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = af = 0, ref3 = ndim; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  c = p3.tensor.elem;
  for (i = ag = 0, ref4 = nelem; 0 <= ref4 ? ag < ref4 : ag > ref4; i = 0 <= ref4 ? ++ag : --ag) {
    push(a[i]);
    push(b[i]);
    add();
    c[i] = pop();
  }
  push(p3);
  return restore();
};

tensor_times_scalar = function() {
  var a, ae, af, b, i, ndim, nelem, ref2, ref3;
  i = 0;
  ndim = 0;
  nelem = 0;
  save();
  p2 = pop();
  p1 = pop();
  ndim = p1.tensor.ndim;
  nelem = p1.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = ae = 0, ref2 = ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  a = p1.tensor.elem;
  b = p3.tensor.elem;
  for (i = af = 0, ref3 = nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    push(a[i]);
    push(p2);
    multiply();
    b[i] = pop();
  }
  push(p3);
  return restore();
};

scalar_times_tensor = function() {
  var a, ae, af, b, i, ndim, nelem, ref2, ref3;
  i = 0;
  ndim = 0;
  nelem = 0;
  save();
  p2 = pop();
  p1 = pop();
  ndim = p2.tensor.ndim;
  nelem = p2.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = ae = 0, ref2 = ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p3.tensor.dim[i] = p2.tensor.dim[i];
  }
  a = p2.tensor.elem;
  b = p3.tensor.elem;
  for (i = af = 0, ref3 = nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    push(p1);
    push(a[i]);
    multiply();
    b[i] = pop();
  }
  push(p3);
  return restore();
};

is_square_matrix = function(p) {
  if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {
    return 1;
  } else {
    return 0;
  }
};

d_tensor_tensor = function() {
  var a, ae, af, ag, b, c, i, j, ndim, nelem, ref2, ref3, ref4;
  i = 0;
  j = 0;
  ndim = 0;
  nelem = 0;
  ndim = p1.tensor.ndim;
  nelem = p1.tensor.nelem;
  if (ndim + 1 >= MAXDIM) {
    push_symbol(DERIVATIVE);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  p3 = alloc_tensor(nelem * p2.tensor.nelem);
  p3.tensor.ndim = ndim + 1;
  for (i = ae = 0, ref2 = ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  p3.tensor.dim[ndim] = p2.tensor.dim[0];
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  c = p3.tensor.elem;
  for (i = af = 0, ref3 = nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    for (j = ag = 0, ref4 = p2.tensor.nelem; 0 <= ref4 ? ag < ref4 : ag > ref4; j = 0 <= ref4 ? ++ag : --ag) {
      push(a[i]);
      push(b[j]);
      derivative();
      c[i * p2.tensor.nelem + j] = pop();
    }
  }
  return push(p3);
};

d_scalar_tensor = function() {
  var a, ae, b, i, ref2;
  p3 = alloc_tensor(p2.tensor.nelem);
  p3.tensor.ndim = 1;
  p3.tensor.dim[0] = p2.tensor.dim[0];
  a = p2.tensor.elem;
  b = p3.tensor.elem;
  for (i = ae = 0, ref2 = p2.tensor.nelem; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    push(p1);
    push(a[i]);
    derivative();
    b[i] = pop();
  }
  return push(p3);
};

d_tensor_scalar = function() {
  var a, ae, af, b, i, ref2, ref3;
  i = 0;
  p3 = alloc_tensor(p1.tensor.nelem);
  p3.tensor.ndim = p1.tensor.ndim;
  for (i = ae = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  a = p1.tensor.elem;
  b = p3.tensor.elem;
  for (i = af = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    push(a[i]);
    push(p2);
    derivative();
    b[i] = pop();
  }
  return push(p3);
};

compare_tensors = function(p1, p2) {
  var ae, af, i, ref2, ref3;
  i = 0;
  if (p1.tensor.ndim < p2.tensor.ndim) {
    return -1;
  }
  if (p1.tensor.ndim > p2.tensor.ndim) {
    return 1;
  }
  for (i = ae = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    if (p1.tensor.dim[i] < p2.tensor.dim[i]) {
      return -1;
    }
    if (p1.tensor.dim[i] > p2.tensor.dim[i]) {
      return 1;
    }
  }
  for (i = af = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {
      continue;
    }
    if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {
      return -1;
    } else {
      return 1;
    }
  }
  return 0;
};

power_tensor = function() {
  var ae, af, i, k, n, ref2, ref3, results;
  i = 0;
  k = 0;
  n = 0;
  k = p1.tensor.ndim - 1;
  if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {
    push_symbol(POWER);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  push(p2);
  n = pop_integer();
  if (n === 0x80000000) {
    push_symbol(POWER);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  if (n === 0) {
    if (p1.tensor.ndim !== 2) {
      stop("power(tensor,0) with tensor rank not equal to 2");
    }
    n = p1.tensor.dim[0];
    p1 = alloc_tensor(n * n);
    p1.tensor.ndim = 2;
    p1.tensor.dim[0] = n;
    p1.tensor.dim[1] = n;
    for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      p1.tensor.elem[n * i + i] = one;
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p1);
    return;
  }
  if (n < 0) {
    n = -n;
    push(p1);
    inv();
    p1 = pop();
  }
  push(p1);
  results = [];
  for (i = af = 1, ref3 = n; 1 <= ref3 ? af < ref3 : af > ref3; i = 1 <= ref3 ? ++af : --af) {
    push(p1);
    inner();
    if (iszero(stack[tos - 1])) {
      break;
    } else {
      results.push(void 0);
    }
  }
  return results;
};

copy_tensor = function() {
  var ae, af, i, ref2, ref3;
  i = 0;
  save();
  p1 = pop();
  p2 = alloc_tensor(p1.tensor.nelem);
  p2.tensor.ndim = p1.tensor.ndim;
  for (i = ae = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    p2.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (i = af = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    p2.tensor.elem[i] = p1.tensor.elem[i];
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  push(p2);
  return restore();
};

promote_tensor = function() {
  var ae, af, ag, ah, aj, i, j, k, ndim, nelem, ref2, ref3, ref4, ref5, ref6;
  i = 0;
  j = 0;
  k = 0;
  nelem = 0;
  ndim = 0;
  save();
  p1 = pop();
  if (!istensor(p1)) {
    push(p1);
    restore();
    return;
  }
  p2 = p1.tensor.elem[0];
  for (i = ae = 1, ref2 = p1.tensor.nelem; 1 <= ref2 ? ae < ref2 : ae > ref2; i = 1 <= ref2 ? ++ae : --ae) {
    if (!compatible(p2, p1.tensor.elem[i])) {
      stop("Cannot promote tensor due to inconsistent tensor components.");
    }
  }
  if (!istensor(p2)) {
    push(p1);
    restore();
    return;
  }
  ndim = p1.tensor.ndim + p2.tensor.ndim;
  if (ndim > MAXDIM) {
    stop("tensor rank > 24");
  }
  nelem = p1.tensor.nelem * p2.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = af = 0, ref3 = p1.tensor.ndim; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (j = ag = 0, ref4 = p2.tensor.ndim; 0 <= ref4 ? ag < ref4 : ag > ref4; j = 0 <= ref4 ? ++ag : --ag) {
    p3.tensor.dim[i + j] = p2.tensor.dim[j];
  }
  k = 0;
  for (i = ah = 0, ref5 = p1.tensor.nelem; 0 <= ref5 ? ah < ref5 : ah > ref5; i = 0 <= ref5 ? ++ah : --ah) {
    p2 = p1.tensor.elem[i];
    for (j = aj = 0, ref6 = p2.tensor.nelem; 0 <= ref6 ? aj < ref6 : aj > ref6; j = 0 <= ref6 ? ++aj : --aj) {
      p3.tensor.elem[k++] = p2.tensor.elem[j];
    }
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p3.tensor.nelem !== p3.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  push(p3);
  return restore();
};

compatible = function(p, q) {
  var ae, i, ref2;
  if (!istensor(p) && !istensor(q)) {
    return 1;
  }
  if (!istensor(p) || !istensor(q)) {
    return 0;
  }
  if (p.tensor.ndim !== q.tensor.ndim) {
    return 0;
  }
  for (i = ae = 0, ref2 = p.tensor.ndim; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    if (p.tensor.dim[i] !== q.tensor.dim[i]) {
      return 0;
    }
  }
  return 1;
};

test_tensor = function() {
  return run_test(["a=(1,2,3)", "", "b=(4,5,6)", "", "c=(7,8,9)", "", "rank((a,b,c))", "2", "(a,b,c)", "((1,2,3),(4,5,6),(7,8,9))", "((1,0),(0,0))", "((1,0),(0,0))", "a=quote(a)", "", "b=quote(b)", "", "c=quote(c)", ""]);
};

Eval_test = function() {
  p1 = cdr(p1);
  while (iscons(p1)) {
    if (cdr(p1) === symbol(NIL)) {
      push(car(p1));
      Eval();
      return;
    }
    push(car(p1));
    Eval_predicate();
    p2 = pop();
    if (!iszero(p2)) {
      push(cadr(p1));
      Eval();
      return;
    }
    p1 = cddr(p1);
  }
  return push_integer(0);
};

Eval_testeq = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  subtract();
  p1 = pop();
  if (iszero(p1)) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_testge = function() {
  if (cmp_args() >= 0) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_testgt = function() {
  if (cmp_args() > 0) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_testle = function() {
  if (cmp_args() <= 0) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_testlt = function() {
  if (cmp_args() < 0) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_not = function() {
  push(cadr(p1));
  Eval_predicate();
  p1 = pop();
  if (iszero(p1)) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_and = function() {
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval_predicate();
    p2 = pop();
    if (iszero(p2)) {
      push_integer(0);
      return;
    }
    p1 = cdr(p1);
  }
  return push_integer(1);
};

Eval_or = function() {
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval_predicate();
    p2 = pop();
    if (!iszero(p2)) {
      push_integer(1);
      return;
    }
    p1 = cdr(p1);
  }
  return push_integer(0);
};

cmp_args = function() {
  var t;
  t = 0;
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  subtract();
  p1 = pop();
  if (p1.k !== NUM && p1.k !== DOUBLE) {
    push(p1);
    yyfloat();
    Eval();
    p1 = pop();
  }
  if (iszero(p1)) {
    return 0;
  }
  switch (p1.k) {
    case NUM:
      if (MSIGN(p1.q.a) === -1) {
        t = -1;
      } else {
        t = 1;
      }
      break;
    case DOUBLE:
      if (p1.d < 0.0) {
        t = -1;
      } else {
        t = 1;
      }
      break;
    default:
      stop("relational operator: cannot determine due to non-numerical comparison");
      t = 0;
  }
  return t;
};

test_test = function() {
  return run_test(["a<a+1", "1", "a-1<a", "1", "1==1", "1", "1==2", "0", "1>=1", "1", "1>=2", "0", "2>=1", "1", "1>1", "0", "1>2", "0", "2>1", "1", "1<=1", "1", "1<=2", "1", "2<=1", "0", "1<1", "0", "1<2", "1", "2<1", "0", "test(0,A,B)", "B", "test(1,A,B)", "A", "test(0,A,0,B)", "0", "test(0,A,0,B,C)", "C", "not(1)", "0", "not(0)", "1", "not(a=a)", "0", "and(1,1)", "1", "and(1,0)", "0", "or(1,0)", "1", "or(0,0)", "0", "(0,0)==0", "1", "1<sqrt(3)", "1"]);
};


/*
Transform an expression using table look-up

The expression and free variable are on the stack.

The argument s is a null terminated list of transform rules.

For example, see itab.cpp

Internally, the following symbols are used:

	F	input expression

	X	free variable, i.e. F of X

	A	template expression

	B	result expression

	C	list of conditional expressions
 */

transform = function(s) {
  var ae, eachEntry, h, len1;
  h = 0;
  save();
  p4 = pop();
  p3 = pop();
  push(get_binding(symbol(METAA)));
  push(get_binding(symbol(METAB)));
  push(get_binding(symbol(METAX)));
  set_binding(symbol(METAX), p4);
  h = tos;
  push_integer(1);
  push(p3);
  push(p4);
  polyform();
  push(p4);
  decomp();
  for (ae = 0, len1 = s.length; ae < len1; ae++) {
    eachEntry = s[ae];
    console.log("scanning table entry " + eachEntry);
    if (eachEntry) {
      scan_meta(eachEntry);
      p1 = pop();
      p5 = cadr(p1);
      p6 = caddr(p1);
      p7 = cdddr(p1);
      if (f_equals_a(h)) {
        break;
      }
    }
  }
  tos = h;
  if (eachEntry) {
    push(p6);
    Eval();
    p1 = pop();
  } else {
    p1 = symbol(NIL);
  }
  set_binding(symbol(METAX), pop());
  set_binding(symbol(METAB), pop());
  set_binding(symbol(METAA), pop());
  push(p1);
  return restore();
};

f_equals_a = function(h) {
  var ae, af, i, j, ref2, ref3, ref4, ref5;
  i = 0;
  j = 0;
  for (i = ae = ref2 = h, ref3 = tos; ref2 <= ref3 ? ae < ref3 : ae > ref3; i = ref2 <= ref3 ? ++ae : --ae) {
    set_binding(symbol(METAA), stack[i]);
    for (j = af = ref4 = h, ref5 = tos; ref4 <= ref5 ? af < ref5 : af > ref5; j = ref4 <= ref5 ? ++af : --af) {
      set_binding(symbol(METAB), stack[j]);
      p1 = p7;
      while (iscons(p1)) {
        push(car(p1));
        Eval();
        p2 = pop();
        if (iszero(p2)) {
          break;
        }
        p1 = cdr(p1);
      }
      if (iscons(p1)) {
        continue;
      }
      push(p3);
      push(p5);
      Eval();
      subtract();
      p1 = pop();
      if (iszero(p1)) {
        return 1;
      }
    }
  }
  return 0;
};

Eval_transpose = function() {
  push(cadr(p1));
  Eval();
  if (cddr(p1) === symbol(NIL)) {
    push_integer(1);
    push_integer(2);
  } else {
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
  }
  return transpose();
};

transpose = function() {
  var a, ae, af, ag, ah, ai, aj, al, an, b, i, j, k, l, m, ndim, nelem, ref2, ref3, ref4, ref5, ref6, ref7, t;
  i = 0;
  j = 0;
  k = 0;
  l = 0;
  m = 0;
  ndim = 0;
  nelem = 0;
  t = 0;
  ai = [];
  an = [];
  for (i = ae = 0, ref2 = MAXDIM; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    ai[i] = 0;
    an[i] = 0;
  }
  save();
  p3 = pop();
  p2 = pop();
  p1 = pop();
  if (!istensor(p1)) {
    if (!iszero(p1)) {
      stop("transpose: tensor expected, 1st arg is not a tensor");
    }
    push(zero);
    restore();
    return;
  }
  ndim = p1.tensor.ndim;
  nelem = p1.tensor.nelem;
  if (ndim === 1) {
    push(p1);
    restore();
    return;
  }
  push(p2);
  l = pop_integer();
  push(p3);
  m = pop_integer();
  if (l < 1 || l > ndim || m < 1 || m > ndim) {
    stop("transpose: index out of range");
  }
  l--;
  m--;
  p2 = alloc_tensor(nelem);
  p2.tensor.ndim = ndim;
  for (i = af = 0, ref3 = ndim; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    p2.tensor.dim[i] = p1.tensor.dim[i];
  }
  p2.tensor.dim[l] = p1.tensor.dim[m];
  p2.tensor.dim[m] = p1.tensor.dim[l];
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  for (i = ag = 0, ref4 = ndim; 0 <= ref4 ? ag < ref4 : ag > ref4; i = 0 <= ref4 ? ++ag : --ag) {
    ai[i] = 0;
    an[i] = p1.tensor.dim[i];
  }
  for (i = ah = 0, ref5 = nelem; 0 <= ref5 ? ah < ref5 : ah > ref5; i = 0 <= ref5 ? ++ah : --ah) {
    t = ai[l];
    ai[l] = ai[m];
    ai[m] = t;
    t = an[l];
    an[l] = an[m];
    an[m] = t;
    k = 0;
    for (j = aj = 0, ref6 = ndim; 0 <= ref6 ? aj < ref6 : aj > ref6; j = 0 <= ref6 ? ++aj : --aj) {
      k = (k * an[j]) + ai[j];
    }
    t = ai[l];
    ai[l] = ai[m];
    ai[m] = t;
    t = an[l];
    an[l] = an[m];
    an[m] = t;
    b[k] = a[i];
    for (j = al = ref7 = ndim - 1; ref7 <= 0 ? al <= 0 : al >= 0; j = ref7 <= 0 ? ++al : --al) {
      if (++ai[j] < an[j]) {
        break;
      }
      ai[j] = 0;
    }
  }
  push(p2);
  return restore();
};

test_transpose = function() {
  return run_test(["transpose(0)", "0", "transpose(0.0)", "0", "transpose(((a,b),(c,d)))", "((a,c),(b,d))", "transpose(((a,b),(c,d)),1,2)", "((a,c),(b,d))", "transpose(((a,b,c),(d,e,f)),1,2)", "((a,d),(b,e),(c,f))", "transpose(((a,d),(b,e),(c,f)),1,2)", "((a,b,c),(d,e,f))", "transpose((a,b,c))", "(a,b,c)"]);
};

Eval_user_function = function() {
  var h;
  if (car(p1) === symbol(SYMBOL_D) && get_arglist(symbol(SYMBOL_D)) === symbol(NIL)) {
    Eval_derivative();
    return;
  }
  p3 = get_binding(car(p1));
  p4 = get_arglist(car(p1));
  p5 = cdr(p1);
  if (p3 === car(p1)) {
    h = tos;
    push(p3);
    p1 = p5;
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p1 = cdr(p1);
    }
    list(tos - h);
    return;
  }
  p1 = p4;
  p2 = p5;
  h = tos;
  while (iscons(p1) && iscons(p2)) {
    push(car(p1));
    push(car(p2));
    Eval();
    p1 = cdr(p1);
    p2 = cdr(p2);
  }
  list(tos - h);
  p6 = pop();
  push(p3);
  if (iscons(p6)) {
    push(p6);
    rewrite_args();
  }
  return Eval();
};

rewrite_args = function() {
  var h, n;
  n = 0;
  save();
  p2 = pop();
  p1 = pop();
  if (istensor(p1)) {
    n = rewrite_args_tensor();
    restore();
    return n;
  }
  if (iscons(p1)) {
    h = tos;
    push(car(p1));
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      n += rewrite_args();
      p1 = cdr(p1);
    }
    list(tos - h);
    restore();
    return n;
  }
  if (!issymbol(p1)) {
    push(p1);
    restore();
    return 0;
  }
  p3 = p2;
  while (iscons(p3)) {
    if (p1 === car(p3)) {
      push(cadr(p3));
      restore();
      return 1;
    }
    p3 = cddr(p3);
  }
  p3 = get_binding(p1);
  push(p3);
  if (p1 !== p3) {
    push(p2);
    n = rewrite_args();
    if (n === 0) {
      pop();
      push(p1);
    }
  }
  restore();
  return n;
};

rewrite_args_tensor = function() {
  var ae, i, n, ref2;
  n = 0;
  i = 0;
  push(p1);
  copy_tensor();
  p1 = pop();
  for (i = ae = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    push(p1.tensor.elem[i]);
    push(p2);
    n += rewrite_args();
    p1.tensor.elem[i] = pop();
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  push(p1);
  return n;
};

Eval_zero = function() {
  var ae, af, i, k, m, n, ref2, ref3;
  i = 0;
  k = [];
  m = 0;
  n = 0;
  for (i = ae = 0, ref2 = MAXDIM; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
    k[i] = 0;
  }
  m = 1;
  n = 0;
  p2 = cdr(p1);
  while (iscons(p2)) {
    push(car(p2));
    Eval();
    i = pop_integer();
    if (i < 2) {
      push(zero);
      return;
    }
    m *= i;
    k[n++] = i;
    p2 = cdr(p2);
  }
  if (n === 0) {
    push(zero);
    return;
  }
  p1 = alloc_tensor(m);
  p1.tensor.ndim = n;
  for (i = af = 0, ref3 = n; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
    p1.tensor.dim[i] = k[i];
  }
  return push(p1);
};

test_zero = function() {
  return run_test(["zero(2,2)", "((0,0),(0,0))", "zero(1,1)", "0"]);
};
